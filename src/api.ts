// tslint:disable
/**
 * Kill Bill
 * Kill Bill is an open-source billing and payments platform
 *
 * The version of the OpenAPI document: 0.21.6-SNAPSHOT
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    accountId?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    firstNameLength?: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    externalKey?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    email?: string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    billCycleDayLocal?: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    currency?: AccountCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    parentAccountId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    isPaymentDelegatedToParent?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    paymentMethodId?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    referenceTime?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    timeZone?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    address1?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    company?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    locale?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    notes?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    isMigrated?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    accountBalance?: number;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    accountCBA?: number;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof Account
     */
    auditLogs?: Array<AuditLog>;
}

/**
    * @export
    * @enum {string}
    */
export enum AccountCurrencyEnum {
    AED = 'AED',
    AFN = 'AFN',
    ALL = 'ALL',
    AMD = 'AMD',
    ANG = 'ANG',
    AOA = 'AOA',
    ARS = 'ARS',
    AUD = 'AUD',
    AWG = 'AWG',
    AZN = 'AZN',
    BAM = 'BAM',
    BBD = 'BBD',
    BDT = 'BDT',
    BGN = 'BGN',
    BHD = 'BHD',
    BIF = 'BIF',
    BMD = 'BMD',
    BND = 'BND',
    BOB = 'BOB',
    BRL = 'BRL',
    BSD = 'BSD',
    BTN = 'BTN',
    BWP = 'BWP',
    BYR = 'BYR',
    BZD = 'BZD',
    CAD = 'CAD',
    CDF = 'CDF',
    CHF = 'CHF',
    CLP = 'CLP',
    CNY = 'CNY',
    COP = 'COP',
    CRC = 'CRC',
    CUC = 'CUC',
    CUP = 'CUP',
    CVE = 'CVE',
    CZK = 'CZK',
    DJF = 'DJF',
    DKK = 'DKK',
    DOP = 'DOP',
    DZD = 'DZD',
    EGP = 'EGP',
    ERN = 'ERN',
    ETB = 'ETB',
    EUR = 'EUR',
    FJD = 'FJD',
    FKP = 'FKP',
    GBP = 'GBP',
    GEL = 'GEL',
    GGP = 'GGP',
    GHS = 'GHS',
    GIP = 'GIP',
    GMD = 'GMD',
    GNF = 'GNF',
    GTQ = 'GTQ',
    GYD = 'GYD',
    HKD = 'HKD',
    HNL = 'HNL',
    HRK = 'HRK',
    HTG = 'HTG',
    HUF = 'HUF',
    IDR = 'IDR',
    ILS = 'ILS',
    IMP = 'IMP',
    INR = 'INR',
    IQD = 'IQD',
    IRR = 'IRR',
    ISK = 'ISK',
    JEP = 'JEP',
    JMD = 'JMD',
    JOD = 'JOD',
    JPY = 'JPY',
    KES = 'KES',
    KGS = 'KGS',
    KHR = 'KHR',
    KMF = 'KMF',
    KPW = 'KPW',
    KRW = 'KRW',
    KWD = 'KWD',
    KYD = 'KYD',
    KZT = 'KZT',
    LAK = 'LAK',
    LBP = 'LBP',
    LKR = 'LKR',
    LRD = 'LRD',
    LSL = 'LSL',
    LTL = 'LTL',
    LVL = 'LVL',
    LYD = 'LYD',
    MAD = 'MAD',
    MDL = 'MDL',
    MGA = 'MGA',
    MKD = 'MKD',
    MMK = 'MMK',
    MNT = 'MNT',
    MOP = 'MOP',
    MRO = 'MRO',
    MUR = 'MUR',
    MVR = 'MVR',
    MWK = 'MWK',
    MXN = 'MXN',
    MYR = 'MYR',
    MZN = 'MZN',
    NAD = 'NAD',
    NGN = 'NGN',
    NIO = 'NIO',
    NOK = 'NOK',
    NPR = 'NPR',
    NZD = 'NZD',
    OMR = 'OMR',
    PAB = 'PAB',
    PEN = 'PEN',
    PGK = 'PGK',
    PHP = 'PHP',
    PKR = 'PKR',
    PLN = 'PLN',
    PYG = 'PYG',
    QAR = 'QAR',
    RON = 'RON',
    RSD = 'RSD',
    RUB = 'RUB',
    RWF = 'RWF',
    SAR = 'SAR',
    SBD = 'SBD',
    SCR = 'SCR',
    SDG = 'SDG',
    SEK = 'SEK',
    SGD = 'SGD',
    SHP = 'SHP',
    SLL = 'SLL',
    SOS = 'SOS',
    SPL = 'SPL',
    SRD = 'SRD',
    STD = 'STD',
    SVC = 'SVC',
    SYP = 'SYP',
    SZL = 'SZL',
    THB = 'THB',
    TJS = 'TJS',
    TMT = 'TMT',
    TND = 'TND',
    TOP = 'TOP',
    TRY = 'TRY',
    TTD = 'TTD',
    TVD = 'TVD',
    TWD = 'TWD',
    TZS = 'TZS',
    UAH = 'UAH',
    UGX = 'UGX',
    USD = 'USD',
    UYU = 'UYU',
    UZS = 'UZS',
    VEF = 'VEF',
    VND = 'VND',
    VUV = 'VUV',
    WST = 'WST',
    XAF = 'XAF',
    XCD = 'XCD',
    XDR = 'XDR',
    XOF = 'XOF',
    XPF = 'XPF',
    YER = 'YER',
    ZAR = 'ZAR',
    ZMW = 'ZMW',
    ZWD = 'ZWD',
    BTC = 'BTC'
}

/**
 * 
 * @export
 * @interface AccountEmail
 */
export interface AccountEmail {
    /**
     * 
     * @type {string}
     * @memberof AccountEmail
     */
    accountId?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountEmail
     */
    email: string;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof AccountEmail
     */
    auditLogs?: Array<AuditLog>;
}
/**
 * 
 * @export
 * @interface AccountTimeline
 */
export interface AccountTimeline {
    /**
     * 
     * @type {Account}
     * @memberof AccountTimeline
     */
    account?: Account;
    /**
     * 
     * @type {Array<Bundle>}
     * @memberof AccountTimeline
     */
    bundles?: Array<Bundle>;
    /**
     * 
     * @type {Array<Invoice>}
     * @memberof AccountTimeline
     */
    invoices?: Array<Invoice>;
    /**
     * 
     * @type {Array<InvoicePayment>}
     * @memberof AccountTimeline
     */
    payments?: Array<InvoicePayment>;
}
/**
 * 
 * @export
 * @interface AdminPayment
 */
export interface AdminPayment {
    /**
     * 
     * @type {string}
     * @memberof AdminPayment
     */
    lastSuccessPaymentState?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminPayment
     */
    currentPaymentStateName?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminPayment
     */
    transactionStatus?: string;
}
/**
 * 
 * @export
 * @interface AuditLog
 */
export interface AuditLog {
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    changeType?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    changeDate?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    objectType?: AuditLogObjectTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    objectId?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    changedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    reasonCode?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    comments?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLog
     */
    userToken?: string;
    /**
     * 
     * @type {Entity}
     * @memberof AuditLog
     */
    history?: Entity;
}

/**
    * @export
    * @enum {string}
    */
export enum AuditLogObjectTypeEnum {
    ACCOUNT = 'ACCOUNT',
    ACCOUNTEMAIL = 'ACCOUNT_EMAIL',
    BLOCKINGSTATES = 'BLOCKING_STATES',
    BUNDLE = 'BUNDLE',
    CUSTOMFIELD = 'CUSTOM_FIELD',
    INVOICE = 'INVOICE',
    PAYMENT = 'PAYMENT',
    TRANSACTION = 'TRANSACTION',
    INVOICEITEM = 'INVOICE_ITEM',
    INVOICEPAYMENT = 'INVOICE_PAYMENT',
    SUBSCRIPTION = 'SUBSCRIPTION',
    SUBSCRIPTIONEVENT = 'SUBSCRIPTION_EVENT',
    SERVICEBROADCAST = 'SERVICE_BROADCAST',
    PAYMENTATTEMPT = 'PAYMENT_ATTEMPT',
    PAYMENTMETHOD = 'PAYMENT_METHOD',
    TAG = 'TAG',
    TAGDEFINITION = 'TAG_DEFINITION',
    TENANT = 'TENANT',
    TENANTKVS = 'TENANT_KVS'
}

/**
 * 
 * @export
 * @interface BlockPrice
 */
export interface BlockPrice {
    /**
     * 
     * @type {string}
     * @memberof BlockPrice
     */
    unitName?: string;
    /**
     * 
     * @type {number}
     * @memberof BlockPrice
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof BlockPrice
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof BlockPrice
     */
    max?: number;
}
/**
 * 
 * @export
 * @interface BlockingState
 */
export interface BlockingState {
    /**
     * 
     * @type {string}
     * @memberof BlockingState
     */
    blockedId?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockingState
     */
    stateName?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockingState
     */
    service?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BlockingState
     */
    isBlockChange?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BlockingState
     */
    isBlockEntitlement?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BlockingState
     */
    isBlockBilling?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BlockingState
     */
    effectiveDate?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockingState
     */
    type?: BlockingStateTypeEnum;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof BlockingState
     */
    auditLogs?: Array<AuditLog>;
}

/**
    * @export
    * @enum {string}
    */
export enum BlockingStateTypeEnum {
    SUBSCRIPTION = 'SUBSCRIPTION',
    SUBSCRIPTIONBUNDLE = 'SUBSCRIPTION_BUNDLE',
    ACCOUNT = 'ACCOUNT'
}

/**
 * 
 * @export
 * @interface BulkSubscriptionsBundle
 */
export interface BulkSubscriptionsBundle {
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof BulkSubscriptionsBundle
     */
    baseEntitlementAndAddOns: Array<Subscription>;
}
/**
 * 
 * @export
 * @interface Bundle
 */
export interface Bundle {
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    accountId: string;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    bundleId?: string;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    externalKey?: string;
    /**
     * 
     * @type {Array<Subscription>}
     * @memberof Bundle
     */
    subscriptions?: Array<Subscription>;
    /**
     * 
     * @type {BundleTimeline}
     * @memberof Bundle
     */
    timeline?: BundleTimeline;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof Bundle
     */
    auditLogs?: Array<AuditLog>;
}
/**
 * 
 * @export
 * @interface BundleTimeline
 */
export interface BundleTimeline {
    /**
     * 
     * @type {string}
     * @memberof BundleTimeline
     */
    accountId?: string;
    /**
     * 
     * @type {string}
     * @memberof BundleTimeline
     */
    bundleId?: string;
    /**
     * 
     * @type {string}
     * @memberof BundleTimeline
     */
    externalKey?: string;
    /**
     * 
     * @type {Array<EventSubscription>}
     * @memberof BundleTimeline
     */
    events?: Array<EventSubscription>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof BundleTimeline
     */
    auditLogs?: Array<AuditLog>;
}
/**
 * 
 * @export
 * @interface Catalog
 */
export interface Catalog {
    /**
     * 
     * @type {string}
     * @memberof Catalog
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Catalog
     */
    effectiveDate?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Catalog
     */
    currencies?: Array<CatalogCurrenciesEnum>;
    /**
     * 
     * @type {Array<Unit>}
     * @memberof Catalog
     */
    units?: Array<Unit>;
    /**
     * 
     * @type {Array<Product>}
     * @memberof Catalog
     */
    products?: Array<Product>;
    /**
     * 
     * @type {Array<PriceList>}
     * @memberof Catalog
     */
    priceLists?: Array<PriceList>;
}

/**
    * @export
    * @enum {string}
    */
export enum CatalogCurrenciesEnum {
    AED = 'AED',
    AFN = 'AFN',
    ALL = 'ALL',
    AMD = 'AMD',
    ANG = 'ANG',
    AOA = 'AOA',
    ARS = 'ARS',
    AUD = 'AUD',
    AWG = 'AWG',
    AZN = 'AZN',
    BAM = 'BAM',
    BBD = 'BBD',
    BDT = 'BDT',
    BGN = 'BGN',
    BHD = 'BHD',
    BIF = 'BIF',
    BMD = 'BMD',
    BND = 'BND',
    BOB = 'BOB',
    BRL = 'BRL',
    BSD = 'BSD',
    BTN = 'BTN',
    BWP = 'BWP',
    BYR = 'BYR',
    BZD = 'BZD',
    CAD = 'CAD',
    CDF = 'CDF',
    CHF = 'CHF',
    CLP = 'CLP',
    CNY = 'CNY',
    COP = 'COP',
    CRC = 'CRC',
    CUC = 'CUC',
    CUP = 'CUP',
    CVE = 'CVE',
    CZK = 'CZK',
    DJF = 'DJF',
    DKK = 'DKK',
    DOP = 'DOP',
    DZD = 'DZD',
    EGP = 'EGP',
    ERN = 'ERN',
    ETB = 'ETB',
    EUR = 'EUR',
    FJD = 'FJD',
    FKP = 'FKP',
    GBP = 'GBP',
    GEL = 'GEL',
    GGP = 'GGP',
    GHS = 'GHS',
    GIP = 'GIP',
    GMD = 'GMD',
    GNF = 'GNF',
    GTQ = 'GTQ',
    GYD = 'GYD',
    HKD = 'HKD',
    HNL = 'HNL',
    HRK = 'HRK',
    HTG = 'HTG',
    HUF = 'HUF',
    IDR = 'IDR',
    ILS = 'ILS',
    IMP = 'IMP',
    INR = 'INR',
    IQD = 'IQD',
    IRR = 'IRR',
    ISK = 'ISK',
    JEP = 'JEP',
    JMD = 'JMD',
    JOD = 'JOD',
    JPY = 'JPY',
    KES = 'KES',
    KGS = 'KGS',
    KHR = 'KHR',
    KMF = 'KMF',
    KPW = 'KPW',
    KRW = 'KRW',
    KWD = 'KWD',
    KYD = 'KYD',
    KZT = 'KZT',
    LAK = 'LAK',
    LBP = 'LBP',
    LKR = 'LKR',
    LRD = 'LRD',
    LSL = 'LSL',
    LTL = 'LTL',
    LVL = 'LVL',
    LYD = 'LYD',
    MAD = 'MAD',
    MDL = 'MDL',
    MGA = 'MGA',
    MKD = 'MKD',
    MMK = 'MMK',
    MNT = 'MNT',
    MOP = 'MOP',
    MRO = 'MRO',
    MUR = 'MUR',
    MVR = 'MVR',
    MWK = 'MWK',
    MXN = 'MXN',
    MYR = 'MYR',
    MZN = 'MZN',
    NAD = 'NAD',
    NGN = 'NGN',
    NIO = 'NIO',
    NOK = 'NOK',
    NPR = 'NPR',
    NZD = 'NZD',
    OMR = 'OMR',
    PAB = 'PAB',
    PEN = 'PEN',
    PGK = 'PGK',
    PHP = 'PHP',
    PKR = 'PKR',
    PLN = 'PLN',
    PYG = 'PYG',
    QAR = 'QAR',
    RON = 'RON',
    RSD = 'RSD',
    RUB = 'RUB',
    RWF = 'RWF',
    SAR = 'SAR',
    SBD = 'SBD',
    SCR = 'SCR',
    SDG = 'SDG',
    SEK = 'SEK',
    SGD = 'SGD',
    SHP = 'SHP',
    SLL = 'SLL',
    SOS = 'SOS',
    SPL = 'SPL',
    SRD = 'SRD',
    STD = 'STD',
    SVC = 'SVC',
    SYP = 'SYP',
    SZL = 'SZL',
    THB = 'THB',
    TJS = 'TJS',
    TMT = 'TMT',
    TND = 'TND',
    TOP = 'TOP',
    TRY = 'TRY',
    TTD = 'TTD',
    TVD = 'TVD',
    TWD = 'TWD',
    TZS = 'TZS',
    UAH = 'UAH',
    UGX = 'UGX',
    USD = 'USD',
    UYU = 'UYU',
    UZS = 'UZS',
    VEF = 'VEF',
    VND = 'VND',
    VUV = 'VUV',
    WST = 'WST',
    XAF = 'XAF',
    XCD = 'XCD',
    XDR = 'XDR',
    XOF = 'XOF',
    XPF = 'XPF',
    YER = 'YER',
    ZAR = 'ZAR',
    ZMW = 'ZMW',
    ZWD = 'ZWD',
    BTC = 'BTC'
}

/**
 * 
 * @export
 * @interface ComboHostedPaymentPage
 */
export interface ComboHostedPaymentPage {
    /**
     * 
     * @type {Account}
     * @memberof ComboHostedPaymentPage
     */
    account?: Account;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof ComboHostedPaymentPage
     */
    paymentMethod?: PaymentMethod;
    /**
     * 
     * @type {HostedPaymentPageFields}
     * @memberof ComboHostedPaymentPage
     */
    hostedPaymentPageFields?: HostedPaymentPageFields;
    /**
     * 
     * @type {Array<PluginProperty>}
     * @memberof ComboHostedPaymentPage
     */
    paymentMethodPluginProperties?: Array<PluginProperty>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof ComboHostedPaymentPage
     */
    auditLogs?: Array<AuditLog>;
}
/**
 * 
 * @export
 * @interface ComboPaymentTransaction
 */
export interface ComboPaymentTransaction {
    /**
     * 
     * @type {Account}
     * @memberof ComboPaymentTransaction
     */
    account?: Account;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof ComboPaymentTransaction
     */
    paymentMethod?: PaymentMethod;
    /**
     * 
     * @type {PaymentTransaction}
     * @memberof ComboPaymentTransaction
     */
    transaction?: PaymentTransaction;
    /**
     * 
     * @type {Array<PluginProperty>}
     * @memberof ComboPaymentTransaction
     */
    paymentMethodPluginProperties?: Array<PluginProperty>;
    /**
     * 
     * @type {Array<PluginProperty>}
     * @memberof ComboPaymentTransaction
     */
    transactionPluginProperties?: Array<PluginProperty>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof ComboPaymentTransaction
     */
    auditLogs?: Array<AuditLog>;
}
/**
 * 
 * @export
 * @interface CustomField
 */
export interface CustomField {
    /**
     * 
     * @type {string}
     * @memberof CustomField
     */
    customFieldId?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomField
     */
    objectId?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomField
     */
    objectType?: CustomFieldObjectTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomField
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CustomField
     */
    value: string;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof CustomField
     */
    auditLogs?: Array<AuditLog>;
}

/**
    * @export
    * @enum {string}
    */
export enum CustomFieldObjectTypeEnum {
    ACCOUNT = 'ACCOUNT',
    ACCOUNTEMAIL = 'ACCOUNT_EMAIL',
    BLOCKINGSTATES = 'BLOCKING_STATES',
    BUNDLE = 'BUNDLE',
    CUSTOMFIELD = 'CUSTOM_FIELD',
    INVOICE = 'INVOICE',
    PAYMENT = 'PAYMENT',
    TRANSACTION = 'TRANSACTION',
    INVOICEITEM = 'INVOICE_ITEM',
    INVOICEPAYMENT = 'INVOICE_PAYMENT',
    SUBSCRIPTION = 'SUBSCRIPTION',
    SUBSCRIPTIONEVENT = 'SUBSCRIPTION_EVENT',
    SERVICEBROADCAST = 'SERVICE_BROADCAST',
    PAYMENTATTEMPT = 'PAYMENT_ATTEMPT',
    PAYMENTMETHOD = 'PAYMENT_METHOD',
    TAG = 'TAG',
    TAGDEFINITION = 'TAG_DEFINITION',
    TENANT = 'TENANT',
    TENANTKVS = 'TENANT_KVS'
}

/**
 * 
 * @export
 * @interface Duration
 */
export interface Duration {
    /**
     * 
     * @type {string}
     * @memberof Duration
     */
    unit?: DurationUnitEnum;
    /**
     * 
     * @type {number}
     * @memberof Duration
     */
    number?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum DurationUnitEnum {
    DAYS = 'DAYS',
    WEEKS = 'WEEKS',
    MONTHS = 'MONTHS',
    YEARS = 'YEARS',
    UNLIMITED = 'UNLIMITED'
}

/**
 * 
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    updatedDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    createdDate?: string;
}
/**
 * 
 * @export
 * @interface EventSubscription
 */
export interface EventSubscription {
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    eventId?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    billingPeriod?: EventSubscriptionBillingPeriodEnum;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    effectiveDate?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    plan?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    product?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    priceList?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    eventType?: EventSubscriptionEventTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof EventSubscription
     */
    isBlockedBilling?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EventSubscription
     */
    isBlockedEntitlement?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    serviceName?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    serviceStateName?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSubscription
     */
    phase?: string;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof EventSubscription
     */
    auditLogs?: Array<AuditLog>;
}

/**
    * @export
    * @enum {string}
    */
export enum EventSubscriptionBillingPeriodEnum {
    DAILY = 'DAILY',
    WEEKLY = 'WEEKLY',
    BIWEEKLY = 'BIWEEKLY',
    THIRTYDAYS = 'THIRTY_DAYS',
    SIXTYDAYS = 'SIXTY_DAYS',
    NINETYDAYS = 'NINETY_DAYS',
    MONTHLY = 'MONTHLY',
    BIMESTRIAL = 'BIMESTRIAL',
    QUARTERLY = 'QUARTERLY',
    TRIANNUAL = 'TRIANNUAL',
    BIANNUAL = 'BIANNUAL',
    ANNUAL = 'ANNUAL',
    BIENNIAL = 'BIENNIAL',
    NOBILLINGPERIOD = 'NO_BILLING_PERIOD'
}
/**
    * @export
    * @enum {string}
    */
export enum EventSubscriptionEventTypeEnum {
    STARTENTITLEMENT = 'START_ENTITLEMENT',
    STARTBILLING = 'START_BILLING',
    PAUSEENTITLEMENT = 'PAUSE_ENTITLEMENT',
    PAUSEBILLING = 'PAUSE_BILLING',
    RESUMEENTITLEMENT = 'RESUME_ENTITLEMENT',
    RESUMEBILLING = 'RESUME_BILLING',
    PHASE = 'PHASE',
    CHANGE = 'CHANGE',
    STOPENTITLEMENT = 'STOP_ENTITLEMENT',
    STOPBILLING = 'STOP_BILLING',
    SERVICESTATECHANGE = 'SERVICE_STATE_CHANGE'
}

/**
 * 
 * @export
 * @interface HostedPaymentPageFields
 */
export interface HostedPaymentPageFields {
    /**
     * 
     * @type {Array<PluginProperty>}
     * @memberof HostedPaymentPageFields
     */
    formFields?: Array<PluginProperty>;
}
/**
 * 
 * @export
 * @interface HostedPaymentPageFormDescriptor
 */
export interface HostedPaymentPageFormDescriptor {
    /**
     * 
     * @type {string}
     * @memberof HostedPaymentPageFormDescriptor
     */
    kbAccountId?: string;
    /**
     * 
     * @type {string}
     * @memberof HostedPaymentPageFormDescriptor
     */
    formMethod?: string;
    /**
     * 
     * @type {string}
     * @memberof HostedPaymentPageFormDescriptor
     */
    formUrl?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof HostedPaymentPageFormDescriptor
     */
    formFields?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof HostedPaymentPageFormDescriptor
     */
    properties?: { [key: string]: object; };
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof HostedPaymentPageFormDescriptor
     */
    auditLogs?: Array<AuditLog>;
}
/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    currency?: InvoiceCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    status?: InvoiceStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    creditAdj?: number;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    refundAdj?: number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    invoiceId?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    invoiceDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    targetDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    invoiceNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof Invoice
     */
    balance?: number;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    accountId?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    bundleKeys?: string;
    /**
     * 
     * @type {Array<InvoiceItem>}
     * @memberof Invoice
     */
    credits?: Array<InvoiceItem>;
    /**
     * 
     * @type {Array<InvoiceItem>}
     * @memberof Invoice
     */
    items?: Array<InvoiceItem>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Invoice
     */
    trackingIds?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Invoice
     */
    isParentInvoice?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    parentInvoiceId?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    parentAccountId?: string;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof Invoice
     */
    auditLogs?: Array<AuditLog>;
}

/**
    * @export
    * @enum {string}
    */
export enum InvoiceCurrencyEnum {
    AED = 'AED',
    AFN = 'AFN',
    ALL = 'ALL',
    AMD = 'AMD',
    ANG = 'ANG',
    AOA = 'AOA',
    ARS = 'ARS',
    AUD = 'AUD',
    AWG = 'AWG',
    AZN = 'AZN',
    BAM = 'BAM',
    BBD = 'BBD',
    BDT = 'BDT',
    BGN = 'BGN',
    BHD = 'BHD',
    BIF = 'BIF',
    BMD = 'BMD',
    BND = 'BND',
    BOB = 'BOB',
    BRL = 'BRL',
    BSD = 'BSD',
    BTN = 'BTN',
    BWP = 'BWP',
    BYR = 'BYR',
    BZD = 'BZD',
    CAD = 'CAD',
    CDF = 'CDF',
    CHF = 'CHF',
    CLP = 'CLP',
    CNY = 'CNY',
    COP = 'COP',
    CRC = 'CRC',
    CUC = 'CUC',
    CUP = 'CUP',
    CVE = 'CVE',
    CZK = 'CZK',
    DJF = 'DJF',
    DKK = 'DKK',
    DOP = 'DOP',
    DZD = 'DZD',
    EGP = 'EGP',
    ERN = 'ERN',
    ETB = 'ETB',
    EUR = 'EUR',
    FJD = 'FJD',
    FKP = 'FKP',
    GBP = 'GBP',
    GEL = 'GEL',
    GGP = 'GGP',
    GHS = 'GHS',
    GIP = 'GIP',
    GMD = 'GMD',
    GNF = 'GNF',
    GTQ = 'GTQ',
    GYD = 'GYD',
    HKD = 'HKD',
    HNL = 'HNL',
    HRK = 'HRK',
    HTG = 'HTG',
    HUF = 'HUF',
    IDR = 'IDR',
    ILS = 'ILS',
    IMP = 'IMP',
    INR = 'INR',
    IQD = 'IQD',
    IRR = 'IRR',
    ISK = 'ISK',
    JEP = 'JEP',
    JMD = 'JMD',
    JOD = 'JOD',
    JPY = 'JPY',
    KES = 'KES',
    KGS = 'KGS',
    KHR = 'KHR',
    KMF = 'KMF',
    KPW = 'KPW',
    KRW = 'KRW',
    KWD = 'KWD',
    KYD = 'KYD',
    KZT = 'KZT',
    LAK = 'LAK',
    LBP = 'LBP',
    LKR = 'LKR',
    LRD = 'LRD',
    LSL = 'LSL',
    LTL = 'LTL',
    LVL = 'LVL',
    LYD = 'LYD',
    MAD = 'MAD',
    MDL = 'MDL',
    MGA = 'MGA',
    MKD = 'MKD',
    MMK = 'MMK',
    MNT = 'MNT',
    MOP = 'MOP',
    MRO = 'MRO',
    MUR = 'MUR',
    MVR = 'MVR',
    MWK = 'MWK',
    MXN = 'MXN',
    MYR = 'MYR',
    MZN = 'MZN',
    NAD = 'NAD',
    NGN = 'NGN',
    NIO = 'NIO',
    NOK = 'NOK',
    NPR = 'NPR',
    NZD = 'NZD',
    OMR = 'OMR',
    PAB = 'PAB',
    PEN = 'PEN',
    PGK = 'PGK',
    PHP = 'PHP',
    PKR = 'PKR',
    PLN = 'PLN',
    PYG = 'PYG',
    QAR = 'QAR',
    RON = 'RON',
    RSD = 'RSD',
    RUB = 'RUB',
    RWF = 'RWF',
    SAR = 'SAR',
    SBD = 'SBD',
    SCR = 'SCR',
    SDG = 'SDG',
    SEK = 'SEK',
    SGD = 'SGD',
    SHP = 'SHP',
    SLL = 'SLL',
    SOS = 'SOS',
    SPL = 'SPL',
    SRD = 'SRD',
    STD = 'STD',
    SVC = 'SVC',
    SYP = 'SYP',
    SZL = 'SZL',
    THB = 'THB',
    TJS = 'TJS',
    TMT = 'TMT',
    TND = 'TND',
    TOP = 'TOP',
    TRY = 'TRY',
    TTD = 'TTD',
    TVD = 'TVD',
    TWD = 'TWD',
    TZS = 'TZS',
    UAH = 'UAH',
    UGX = 'UGX',
    USD = 'USD',
    UYU = 'UYU',
    UZS = 'UZS',
    VEF = 'VEF',
    VND = 'VND',
    VUV = 'VUV',
    WST = 'WST',
    XAF = 'XAF',
    XCD = 'XCD',
    XDR = 'XDR',
    XOF = 'XOF',
    XPF = 'XPF',
    YER = 'YER',
    ZAR = 'ZAR',
    ZMW = 'ZMW',
    ZWD = 'ZWD',
    BTC = 'BTC'
}
/**
    * @export
    * @enum {string}
    */
export enum InvoiceStatusEnum {
    DRAFT = 'DRAFT',
    COMMITTED = 'COMMITTED',
    VOID = 'VOID'
}

/**
 * 
 * @export
 * @interface InvoiceDryRun
 */
export interface InvoiceDryRun {
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    dryRunType?: InvoiceDryRunDryRunTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    dryRunAction?: InvoiceDryRunDryRunActionEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    phaseType?: InvoiceDryRunPhaseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    productName?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    productCategory?: InvoiceDryRunProductCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    billingPeriod?: InvoiceDryRunBillingPeriodEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    priceListName?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    subscriptionId?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    bundleId?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    effectiveDate?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDryRun
     */
    billingPolicy?: InvoiceDryRunBillingPolicyEnum;
    /**
     * 
     * @type {Array<PhasePrice>}
     * @memberof InvoiceDryRun
     */
    priceOverrides?: Array<PhasePrice>;
}

/**
    * @export
    * @enum {string}
    */
export enum InvoiceDryRunDryRunTypeEnum {
    TARGETDATE = 'TARGET_DATE',
    UPCOMINGINVOICE = 'UPCOMING_INVOICE',
    SUBSCRIPTIONACTION = 'SUBSCRIPTION_ACTION'
}
/**
    * @export
    * @enum {string}
    */
export enum InvoiceDryRunDryRunActionEnum {
    STARTENTITLEMENT = 'START_ENTITLEMENT',
    STARTBILLING = 'START_BILLING',
    PAUSEENTITLEMENT = 'PAUSE_ENTITLEMENT',
    PAUSEBILLING = 'PAUSE_BILLING',
    RESUMEENTITLEMENT = 'RESUME_ENTITLEMENT',
    RESUMEBILLING = 'RESUME_BILLING',
    PHASE = 'PHASE',
    CHANGE = 'CHANGE',
    STOPENTITLEMENT = 'STOP_ENTITLEMENT',
    STOPBILLING = 'STOP_BILLING',
    SERVICESTATECHANGE = 'SERVICE_STATE_CHANGE'
}
/**
    * @export
    * @enum {string}
    */
export enum InvoiceDryRunPhaseTypeEnum {
    TRIAL = 'TRIAL',
    DISCOUNT = 'DISCOUNT',
    FIXEDTERM = 'FIXEDTERM',
    EVERGREEN = 'EVERGREEN'
}
/**
    * @export
    * @enum {string}
    */
export enum InvoiceDryRunProductCategoryEnum {
    BASE = 'BASE',
    ADDON = 'ADD_ON',
    STANDALONE = 'STANDALONE'
}
/**
    * @export
    * @enum {string}
    */
export enum InvoiceDryRunBillingPeriodEnum {
    DAILY = 'DAILY',
    WEEKLY = 'WEEKLY',
    BIWEEKLY = 'BIWEEKLY',
    THIRTYDAYS = 'THIRTY_DAYS',
    SIXTYDAYS = 'SIXTY_DAYS',
    NINETYDAYS = 'NINETY_DAYS',
    MONTHLY = 'MONTHLY',
    BIMESTRIAL = 'BIMESTRIAL',
    QUARTERLY = 'QUARTERLY',
    TRIANNUAL = 'TRIANNUAL',
    BIANNUAL = 'BIANNUAL',
    ANNUAL = 'ANNUAL',
    BIENNIAL = 'BIENNIAL',
    NOBILLINGPERIOD = 'NO_BILLING_PERIOD'
}
/**
    * @export
    * @enum {string}
    */
export enum InvoiceDryRunBillingPolicyEnum {
    STARTOFTERM = 'START_OF_TERM',
    ENDOFTERM = 'END_OF_TERM',
    IMMEDIATE = 'IMMEDIATE',
    ILLEGAL = 'ILLEGAL'
}

/**
 * 
 * @export
 * @interface InvoiceItem
 */
export interface InvoiceItem {
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    invoiceItemId: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    invoiceId?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    linkedInvoiceItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    accountId: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    childAccountId?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    bundleId?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    subscriptionId?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    productName?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    planName?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    phaseName?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    usageName?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    prettyProductName?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    prettyPlanName?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    prettyPhaseName?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    prettyUsageName?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    itemType?: InvoiceItemItemTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    endDate?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceItem
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceItem
     */
    rate?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    currency?: InvoiceItemCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof InvoiceItem
     */
    quantity?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    itemDetails?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItem
     */
    catalogEffectiveDate?: string;
    /**
     * 
     * @type {Array<InvoiceItem>}
     * @memberof InvoiceItem
     */
    childItems?: Array<InvoiceItem>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof InvoiceItem
     */
    auditLogs?: Array<AuditLog>;
}

/**
    * @export
    * @enum {string}
    */
export enum InvoiceItemItemTypeEnum {
    EXTERNALCHARGE = 'EXTERNAL_CHARGE',
    FIXED = 'FIXED',
    RECURRING = 'RECURRING',
    REPAIRADJ = 'REPAIR_ADJ',
    CBAADJ = 'CBA_ADJ',
    CREDITADJ = 'CREDIT_ADJ',
    ITEMADJ = 'ITEM_ADJ',
    USAGE = 'USAGE',
    TAX = 'TAX',
    PARENTSUMMARY = 'PARENT_SUMMARY'
}
/**
    * @export
    * @enum {string}
    */
export enum InvoiceItemCurrencyEnum {
    AED = 'AED',
    AFN = 'AFN',
    ALL = 'ALL',
    AMD = 'AMD',
    ANG = 'ANG',
    AOA = 'AOA',
    ARS = 'ARS',
    AUD = 'AUD',
    AWG = 'AWG',
    AZN = 'AZN',
    BAM = 'BAM',
    BBD = 'BBD',
    BDT = 'BDT',
    BGN = 'BGN',
    BHD = 'BHD',
    BIF = 'BIF',
    BMD = 'BMD',
    BND = 'BND',
    BOB = 'BOB',
    BRL = 'BRL',
    BSD = 'BSD',
    BTN = 'BTN',
    BWP = 'BWP',
    BYR = 'BYR',
    BZD = 'BZD',
    CAD = 'CAD',
    CDF = 'CDF',
    CHF = 'CHF',
    CLP = 'CLP',
    CNY = 'CNY',
    COP = 'COP',
    CRC = 'CRC',
    CUC = 'CUC',
    CUP = 'CUP',
    CVE = 'CVE',
    CZK = 'CZK',
    DJF = 'DJF',
    DKK = 'DKK',
    DOP = 'DOP',
    DZD = 'DZD',
    EGP = 'EGP',
    ERN = 'ERN',
    ETB = 'ETB',
    EUR = 'EUR',
    FJD = 'FJD',
    FKP = 'FKP',
    GBP = 'GBP',
    GEL = 'GEL',
    GGP = 'GGP',
    GHS = 'GHS',
    GIP = 'GIP',
    GMD = 'GMD',
    GNF = 'GNF',
    GTQ = 'GTQ',
    GYD = 'GYD',
    HKD = 'HKD',
    HNL = 'HNL',
    HRK = 'HRK',
    HTG = 'HTG',
    HUF = 'HUF',
    IDR = 'IDR',
    ILS = 'ILS',
    IMP = 'IMP',
    INR = 'INR',
    IQD = 'IQD',
    IRR = 'IRR',
    ISK = 'ISK',
    JEP = 'JEP',
    JMD = 'JMD',
    JOD = 'JOD',
    JPY = 'JPY',
    KES = 'KES',
    KGS = 'KGS',
    KHR = 'KHR',
    KMF = 'KMF',
    KPW = 'KPW',
    KRW = 'KRW',
    KWD = 'KWD',
    KYD = 'KYD',
    KZT = 'KZT',
    LAK = 'LAK',
    LBP = 'LBP',
    LKR = 'LKR',
    LRD = 'LRD',
    LSL = 'LSL',
    LTL = 'LTL',
    LVL = 'LVL',
    LYD = 'LYD',
    MAD = 'MAD',
    MDL = 'MDL',
    MGA = 'MGA',
    MKD = 'MKD',
    MMK = 'MMK',
    MNT = 'MNT',
    MOP = 'MOP',
    MRO = 'MRO',
    MUR = 'MUR',
    MVR = 'MVR',
    MWK = 'MWK',
    MXN = 'MXN',
    MYR = 'MYR',
    MZN = 'MZN',
    NAD = 'NAD',
    NGN = 'NGN',
    NIO = 'NIO',
    NOK = 'NOK',
    NPR = 'NPR',
    NZD = 'NZD',
    OMR = 'OMR',
    PAB = 'PAB',
    PEN = 'PEN',
    PGK = 'PGK',
    PHP = 'PHP',
    PKR = 'PKR',
    PLN = 'PLN',
    PYG = 'PYG',
    QAR = 'QAR',
    RON = 'RON',
    RSD = 'RSD',
    RUB = 'RUB',
    RWF = 'RWF',
    SAR = 'SAR',
    SBD = 'SBD',
    SCR = 'SCR',
    SDG = 'SDG',
    SEK = 'SEK',
    SGD = 'SGD',
    SHP = 'SHP',
    SLL = 'SLL',
    SOS = 'SOS',
    SPL = 'SPL',
    SRD = 'SRD',
    STD = 'STD',
    SVC = 'SVC',
    SYP = 'SYP',
    SZL = 'SZL',
    THB = 'THB',
    TJS = 'TJS',
    TMT = 'TMT',
    TND = 'TND',
    TOP = 'TOP',
    TRY = 'TRY',
    TTD = 'TTD',
    TVD = 'TVD',
    TWD = 'TWD',
    TZS = 'TZS',
    UAH = 'UAH',
    UGX = 'UGX',
    USD = 'USD',
    UYU = 'UYU',
    UZS = 'UZS',
    VEF = 'VEF',
    VND = 'VND',
    VUV = 'VUV',
    WST = 'WST',
    XAF = 'XAF',
    XCD = 'XCD',
    XDR = 'XDR',
    XOF = 'XOF',
    XPF = 'XPF',
    YER = 'YER',
    ZAR = 'ZAR',
    ZMW = 'ZMW',
    ZWD = 'ZWD',
    BTC = 'BTC'
}

/**
 * 
 * @export
 * @interface InvoicePayment
 */
export interface InvoicePayment {
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    targetInvoiceId?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    accountId?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    paymentId?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    paymentNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    paymentExternalKey?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoicePayment
     */
    authAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoicePayment
     */
    capturedAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoicePayment
     */
    purchasedAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoicePayment
     */
    refundedAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoicePayment
     */
    creditedAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    currency?: InvoicePaymentCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoicePayment
     */
    paymentMethodId?: string;
    /**
     * 
     * @type {Array<PaymentTransaction>}
     * @memberof InvoicePayment
     */
    transactions?: Array<PaymentTransaction>;
    /**
     * 
     * @type {Array<PaymentAttempt>}
     * @memberof InvoicePayment
     */
    paymentAttempts?: Array<PaymentAttempt>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof InvoicePayment
     */
    auditLogs?: Array<AuditLog>;
}

/**
    * @export
    * @enum {string}
    */
export enum InvoicePaymentCurrencyEnum {
    AED = 'AED',
    AFN = 'AFN',
    ALL = 'ALL',
    AMD = 'AMD',
    ANG = 'ANG',
    AOA = 'AOA',
    ARS = 'ARS',
    AUD = 'AUD',
    AWG = 'AWG',
    AZN = 'AZN',
    BAM = 'BAM',
    BBD = 'BBD',
    BDT = 'BDT',
    BGN = 'BGN',
    BHD = 'BHD',
    BIF = 'BIF',
    BMD = 'BMD',
    BND = 'BND',
    BOB = 'BOB',
    BRL = 'BRL',
    BSD = 'BSD',
    BTN = 'BTN',
    BWP = 'BWP',
    BYR = 'BYR',
    BZD = 'BZD',
    CAD = 'CAD',
    CDF = 'CDF',
    CHF = 'CHF',
    CLP = 'CLP',
    CNY = 'CNY',
    COP = 'COP',
    CRC = 'CRC',
    CUC = 'CUC',
    CUP = 'CUP',
    CVE = 'CVE',
    CZK = 'CZK',
    DJF = 'DJF',
    DKK = 'DKK',
    DOP = 'DOP',
    DZD = 'DZD',
    EGP = 'EGP',
    ERN = 'ERN',
    ETB = 'ETB',
    EUR = 'EUR',
    FJD = 'FJD',
    FKP = 'FKP',
    GBP = 'GBP',
    GEL = 'GEL',
    GGP = 'GGP',
    GHS = 'GHS',
    GIP = 'GIP',
    GMD = 'GMD',
    GNF = 'GNF',
    GTQ = 'GTQ',
    GYD = 'GYD',
    HKD = 'HKD',
    HNL = 'HNL',
    HRK = 'HRK',
    HTG = 'HTG',
    HUF = 'HUF',
    IDR = 'IDR',
    ILS = 'ILS',
    IMP = 'IMP',
    INR = 'INR',
    IQD = 'IQD',
    IRR = 'IRR',
    ISK = 'ISK',
    JEP = 'JEP',
    JMD = 'JMD',
    JOD = 'JOD',
    JPY = 'JPY',
    KES = 'KES',
    KGS = 'KGS',
    KHR = 'KHR',
    KMF = 'KMF',
    KPW = 'KPW',
    KRW = 'KRW',
    KWD = 'KWD',
    KYD = 'KYD',
    KZT = 'KZT',
    LAK = 'LAK',
    LBP = 'LBP',
    LKR = 'LKR',
    LRD = 'LRD',
    LSL = 'LSL',
    LTL = 'LTL',
    LVL = 'LVL',
    LYD = 'LYD',
    MAD = 'MAD',
    MDL = 'MDL',
    MGA = 'MGA',
    MKD = 'MKD',
    MMK = 'MMK',
    MNT = 'MNT',
    MOP = 'MOP',
    MRO = 'MRO',
    MUR = 'MUR',
    MVR = 'MVR',
    MWK = 'MWK',
    MXN = 'MXN',
    MYR = 'MYR',
    MZN = 'MZN',
    NAD = 'NAD',
    NGN = 'NGN',
    NIO = 'NIO',
    NOK = 'NOK',
    NPR = 'NPR',
    NZD = 'NZD',
    OMR = 'OMR',
    PAB = 'PAB',
    PEN = 'PEN',
    PGK = 'PGK',
    PHP = 'PHP',
    PKR = 'PKR',
    PLN = 'PLN',
    PYG = 'PYG',
    QAR = 'QAR',
    RON = 'RON',
    RSD = 'RSD',
    RUB = 'RUB',
    RWF = 'RWF',
    SAR = 'SAR',
    SBD = 'SBD',
    SCR = 'SCR',
    SDG = 'SDG',
    SEK = 'SEK',
    SGD = 'SGD',
    SHP = 'SHP',
    SLL = 'SLL',
    SOS = 'SOS',
    SPL = 'SPL',
    SRD = 'SRD',
    STD = 'STD',
    SVC = 'SVC',
    SYP = 'SYP',
    SZL = 'SZL',
    THB = 'THB',
    TJS = 'TJS',
    TMT = 'TMT',
    TND = 'TND',
    TOP = 'TOP',
    TRY = 'TRY',
    TTD = 'TTD',
    TVD = 'TVD',
    TWD = 'TWD',
    TZS = 'TZS',
    UAH = 'UAH',
    UGX = 'UGX',
    USD = 'USD',
    UYU = 'UYU',
    UZS = 'UZS',
    VEF = 'VEF',
    VND = 'VND',
    VUV = 'VUV',
    WST = 'WST',
    XAF = 'XAF',
    XCD = 'XCD',
    XDR = 'XDR',
    XOF = 'XOF',
    XPF = 'XPF',
    YER = 'YER',
    ZAR = 'ZAR',
    ZMW = 'ZMW',
    ZWD = 'ZWD',
    BTC = 'BTC'
}

/**
 * 
 * @export
 * @interface InvoicePaymentTransaction
 */
export interface InvoicePaymentTransaction {
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    transactionExternalKey?: string;
    /**
     * Associated payment id, required when notifying state transitions
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    paymentId?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    paymentExternalKey?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    transactionType?: InvoicePaymentTransactionTransactionTypeEnum;
    /**
     * Transaction amount, required except for void operations
     * @type {number}
     * @memberof InvoicePaymentTransaction
     */
    amount?: number;
    /**
     * Amount currency (account currency unless specified)
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    currency?: InvoicePaymentTransactionCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    effectiveDate?: string;
    /**
     * 
     * @type {number}
     * @memberof InvoicePaymentTransaction
     */
    processedAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    processedCurrency?: InvoicePaymentTransactionProcessedCurrencyEnum;
    /**
     * Transaction status, required for state change notifications
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    status?: InvoicePaymentTransactionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    gatewayErrorCode?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    gatewayErrorMsg?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    firstPaymentReferenceId?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoicePaymentTransaction
     */
    secondPaymentReferenceId?: string;
    /**
     * 
     * @type {Array<PluginProperty>}
     * @memberof InvoicePaymentTransaction
     */
    properties?: Array<PluginProperty>;
    /**
     * 
     * @type {boolean}
     * @memberof InvoicePaymentTransaction
     */
    isAdjusted?: boolean;
    /**
     * 
     * @type {Array<InvoiceItem>}
     * @memberof InvoicePaymentTransaction
     */
    adjustments?: Array<InvoiceItem>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof InvoicePaymentTransaction
     */
    auditLogs?: Array<AuditLog>;
}

/**
    * @export
    * @enum {string}
    */
export enum InvoicePaymentTransactionTransactionTypeEnum {
    AUTHORIZE = 'AUTHORIZE',
    CAPTURE = 'CAPTURE',
    CHARGEBACK = 'CHARGEBACK',
    CREDIT = 'CREDIT',
    PURCHASE = 'PURCHASE',
    REFUND = 'REFUND',
    VOID = 'VOID'
}
/**
    * @export
    * @enum {string}
    */
export enum InvoicePaymentTransactionCurrencyEnum {
    AED = 'AED',
    AFN = 'AFN',
    ALL = 'ALL',
    AMD = 'AMD',
    ANG = 'ANG',
    AOA = 'AOA',
    ARS = 'ARS',
    AUD = 'AUD',
    AWG = 'AWG',
    AZN = 'AZN',
    BAM = 'BAM',
    BBD = 'BBD',
    BDT = 'BDT',
    BGN = 'BGN',
    BHD = 'BHD',
    BIF = 'BIF',
    BMD = 'BMD',
    BND = 'BND',
    BOB = 'BOB',
    BRL = 'BRL',
    BSD = 'BSD',
    BTN = 'BTN',
    BWP = 'BWP',
    BYR = 'BYR',
    BZD = 'BZD',
    CAD = 'CAD',
    CDF = 'CDF',
    CHF = 'CHF',
    CLP = 'CLP',
    CNY = 'CNY',
    COP = 'COP',
    CRC = 'CRC',
    CUC = 'CUC',
    CUP = 'CUP',
    CVE = 'CVE',
    CZK = 'CZK',
    DJF = 'DJF',
    DKK = 'DKK',
    DOP = 'DOP',
    DZD = 'DZD',
    EGP = 'EGP',
    ERN = 'ERN',
    ETB = 'ETB',
    EUR = 'EUR',
    FJD = 'FJD',
    FKP = 'FKP',
    GBP = 'GBP',
    GEL = 'GEL',
    GGP = 'GGP',
    GHS = 'GHS',
    GIP = 'GIP',
    GMD = 'GMD',
    GNF = 'GNF',
    GTQ = 'GTQ',
    GYD = 'GYD',
    HKD = 'HKD',
    HNL = 'HNL',
    HRK = 'HRK',
    HTG = 'HTG',
    HUF = 'HUF',
    IDR = 'IDR',
    ILS = 'ILS',
    IMP = 'IMP',
    INR = 'INR',
    IQD = 'IQD',
    IRR = 'IRR',
    ISK = 'ISK',
    JEP = 'JEP',
    JMD = 'JMD',
    JOD = 'JOD',
    JPY = 'JPY',
    KES = 'KES',
    KGS = 'KGS',
    KHR = 'KHR',
    KMF = 'KMF',
    KPW = 'KPW',
    KRW = 'KRW',
    KWD = 'KWD',
    KYD = 'KYD',
    KZT = 'KZT',
    LAK = 'LAK',
    LBP = 'LBP',
    LKR = 'LKR',
    LRD = 'LRD',
    LSL = 'LSL',
    LTL = 'LTL',
    LVL = 'LVL',
    LYD = 'LYD',
    MAD = 'MAD',
    MDL = 'MDL',
    MGA = 'MGA',
    MKD = 'MKD',
    MMK = 'MMK',
    MNT = 'MNT',
    MOP = 'MOP',
    MRO = 'MRO',
    MUR = 'MUR',
    MVR = 'MVR',
    MWK = 'MWK',
    MXN = 'MXN',
    MYR = 'MYR',
    MZN = 'MZN',
    NAD = 'NAD',
    NGN = 'NGN',
    NIO = 'NIO',
    NOK = 'NOK',
    NPR = 'NPR',
    NZD = 'NZD',
    OMR = 'OMR',
    PAB = 'PAB',
    PEN = 'PEN',
    PGK = 'PGK',
    PHP = 'PHP',
    PKR = 'PKR',
    PLN = 'PLN',
    PYG = 'PYG',
    QAR = 'QAR',
    RON = 'RON',
    RSD = 'RSD',
    RUB = 'RUB',
    RWF = 'RWF',
    SAR = 'SAR',
    SBD = 'SBD',
    SCR = 'SCR',
    SDG = 'SDG',
    SEK = 'SEK',
    SGD = 'SGD',
    SHP = 'SHP',
    SLL = 'SLL',
    SOS = 'SOS',
    SPL = 'SPL',
    SRD = 'SRD',
    STD = 'STD',
    SVC = 'SVC',
    SYP = 'SYP',
    SZL = 'SZL',
    THB = 'THB',
    TJS = 'TJS',
    TMT = 'TMT',
    TND = 'TND',
    TOP = 'TOP',
    TRY = 'TRY',
    TTD = 'TTD',
    TVD = 'TVD',
    TWD = 'TWD',
    TZS = 'TZS',
    UAH = 'UAH',
    UGX = 'UGX',
    USD = 'USD',
    UYU = 'UYU',
    UZS = 'UZS',
    VEF = 'VEF',
    VND = 'VND',
    VUV = 'VUV',
    WST = 'WST',
    XAF = 'XAF',
    XCD = 'XCD',
    XDR = 'XDR',
    XOF = 'XOF',
    XPF = 'XPF',
    YER = 'YER',
    ZAR = 'ZAR',
    ZMW = 'ZMW',
    ZWD = 'ZWD',
    BTC = 'BTC'
}
/**
    * @export
    * @enum {string}
    */
export enum InvoicePaymentTransactionProcessedCurrencyEnum {
    AED = 'AED',
    AFN = 'AFN',
    ALL = 'ALL',
    AMD = 'AMD',
    ANG = 'ANG',
    AOA = 'AOA',
    ARS = 'ARS',
    AUD = 'AUD',
    AWG = 'AWG',
    AZN = 'AZN',
    BAM = 'BAM',
    BBD = 'BBD',
    BDT = 'BDT',
    BGN = 'BGN',
    BHD = 'BHD',
    BIF = 'BIF',
    BMD = 'BMD',
    BND = 'BND',
    BOB = 'BOB',
    BRL = 'BRL',
    BSD = 'BSD',
    BTN = 'BTN',
    BWP = 'BWP',
    BYR = 'BYR',
    BZD = 'BZD',
    CAD = 'CAD',
    CDF = 'CDF',
    CHF = 'CHF',
    CLP = 'CLP',
    CNY = 'CNY',
    COP = 'COP',
    CRC = 'CRC',
    CUC = 'CUC',
    CUP = 'CUP',
    CVE = 'CVE',
    CZK = 'CZK',
    DJF = 'DJF',
    DKK = 'DKK',
    DOP = 'DOP',
    DZD = 'DZD',
    EGP = 'EGP',
    ERN = 'ERN',
    ETB = 'ETB',
    EUR = 'EUR',
    FJD = 'FJD',
    FKP = 'FKP',
    GBP = 'GBP',
    GEL = 'GEL',
    GGP = 'GGP',
    GHS = 'GHS',
    GIP = 'GIP',
    GMD = 'GMD',
    GNF = 'GNF',
    GTQ = 'GTQ',
    GYD = 'GYD',
    HKD = 'HKD',
    HNL = 'HNL',
    HRK = 'HRK',
    HTG = 'HTG',
    HUF = 'HUF',
    IDR = 'IDR',
    ILS = 'ILS',
    IMP = 'IMP',
    INR = 'INR',
    IQD = 'IQD',
    IRR = 'IRR',
    ISK = 'ISK',
    JEP = 'JEP',
    JMD = 'JMD',
    JOD = 'JOD',
    JPY = 'JPY',
    KES = 'KES',
    KGS = 'KGS',
    KHR = 'KHR',
    KMF = 'KMF',
    KPW = 'KPW',
    KRW = 'KRW',
    KWD = 'KWD',
    KYD = 'KYD',
    KZT = 'KZT',
    LAK = 'LAK',
    LBP = 'LBP',
    LKR = 'LKR',
    LRD = 'LRD',
    LSL = 'LSL',
    LTL = 'LTL',
    LVL = 'LVL',
    LYD = 'LYD',
    MAD = 'MAD',
    MDL = 'MDL',
    MGA = 'MGA',
    MKD = 'MKD',
    MMK = 'MMK',
    MNT = 'MNT',
    MOP = 'MOP',
    MRO = 'MRO',
    MUR = 'MUR',
    MVR = 'MVR',
    MWK = 'MWK',
    MXN = 'MXN',
    MYR = 'MYR',
    MZN = 'MZN',
    NAD = 'NAD',
    NGN = 'NGN',
    NIO = 'NIO',
    NOK = 'NOK',
    NPR = 'NPR',
    NZD = 'NZD',
    OMR = 'OMR',
    PAB = 'PAB',
    PEN = 'PEN',
    PGK = 'PGK',
    PHP = 'PHP',
    PKR = 'PKR',
    PLN = 'PLN',
    PYG = 'PYG',
    QAR = 'QAR',
    RON = 'RON',
    RSD = 'RSD',
    RUB = 'RUB',
    RWF = 'RWF',
    SAR = 'SAR',
    SBD = 'SBD',
    SCR = 'SCR',
    SDG = 'SDG',
    SEK = 'SEK',
    SGD = 'SGD',
    SHP = 'SHP',
    SLL = 'SLL',
    SOS = 'SOS',
    SPL = 'SPL',
    SRD = 'SRD',
    STD = 'STD',
    SVC = 'SVC',
    SYP = 'SYP',
    SZL = 'SZL',
    THB = 'THB',
    TJS = 'TJS',
    TMT = 'TMT',
    TND = 'TND',
    TOP = 'TOP',
    TRY = 'TRY',
    TTD = 'TTD',
    TVD = 'TVD',
    TWD = 'TWD',
    TZS = 'TZS',
    UAH = 'UAH',
    UGX = 'UGX',
    USD = 'USD',
    UYU = 'UYU',
    UZS = 'UZS',
    VEF = 'VEF',
    VND = 'VND',
    VUV = 'VUV',
    WST = 'WST',
    XAF = 'XAF',
    XCD = 'XCD',
    XDR = 'XDR',
    XOF = 'XOF',
    XPF = 'XPF',
    YER = 'YER',
    ZAR = 'ZAR',
    ZMW = 'ZMW',
    ZWD = 'ZWD',
    BTC = 'BTC'
}
/**
    * @export
    * @enum {string}
    */
export enum InvoicePaymentTransactionStatusEnum {
    SUCCESS = 'SUCCESS',
    UNKNOWN = 'UNKNOWN',
    PENDING = 'PENDING',
    PAYMENTFAILURE = 'PAYMENT_FAILURE',
    PLUGINFAILURE = 'PLUGIN_FAILURE',
    PAYMENTSYSTEMOFF = 'PAYMENT_SYSTEM_OFF'
}

/**
 * 
 * @export
 * @interface Limit
 */
export interface Limit {
    /**
     * 
     * @type {string}
     * @memberof Limit
     */
    unit?: string;
    /**
     * 
     * @type {string}
     * @memberof Limit
     */
    max?: string;
    /**
     * 
     * @type {string}
     * @memberof Limit
     */
    min?: string;
}
/**
 * 
 * @export
 * @interface NodeCommand
 */
export interface NodeCommand {
    /**
     * 
     * @type {boolean}
     * @memberof NodeCommand
     */
    isSystemCommandType?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NodeCommand
     */
    nodeCommandType?: string;
    /**
     * 
     * @type {Array<NodeCommandProperty>}
     * @memberof NodeCommand
     */
    nodeCommandProperties?: Array<NodeCommandProperty>;
}
/**
 * 
 * @export
 * @interface NodeCommandProperty
 */
export interface NodeCommandProperty {
    /**
     * 
     * @type {string}
     * @memberof NodeCommandProperty
     */
    key?: string;
    /**
     * 
     * @type {object}
     * @memberof NodeCommandProperty
     */
    value?: object;
}
/**
 * 
 * @export
 * @interface Overdue
 */
export interface Overdue {
    /**
     * 
     * @type {number}
     * @memberof Overdue
     */
    initialReevaluationInterval?: number;
    /**
     * 
     * @type {Array<OverdueStateConfig>}
     * @memberof Overdue
     */
    overdueStates?: Array<OverdueStateConfig>;
}
/**
 * 
 * @export
 * @interface OverdueCondition
 */
export interface OverdueCondition {
    /**
     * 
     * @type {Duration}
     * @memberof OverdueCondition
     */
    timeSinceEarliestUnpaidInvoiceEqualsOrExceeds?: Duration;
    /**
     * 
     * @type {string}
     * @memberof OverdueCondition
     */
    controlTagInclusion?: OverdueConditionControlTagInclusionEnum;
    /**
     * 
     * @type {string}
     * @memberof OverdueCondition
     */
    controlTagExclusion?: OverdueConditionControlTagExclusionEnum;
    /**
     * 
     * @type {number}
     * @memberof OverdueCondition
     */
    numberOfUnpaidInvoicesEqualsOrExceeds?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof OverdueCondition
     */
    responseForLastFailedPayment?: Array<OverdueConditionResponseForLastFailedPaymentEnum>;
    /**
     * 
     * @type {number}
     * @memberof OverdueCondition
     */
    totalUnpaidInvoiceBalanceEqualsOrExceeds?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum OverdueConditionControlTagInclusionEnum {
    AUTOPAYOFF = 'AUTO_PAY_OFF',
    AUTOINVOICINGOFF = 'AUTO_INVOICING_OFF',
    OVERDUEENFORCEMENTOFF = 'OVERDUE_ENFORCEMENT_OFF',
    WRITTENOFF = 'WRITTEN_OFF',
    MANUALPAY = 'MANUAL_PAY',
    TEST = 'TEST',
    PARTNER = 'PARTNER',
    AUTOINVOICINGDRAFT = 'AUTO_INVOICING_DRAFT',
    AUTOINVOICINGREUSEDRAFT = 'AUTO_INVOICING_REUSE_DRAFT'
}
/**
    * @export
    * @enum {string}
    */
export enum OverdueConditionControlTagExclusionEnum {
    AUTOPAYOFF = 'AUTO_PAY_OFF',
    AUTOINVOICINGOFF = 'AUTO_INVOICING_OFF',
    OVERDUEENFORCEMENTOFF = 'OVERDUE_ENFORCEMENT_OFF',
    WRITTENOFF = 'WRITTEN_OFF',
    MANUALPAY = 'MANUAL_PAY',
    TEST = 'TEST',
    PARTNER = 'PARTNER',
    AUTOINVOICINGDRAFT = 'AUTO_INVOICING_DRAFT',
    AUTOINVOICINGREUSEDRAFT = 'AUTO_INVOICING_REUSE_DRAFT'
}
/**
    * @export
    * @enum {string}
    */
export enum OverdueConditionResponseForLastFailedPaymentEnum {
    INVALIDCARD = 'INVALID_CARD',
    EXPIREDCARD = 'EXPIRED_CARD',
    LOSTORSTOLENCARD = 'LOST_OR_STOLEN_CARD',
    DONOTHONOR = 'DO_NOT_HONOR',
    INSUFFICIENTFUNDS = 'INSUFFICIENT_FUNDS',
    DECLINE = 'DECLINE',
    PROCESSINGERROR = 'PROCESSING_ERROR',
    INVALIDAMOUNT = 'INVALID_AMOUNT',
    DUPLICATETRANSACTION = 'DUPLICATE_TRANSACTION',
    OTHER = 'OTHER'
}

/**
 * 
 * @export
 * @interface OverdueState
 */
export interface OverdueState {
    /**
     * 
     * @type {string}
     * @memberof OverdueState
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof OverdueState
     */
    externalMessage?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OverdueState
     */
    isDisableEntitlementAndChangesBlocked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OverdueState
     */
    isBlockChanges?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OverdueState
     */
    isClearState?: boolean;
    /**
     * 
     * @type {number}
     * @memberof OverdueState
     */
    reevaluationIntervalDays?: number;
}
/**
 * 
 * @export
 * @interface OverdueStateConfig
 */
export interface OverdueStateConfig {
    /**
     * 
     * @type {string}
     * @memberof OverdueStateConfig
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OverdueStateConfig
     */
    isClearState?: boolean;
    /**
     * 
     * @type {OverdueCondition}
     * @memberof OverdueStateConfig
     */
    condition?: OverdueCondition;
    /**
     * 
     * @type {string}
     * @memberof OverdueStateConfig
     */
    externalMessage?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OverdueStateConfig
     */
    isBlockChanges?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OverdueStateConfig
     */
    isDisableEntitlement?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OverdueStateConfig
     */
    subscriptionCancellationPolicy?: OverdueStateConfigSubscriptionCancellationPolicyEnum;
    /**
     * 
     * @type {number}
     * @memberof OverdueStateConfig
     */
    autoReevaluationIntervalDays?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum OverdueStateConfigSubscriptionCancellationPolicyEnum {
    ENDOFTERM = 'END_OF_TERM',
    IMMEDIATE = 'IMMEDIATE',
    NONE = 'NONE'
}

/**
 * 
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    accountId?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    paymentId?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    paymentNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    paymentExternalKey?: string;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    authAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    capturedAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    purchasedAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    refundedAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    creditedAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    currency?: PaymentCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    paymentMethodId?: string;
    /**
     * 
     * @type {Array<PaymentTransaction>}
     * @memberof Payment
     */
    transactions?: Array<PaymentTransaction>;
    /**
     * 
     * @type {Array<PaymentAttempt>}
     * @memberof Payment
     */
    paymentAttempts?: Array<PaymentAttempt>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof Payment
     */
    auditLogs?: Array<AuditLog>;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentCurrencyEnum {
    AED = 'AED',
    AFN = 'AFN',
    ALL = 'ALL',
    AMD = 'AMD',
    ANG = 'ANG',
    AOA = 'AOA',
    ARS = 'ARS',
    AUD = 'AUD',
    AWG = 'AWG',
    AZN = 'AZN',
    BAM = 'BAM',
    BBD = 'BBD',
    BDT = 'BDT',
    BGN = 'BGN',
    BHD = 'BHD',
    BIF = 'BIF',
    BMD = 'BMD',
    BND = 'BND',
    BOB = 'BOB',
    BRL = 'BRL',
    BSD = 'BSD',
    BTN = 'BTN',
    BWP = 'BWP',
    BYR = 'BYR',
    BZD = 'BZD',
    CAD = 'CAD',
    CDF = 'CDF',
    CHF = 'CHF',
    CLP = 'CLP',
    CNY = 'CNY',
    COP = 'COP',
    CRC = 'CRC',
    CUC = 'CUC',
    CUP = 'CUP',
    CVE = 'CVE',
    CZK = 'CZK',
    DJF = 'DJF',
    DKK = 'DKK',
    DOP = 'DOP',
    DZD = 'DZD',
    EGP = 'EGP',
    ERN = 'ERN',
    ETB = 'ETB',
    EUR = 'EUR',
    FJD = 'FJD',
    FKP = 'FKP',
    GBP = 'GBP',
    GEL = 'GEL',
    GGP = 'GGP',
    GHS = 'GHS',
    GIP = 'GIP',
    GMD = 'GMD',
    GNF = 'GNF',
    GTQ = 'GTQ',
    GYD = 'GYD',
    HKD = 'HKD',
    HNL = 'HNL',
    HRK = 'HRK',
    HTG = 'HTG',
    HUF = 'HUF',
    IDR = 'IDR',
    ILS = 'ILS',
    IMP = 'IMP',
    INR = 'INR',
    IQD = 'IQD',
    IRR = 'IRR',
    ISK = 'ISK',
    JEP = 'JEP',
    JMD = 'JMD',
    JOD = 'JOD',
    JPY = 'JPY',
    KES = 'KES',
    KGS = 'KGS',
    KHR = 'KHR',
    KMF = 'KMF',
    KPW = 'KPW',
    KRW = 'KRW',
    KWD = 'KWD',
    KYD = 'KYD',
    KZT = 'KZT',
    LAK = 'LAK',
    LBP = 'LBP',
    LKR = 'LKR',
    LRD = 'LRD',
    LSL = 'LSL',
    LTL = 'LTL',
    LVL = 'LVL',
    LYD = 'LYD',
    MAD = 'MAD',
    MDL = 'MDL',
    MGA = 'MGA',
    MKD = 'MKD',
    MMK = 'MMK',
    MNT = 'MNT',
    MOP = 'MOP',
    MRO = 'MRO',
    MUR = 'MUR',
    MVR = 'MVR',
    MWK = 'MWK',
    MXN = 'MXN',
    MYR = 'MYR',
    MZN = 'MZN',
    NAD = 'NAD',
    NGN = 'NGN',
    NIO = 'NIO',
    NOK = 'NOK',
    NPR = 'NPR',
    NZD = 'NZD',
    OMR = 'OMR',
    PAB = 'PAB',
    PEN = 'PEN',
    PGK = 'PGK',
    PHP = 'PHP',
    PKR = 'PKR',
    PLN = 'PLN',
    PYG = 'PYG',
    QAR = 'QAR',
    RON = 'RON',
    RSD = 'RSD',
    RUB = 'RUB',
    RWF = 'RWF',
    SAR = 'SAR',
    SBD = 'SBD',
    SCR = 'SCR',
    SDG = 'SDG',
    SEK = 'SEK',
    SGD = 'SGD',
    SHP = 'SHP',
    SLL = 'SLL',
    SOS = 'SOS',
    SPL = 'SPL',
    SRD = 'SRD',
    STD = 'STD',
    SVC = 'SVC',
    SYP = 'SYP',
    SZL = 'SZL',
    THB = 'THB',
    TJS = 'TJS',
    TMT = 'TMT',
    TND = 'TND',
    TOP = 'TOP',
    TRY = 'TRY',
    TTD = 'TTD',
    TVD = 'TVD',
    TWD = 'TWD',
    TZS = 'TZS',
    UAH = 'UAH',
    UGX = 'UGX',
    USD = 'USD',
    UYU = 'UYU',
    UZS = 'UZS',
    VEF = 'VEF',
    VND = 'VND',
    VUV = 'VUV',
    WST = 'WST',
    XAF = 'XAF',
    XCD = 'XCD',
    XDR = 'XDR',
    XOF = 'XOF',
    XPF = 'XPF',
    YER = 'YER',
    ZAR = 'ZAR',
    ZMW = 'ZMW',
    ZWD = 'ZWD',
    BTC = 'BTC'
}

/**
 * 
 * @export
 * @interface PaymentAttempt
 */
export interface PaymentAttempt {
    /**
     * 
     * @type {string}
     * @memberof PaymentAttempt
     */
    accountId?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentAttempt
     */
    paymentMethodId?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentAttempt
     */
    paymentExternalKey?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentAttempt
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentAttempt
     */
    transactionExternalKey?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentAttempt
     */
    transactionType?: PaymentAttemptTransactionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentAttempt
     */
    effectiveDate?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentAttempt
     */
    stateName?: string;
    /**
     * Transaction amount, required except for void operations
     * @type {number}
     * @memberof PaymentAttempt
     */
    amount?: number;
    /**
     * Amount currency (account currency unless specified)
     * @type {string}
     * @memberof PaymentAttempt
     */
    currency?: PaymentAttemptCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentAttempt
     */
    pluginName?: string;
    /**
     * 
     * @type {Array<PluginProperty>}
     * @memberof PaymentAttempt
     */
    pluginProperties?: Array<PluginProperty>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof PaymentAttempt
     */
    auditLogs?: Array<AuditLog>;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentAttemptTransactionTypeEnum {
    AUTHORIZE = 'AUTHORIZE',
    CAPTURE = 'CAPTURE',
    CHARGEBACK = 'CHARGEBACK',
    CREDIT = 'CREDIT',
    PURCHASE = 'PURCHASE',
    REFUND = 'REFUND',
    VOID = 'VOID'
}
/**
    * @export
    * @enum {string}
    */
export enum PaymentAttemptCurrencyEnum {
    AED = 'AED',
    AFN = 'AFN',
    ALL = 'ALL',
    AMD = 'AMD',
    ANG = 'ANG',
    AOA = 'AOA',
    ARS = 'ARS',
    AUD = 'AUD',
    AWG = 'AWG',
    AZN = 'AZN',
    BAM = 'BAM',
    BBD = 'BBD',
    BDT = 'BDT',
    BGN = 'BGN',
    BHD = 'BHD',
    BIF = 'BIF',
    BMD = 'BMD',
    BND = 'BND',
    BOB = 'BOB',
    BRL = 'BRL',
    BSD = 'BSD',
    BTN = 'BTN',
    BWP = 'BWP',
    BYR = 'BYR',
    BZD = 'BZD',
    CAD = 'CAD',
    CDF = 'CDF',
    CHF = 'CHF',
    CLP = 'CLP',
    CNY = 'CNY',
    COP = 'COP',
    CRC = 'CRC',
    CUC = 'CUC',
    CUP = 'CUP',
    CVE = 'CVE',
    CZK = 'CZK',
    DJF = 'DJF',
    DKK = 'DKK',
    DOP = 'DOP',
    DZD = 'DZD',
    EGP = 'EGP',
    ERN = 'ERN',
    ETB = 'ETB',
    EUR = 'EUR',
    FJD = 'FJD',
    FKP = 'FKP',
    GBP = 'GBP',
    GEL = 'GEL',
    GGP = 'GGP',
    GHS = 'GHS',
    GIP = 'GIP',
    GMD = 'GMD',
    GNF = 'GNF',
    GTQ = 'GTQ',
    GYD = 'GYD',
    HKD = 'HKD',
    HNL = 'HNL',
    HRK = 'HRK',
    HTG = 'HTG',
    HUF = 'HUF',
    IDR = 'IDR',
    ILS = 'ILS',
    IMP = 'IMP',
    INR = 'INR',
    IQD = 'IQD',
    IRR = 'IRR',
    ISK = 'ISK',
    JEP = 'JEP',
    JMD = 'JMD',
    JOD = 'JOD',
    JPY = 'JPY',
    KES = 'KES',
    KGS = 'KGS',
    KHR = 'KHR',
    KMF = 'KMF',
    KPW = 'KPW',
    KRW = 'KRW',
    KWD = 'KWD',
    KYD = 'KYD',
    KZT = 'KZT',
    LAK = 'LAK',
    LBP = 'LBP',
    LKR = 'LKR',
    LRD = 'LRD',
    LSL = 'LSL',
    LTL = 'LTL',
    LVL = 'LVL',
    LYD = 'LYD',
    MAD = 'MAD',
    MDL = 'MDL',
    MGA = 'MGA',
    MKD = 'MKD',
    MMK = 'MMK',
    MNT = 'MNT',
    MOP = 'MOP',
    MRO = 'MRO',
    MUR = 'MUR',
    MVR = 'MVR',
    MWK = 'MWK',
    MXN = 'MXN',
    MYR = 'MYR',
    MZN = 'MZN',
    NAD = 'NAD',
    NGN = 'NGN',
    NIO = 'NIO',
    NOK = 'NOK',
    NPR = 'NPR',
    NZD = 'NZD',
    OMR = 'OMR',
    PAB = 'PAB',
    PEN = 'PEN',
    PGK = 'PGK',
    PHP = 'PHP',
    PKR = 'PKR',
    PLN = 'PLN',
    PYG = 'PYG',
    QAR = 'QAR',
    RON = 'RON',
    RSD = 'RSD',
    RUB = 'RUB',
    RWF = 'RWF',
    SAR = 'SAR',
    SBD = 'SBD',
    SCR = 'SCR',
    SDG = 'SDG',
    SEK = 'SEK',
    SGD = 'SGD',
    SHP = 'SHP',
    SLL = 'SLL',
    SOS = 'SOS',
    SPL = 'SPL',
    SRD = 'SRD',
    STD = 'STD',
    SVC = 'SVC',
    SYP = 'SYP',
    SZL = 'SZL',
    THB = 'THB',
    TJS = 'TJS',
    TMT = 'TMT',
    TND = 'TND',
    TOP = 'TOP',
    TRY = 'TRY',
    TTD = 'TTD',
    TVD = 'TVD',
    TWD = 'TWD',
    TZS = 'TZS',
    UAH = 'UAH',
    UGX = 'UGX',
    USD = 'USD',
    UYU = 'UYU',
    UZS = 'UZS',
    VEF = 'VEF',
    VND = 'VND',
    VUV = 'VUV',
    WST = 'WST',
    XAF = 'XAF',
    XCD = 'XCD',
    XDR = 'XDR',
    XOF = 'XOF',
    XPF = 'XPF',
    YER = 'YER',
    ZAR = 'ZAR',
    ZMW = 'ZMW',
    ZWD = 'ZWD',
    BTC = 'BTC'
}

/**
 * 
 * @export
 * @interface PaymentMethod
 */
export interface PaymentMethod {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    paymentMethodId?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    externalKey?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    accountId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethod
     */
    isDefault?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    pluginName?: string;
    /**
     * 
     * @type {PaymentMethodPluginDetail}
     * @memberof PaymentMethod
     */
    pluginInfo?: PaymentMethodPluginDetail;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof PaymentMethod
     */
    auditLogs?: Array<AuditLog>;
}
/**
 * 
 * @export
 * @interface PaymentMethodPluginDetail
 */
export interface PaymentMethodPluginDetail {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethodPluginDetail
     */
    externalPaymentMethodId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethodPluginDetail
     */
    isDefaultPaymentMethod?: boolean;
    /**
     * 
     * @type {Array<PluginProperty>}
     * @memberof PaymentMethodPluginDetail
     */
    properties?: Array<PluginProperty>;
}
/**
 * 
 * @export
 * @interface PaymentTransaction
 */
export interface PaymentTransaction {
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    transactionExternalKey?: string;
    /**
     * Associated payment id, required when notifying state transitions
     * @type {string}
     * @memberof PaymentTransaction
     */
    paymentId?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    paymentExternalKey?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    transactionType?: PaymentTransactionTransactionTypeEnum;
    /**
     * Transaction amount, required except for void operations
     * @type {number}
     * @memberof PaymentTransaction
     */
    amount?: number;
    /**
     * Amount currency (account currency unless specified)
     * @type {string}
     * @memberof PaymentTransaction
     */
    currency?: PaymentTransactionCurrencyEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    effectiveDate?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentTransaction
     */
    processedAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    processedCurrency?: PaymentTransactionProcessedCurrencyEnum;
    /**
     * Transaction status, required for state change notifications
     * @type {string}
     * @memberof PaymentTransaction
     */
    status?: PaymentTransactionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    gatewayErrorCode?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    gatewayErrorMsg?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    firstPaymentReferenceId?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentTransaction
     */
    secondPaymentReferenceId?: string;
    /**
     * 
     * @type {Array<PluginProperty>}
     * @memberof PaymentTransaction
     */
    properties?: Array<PluginProperty>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof PaymentTransaction
     */
    auditLogs?: Array<AuditLog>;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentTransactionTransactionTypeEnum {
    AUTHORIZE = 'AUTHORIZE',
    CAPTURE = 'CAPTURE',
    CHARGEBACK = 'CHARGEBACK',
    CREDIT = 'CREDIT',
    PURCHASE = 'PURCHASE',
    REFUND = 'REFUND',
    VOID = 'VOID'
}
/**
    * @export
    * @enum {string}
    */
export enum PaymentTransactionCurrencyEnum {
    AED = 'AED',
    AFN = 'AFN',
    ALL = 'ALL',
    AMD = 'AMD',
    ANG = 'ANG',
    AOA = 'AOA',
    ARS = 'ARS',
    AUD = 'AUD',
    AWG = 'AWG',
    AZN = 'AZN',
    BAM = 'BAM',
    BBD = 'BBD',
    BDT = 'BDT',
    BGN = 'BGN',
    BHD = 'BHD',
    BIF = 'BIF',
    BMD = 'BMD',
    BND = 'BND',
    BOB = 'BOB',
    BRL = 'BRL',
    BSD = 'BSD',
    BTN = 'BTN',
    BWP = 'BWP',
    BYR = 'BYR',
    BZD = 'BZD',
    CAD = 'CAD',
    CDF = 'CDF',
    CHF = 'CHF',
    CLP = 'CLP',
    CNY = 'CNY',
    COP = 'COP',
    CRC = 'CRC',
    CUC = 'CUC',
    CUP = 'CUP',
    CVE = 'CVE',
    CZK = 'CZK',
    DJF = 'DJF',
    DKK = 'DKK',
    DOP = 'DOP',
    DZD = 'DZD',
    EGP = 'EGP',
    ERN = 'ERN',
    ETB = 'ETB',
    EUR = 'EUR',
    FJD = 'FJD',
    FKP = 'FKP',
    GBP = 'GBP',
    GEL = 'GEL',
    GGP = 'GGP',
    GHS = 'GHS',
    GIP = 'GIP',
    GMD = 'GMD',
    GNF = 'GNF',
    GTQ = 'GTQ',
    GYD = 'GYD',
    HKD = 'HKD',
    HNL = 'HNL',
    HRK = 'HRK',
    HTG = 'HTG',
    HUF = 'HUF',
    IDR = 'IDR',
    ILS = 'ILS',
    IMP = 'IMP',
    INR = 'INR',
    IQD = 'IQD',
    IRR = 'IRR',
    ISK = 'ISK',
    JEP = 'JEP',
    JMD = 'JMD',
    JOD = 'JOD',
    JPY = 'JPY',
    KES = 'KES',
    KGS = 'KGS',
    KHR = 'KHR',
    KMF = 'KMF',
    KPW = 'KPW',
    KRW = 'KRW',
    KWD = 'KWD',
    KYD = 'KYD',
    KZT = 'KZT',
    LAK = 'LAK',
    LBP = 'LBP',
    LKR = 'LKR',
    LRD = 'LRD',
    LSL = 'LSL',
    LTL = 'LTL',
    LVL = 'LVL',
    LYD = 'LYD',
    MAD = 'MAD',
    MDL = 'MDL',
    MGA = 'MGA',
    MKD = 'MKD',
    MMK = 'MMK',
    MNT = 'MNT',
    MOP = 'MOP',
    MRO = 'MRO',
    MUR = 'MUR',
    MVR = 'MVR',
    MWK = 'MWK',
    MXN = 'MXN',
    MYR = 'MYR',
    MZN = 'MZN',
    NAD = 'NAD',
    NGN = 'NGN',
    NIO = 'NIO',
    NOK = 'NOK',
    NPR = 'NPR',
    NZD = 'NZD',
    OMR = 'OMR',
    PAB = 'PAB',
    PEN = 'PEN',
    PGK = 'PGK',
    PHP = 'PHP',
    PKR = 'PKR',
    PLN = 'PLN',
    PYG = 'PYG',
    QAR = 'QAR',
    RON = 'RON',
    RSD = 'RSD',
    RUB = 'RUB',
    RWF = 'RWF',
    SAR = 'SAR',
    SBD = 'SBD',
    SCR = 'SCR',
    SDG = 'SDG',
    SEK = 'SEK',
    SGD = 'SGD',
    SHP = 'SHP',
    SLL = 'SLL',
    SOS = 'SOS',
    SPL = 'SPL',
    SRD = 'SRD',
    STD = 'STD',
    SVC = 'SVC',
    SYP = 'SYP',
    SZL = 'SZL',
    THB = 'THB',
    TJS = 'TJS',
    TMT = 'TMT',
    TND = 'TND',
    TOP = 'TOP',
    TRY = 'TRY',
    TTD = 'TTD',
    TVD = 'TVD',
    TWD = 'TWD',
    TZS = 'TZS',
    UAH = 'UAH',
    UGX = 'UGX',
    USD = 'USD',
    UYU = 'UYU',
    UZS = 'UZS',
    VEF = 'VEF',
    VND = 'VND',
    VUV = 'VUV',
    WST = 'WST',
    XAF = 'XAF',
    XCD = 'XCD',
    XDR = 'XDR',
    XOF = 'XOF',
    XPF = 'XPF',
    YER = 'YER',
    ZAR = 'ZAR',
    ZMW = 'ZMW',
    ZWD = 'ZWD',
    BTC = 'BTC'
}
/**
    * @export
    * @enum {string}
    */
export enum PaymentTransactionProcessedCurrencyEnum {
    AED = 'AED',
    AFN = 'AFN',
    ALL = 'ALL',
    AMD = 'AMD',
    ANG = 'ANG',
    AOA = 'AOA',
    ARS = 'ARS',
    AUD = 'AUD',
    AWG = 'AWG',
    AZN = 'AZN',
    BAM = 'BAM',
    BBD = 'BBD',
    BDT = 'BDT',
    BGN = 'BGN',
    BHD = 'BHD',
    BIF = 'BIF',
    BMD = 'BMD',
    BND = 'BND',
    BOB = 'BOB',
    BRL = 'BRL',
    BSD = 'BSD',
    BTN = 'BTN',
    BWP = 'BWP',
    BYR = 'BYR',
    BZD = 'BZD',
    CAD = 'CAD',
    CDF = 'CDF',
    CHF = 'CHF',
    CLP = 'CLP',
    CNY = 'CNY',
    COP = 'COP',
    CRC = 'CRC',
    CUC = 'CUC',
    CUP = 'CUP',
    CVE = 'CVE',
    CZK = 'CZK',
    DJF = 'DJF',
    DKK = 'DKK',
    DOP = 'DOP',
    DZD = 'DZD',
    EGP = 'EGP',
    ERN = 'ERN',
    ETB = 'ETB',
    EUR = 'EUR',
    FJD = 'FJD',
    FKP = 'FKP',
    GBP = 'GBP',
    GEL = 'GEL',
    GGP = 'GGP',
    GHS = 'GHS',
    GIP = 'GIP',
    GMD = 'GMD',
    GNF = 'GNF',
    GTQ = 'GTQ',
    GYD = 'GYD',
    HKD = 'HKD',
    HNL = 'HNL',
    HRK = 'HRK',
    HTG = 'HTG',
    HUF = 'HUF',
    IDR = 'IDR',
    ILS = 'ILS',
    IMP = 'IMP',
    INR = 'INR',
    IQD = 'IQD',
    IRR = 'IRR',
    ISK = 'ISK',
    JEP = 'JEP',
    JMD = 'JMD',
    JOD = 'JOD',
    JPY = 'JPY',
    KES = 'KES',
    KGS = 'KGS',
    KHR = 'KHR',
    KMF = 'KMF',
    KPW = 'KPW',
    KRW = 'KRW',
    KWD = 'KWD',
    KYD = 'KYD',
    KZT = 'KZT',
    LAK = 'LAK',
    LBP = 'LBP',
    LKR = 'LKR',
    LRD = 'LRD',
    LSL = 'LSL',
    LTL = 'LTL',
    LVL = 'LVL',
    LYD = 'LYD',
    MAD = 'MAD',
    MDL = 'MDL',
    MGA = 'MGA',
    MKD = 'MKD',
    MMK = 'MMK',
    MNT = 'MNT',
    MOP = 'MOP',
    MRO = 'MRO',
    MUR = 'MUR',
    MVR = 'MVR',
    MWK = 'MWK',
    MXN = 'MXN',
    MYR = 'MYR',
    MZN = 'MZN',
    NAD = 'NAD',
    NGN = 'NGN',
    NIO = 'NIO',
    NOK = 'NOK',
    NPR = 'NPR',
    NZD = 'NZD',
    OMR = 'OMR',
    PAB = 'PAB',
    PEN = 'PEN',
    PGK = 'PGK',
    PHP = 'PHP',
    PKR = 'PKR',
    PLN = 'PLN',
    PYG = 'PYG',
    QAR = 'QAR',
    RON = 'RON',
    RSD = 'RSD',
    RUB = 'RUB',
    RWF = 'RWF',
    SAR = 'SAR',
    SBD = 'SBD',
    SCR = 'SCR',
    SDG = 'SDG',
    SEK = 'SEK',
    SGD = 'SGD',
    SHP = 'SHP',
    SLL = 'SLL',
    SOS = 'SOS',
    SPL = 'SPL',
    SRD = 'SRD',
    STD = 'STD',
    SVC = 'SVC',
    SYP = 'SYP',
    SZL = 'SZL',
    THB = 'THB',
    TJS = 'TJS',
    TMT = 'TMT',
    TND = 'TND',
    TOP = 'TOP',
    TRY = 'TRY',
    TTD = 'TTD',
    TVD = 'TVD',
    TWD = 'TWD',
    TZS = 'TZS',
    UAH = 'UAH',
    UGX = 'UGX',
    USD = 'USD',
    UYU = 'UYU',
    UZS = 'UZS',
    VEF = 'VEF',
    VND = 'VND',
    VUV = 'VUV',
    WST = 'WST',
    XAF = 'XAF',
    XCD = 'XCD',
    XDR = 'XDR',
    XOF = 'XOF',
    XPF = 'XPF',
    YER = 'YER',
    ZAR = 'ZAR',
    ZMW = 'ZMW',
    ZWD = 'ZWD',
    BTC = 'BTC'
}
/**
    * @export
    * @enum {string}
    */
export enum PaymentTransactionStatusEnum {
    SUCCESS = 'SUCCESS',
    UNKNOWN = 'UNKNOWN',
    PENDING = 'PENDING',
    PAYMENTFAILURE = 'PAYMENT_FAILURE',
    PLUGINFAILURE = 'PLUGIN_FAILURE',
    PAYMENTSYSTEMOFF = 'PAYMENT_SYSTEM_OFF'
}

/**
 * 
 * @export
 * @interface Phase
 */
export interface Phase {
    /**
     * 
     * @type {string}
     * @memberof Phase
     */
    type?: string;
    /**
     * 
     * @type {Array<Price>}
     * @memberof Phase
     */
    prices?: Array<Price>;
    /**
     * 
     * @type {Array<Price>}
     * @memberof Phase
     */
    fixedPrices?: Array<Price>;
    /**
     * 
     * @type {Duration}
     * @memberof Phase
     */
    duration?: Duration;
    /**
     * 
     * @type {Array<Usage>}
     * @memberof Phase
     */
    usages?: Array<Usage>;
}
/**
 * 
 * @export
 * @interface PhasePrice
 */
export interface PhasePrice {
    /**
     * 
     * @type {string}
     * @memberof PhasePrice
     */
    planName?: string;
    /**
     * 
     * @type {string}
     * @memberof PhasePrice
     */
    phaseName?: string;
    /**
     * 
     * @type {string}
     * @memberof PhasePrice
     */
    phaseType?: string;
    /**
     * 
     * @type {number}
     * @memberof PhasePrice
     */
    fixedPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof PhasePrice
     */
    recurringPrice?: number;
    /**
     * 
     * @type {Array<UsagePrice>}
     * @memberof PhasePrice
     */
    usagePrices?: Array<UsagePrice>;
}
/**
 * 
 * @export
 * @interface Plan
 */
export interface Plan {
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    prettyName?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    billingPeriod?: PlanBillingPeriodEnum;
    /**
     * 
     * @type {Array<Phase>}
     * @memberof Plan
     */
    phases?: Array<Phase>;
}

/**
    * @export
    * @enum {string}
    */
export enum PlanBillingPeriodEnum {
    DAILY = 'DAILY',
    WEEKLY = 'WEEKLY',
    BIWEEKLY = 'BIWEEKLY',
    THIRTYDAYS = 'THIRTY_DAYS',
    SIXTYDAYS = 'SIXTY_DAYS',
    NINETYDAYS = 'NINETY_DAYS',
    MONTHLY = 'MONTHLY',
    BIMESTRIAL = 'BIMESTRIAL',
    QUARTERLY = 'QUARTERLY',
    TRIANNUAL = 'TRIANNUAL',
    BIANNUAL = 'BIANNUAL',
    ANNUAL = 'ANNUAL',
    BIENNIAL = 'BIENNIAL',
    NOBILLINGPERIOD = 'NO_BILLING_PERIOD'
}

/**
 * 
 * @export
 * @interface PlanDetail
 */
export interface PlanDetail {
    /**
     * 
     * @type {string}
     * @memberof PlanDetail
     */
    product?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanDetail
     */
    plan?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanDetail
     */
    priceList?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanDetail
     */
    finalPhaseBillingPeriod?: PlanDetailFinalPhaseBillingPeriodEnum;
    /**
     * 
     * @type {Array<Price>}
     * @memberof PlanDetail
     */
    finalPhaseRecurringPrice?: Array<Price>;
}

/**
    * @export
    * @enum {string}
    */
export enum PlanDetailFinalPhaseBillingPeriodEnum {
    DAILY = 'DAILY',
    WEEKLY = 'WEEKLY',
    BIWEEKLY = 'BIWEEKLY',
    THIRTYDAYS = 'THIRTY_DAYS',
    SIXTYDAYS = 'SIXTY_DAYS',
    NINETYDAYS = 'NINETY_DAYS',
    MONTHLY = 'MONTHLY',
    BIMESTRIAL = 'BIMESTRIAL',
    QUARTERLY = 'QUARTERLY',
    TRIANNUAL = 'TRIANNUAL',
    BIANNUAL = 'BIANNUAL',
    ANNUAL = 'ANNUAL',
    BIENNIAL = 'BIENNIAL',
    NOBILLINGPERIOD = 'NO_BILLING_PERIOD'
}

/**
 * 
 * @export
 * @interface PluginInfo
 */
export interface PluginInfo {
    /**
     * 
     * @type {string}
     * @memberof PluginInfo
     */
    bundleSymbolicName?: string;
    /**
     * 
     * @type {string}
     * @memberof PluginInfo
     */
    pluginKey?: string;
    /**
     * 
     * @type {string}
     * @memberof PluginInfo
     */
    pluginName?: string;
    /**
     * 
     * @type {string}
     * @memberof PluginInfo
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof PluginInfo
     */
    state?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PluginInfo
     */
    isSelectedForStart?: boolean;
    /**
     * 
     * @type {Array<PluginServiceInfo>}
     * @memberof PluginInfo
     */
    services?: Array<PluginServiceInfo>;
}
/**
 * 
 * @export
 * @interface PluginProperty
 */
export interface PluginProperty {
    /**
     * 
     * @type {string}
     * @memberof PluginProperty
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof PluginProperty
     */
    value?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PluginProperty
     */
    isUpdatable?: boolean;
}
/**
 * 
 * @export
 * @interface PluginServiceInfo
 */
export interface PluginServiceInfo {
    /**
     * 
     * @type {string}
     * @memberof PluginServiceInfo
     */
    serviceTypeName?: string;
    /**
     * 
     * @type {string}
     * @memberof PluginServiceInfo
     */
    registrationName?: string;
}
/**
 * 
 * @export
 * @interface Price
 */
export interface Price {
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    currency?: PriceCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    value?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum PriceCurrencyEnum {
    AED = 'AED',
    AFN = 'AFN',
    ALL = 'ALL',
    AMD = 'AMD',
    ANG = 'ANG',
    AOA = 'AOA',
    ARS = 'ARS',
    AUD = 'AUD',
    AWG = 'AWG',
    AZN = 'AZN',
    BAM = 'BAM',
    BBD = 'BBD',
    BDT = 'BDT',
    BGN = 'BGN',
    BHD = 'BHD',
    BIF = 'BIF',
    BMD = 'BMD',
    BND = 'BND',
    BOB = 'BOB',
    BRL = 'BRL',
    BSD = 'BSD',
    BTN = 'BTN',
    BWP = 'BWP',
    BYR = 'BYR',
    BZD = 'BZD',
    CAD = 'CAD',
    CDF = 'CDF',
    CHF = 'CHF',
    CLP = 'CLP',
    CNY = 'CNY',
    COP = 'COP',
    CRC = 'CRC',
    CUC = 'CUC',
    CUP = 'CUP',
    CVE = 'CVE',
    CZK = 'CZK',
    DJF = 'DJF',
    DKK = 'DKK',
    DOP = 'DOP',
    DZD = 'DZD',
    EGP = 'EGP',
    ERN = 'ERN',
    ETB = 'ETB',
    EUR = 'EUR',
    FJD = 'FJD',
    FKP = 'FKP',
    GBP = 'GBP',
    GEL = 'GEL',
    GGP = 'GGP',
    GHS = 'GHS',
    GIP = 'GIP',
    GMD = 'GMD',
    GNF = 'GNF',
    GTQ = 'GTQ',
    GYD = 'GYD',
    HKD = 'HKD',
    HNL = 'HNL',
    HRK = 'HRK',
    HTG = 'HTG',
    HUF = 'HUF',
    IDR = 'IDR',
    ILS = 'ILS',
    IMP = 'IMP',
    INR = 'INR',
    IQD = 'IQD',
    IRR = 'IRR',
    ISK = 'ISK',
    JEP = 'JEP',
    JMD = 'JMD',
    JOD = 'JOD',
    JPY = 'JPY',
    KES = 'KES',
    KGS = 'KGS',
    KHR = 'KHR',
    KMF = 'KMF',
    KPW = 'KPW',
    KRW = 'KRW',
    KWD = 'KWD',
    KYD = 'KYD',
    KZT = 'KZT',
    LAK = 'LAK',
    LBP = 'LBP',
    LKR = 'LKR',
    LRD = 'LRD',
    LSL = 'LSL',
    LTL = 'LTL',
    LVL = 'LVL',
    LYD = 'LYD',
    MAD = 'MAD',
    MDL = 'MDL',
    MGA = 'MGA',
    MKD = 'MKD',
    MMK = 'MMK',
    MNT = 'MNT',
    MOP = 'MOP',
    MRO = 'MRO',
    MUR = 'MUR',
    MVR = 'MVR',
    MWK = 'MWK',
    MXN = 'MXN',
    MYR = 'MYR',
    MZN = 'MZN',
    NAD = 'NAD',
    NGN = 'NGN',
    NIO = 'NIO',
    NOK = 'NOK',
    NPR = 'NPR',
    NZD = 'NZD',
    OMR = 'OMR',
    PAB = 'PAB',
    PEN = 'PEN',
    PGK = 'PGK',
    PHP = 'PHP',
    PKR = 'PKR',
    PLN = 'PLN',
    PYG = 'PYG',
    QAR = 'QAR',
    RON = 'RON',
    RSD = 'RSD',
    RUB = 'RUB',
    RWF = 'RWF',
    SAR = 'SAR',
    SBD = 'SBD',
    SCR = 'SCR',
    SDG = 'SDG',
    SEK = 'SEK',
    SGD = 'SGD',
    SHP = 'SHP',
    SLL = 'SLL',
    SOS = 'SOS',
    SPL = 'SPL',
    SRD = 'SRD',
    STD = 'STD',
    SVC = 'SVC',
    SYP = 'SYP',
    SZL = 'SZL',
    THB = 'THB',
    TJS = 'TJS',
    TMT = 'TMT',
    TND = 'TND',
    TOP = 'TOP',
    TRY = 'TRY',
    TTD = 'TTD',
    TVD = 'TVD',
    TWD = 'TWD',
    TZS = 'TZS',
    UAH = 'UAH',
    UGX = 'UGX',
    USD = 'USD',
    UYU = 'UYU',
    UZS = 'UZS',
    VEF = 'VEF',
    VND = 'VND',
    VUV = 'VUV',
    WST = 'WST',
    XAF = 'XAF',
    XCD = 'XCD',
    XDR = 'XDR',
    XOF = 'XOF',
    XPF = 'XPF',
    YER = 'YER',
    ZAR = 'ZAR',
    ZMW = 'ZMW',
    ZWD = 'ZWD',
    BTC = 'BTC'
}

/**
 * 
 * @export
 * @interface PriceList
 */
export interface PriceList {
    /**
     * 
     * @type {string}
     * @memberof PriceList
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PriceList
     */
    plans?: Array<string>;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    prettyName?: string;
    /**
     * 
     * @type {Array<Plan>}
     * @memberof Product
     */
    plans?: Array<Plan>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Product
     */
    included?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Product
     */
    available?: Array<string>;
}
/**
 * 
 * @export
 * @interface RoleDefinition
 */
export interface RoleDefinition {
    /**
     * 
     * @type {string}
     * @memberof RoleDefinition
     */
    role: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleDefinition
     */
    permissions: Array<string>;
}
/**
 * 
 * @export
 * @interface RolledUpUnit
 */
export interface RolledUpUnit {
    /**
     * 
     * @type {string}
     * @memberof RolledUpUnit
     */
    unitType?: string;
    /**
     * 
     * @type {number}
     * @memberof RolledUpUnit
     */
    amount?: number;
}
/**
 * 
 * @export
 * @interface RolledUpUsage
 */
export interface RolledUpUsage {
    /**
     * 
     * @type {string}
     * @memberof RolledUpUsage
     */
    subscriptionId?: string;
    /**
     * 
     * @type {string}
     * @memberof RolledUpUsage
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof RolledUpUsage
     */
    endDate?: string;
    /**
     * 
     * @type {Array<RolledUpUnit>}
     * @memberof RolledUpUsage
     */
    rolledUpUnits?: Array<RolledUpUnit>;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    lastAccessDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    timeout?: number;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    host?: string;
}
/**
 * 
 * @export
 * @interface SimplePlan
 */
export interface SimplePlan {
    /**
     * 
     * @type {string}
     * @memberof SimplePlan
     */
    planId?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplePlan
     */
    productName?: string;
    /**
     * 
     * @type {string}
     * @memberof SimplePlan
     */
    productCategory?: SimplePlanProductCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof SimplePlan
     */
    currency?: SimplePlanCurrencyEnum;
    /**
     * 
     * @type {number}
     * @memberof SimplePlan
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof SimplePlan
     */
    billingPeriod?: SimplePlanBillingPeriodEnum;
    /**
     * 
     * @type {number}
     * @memberof SimplePlan
     */
    trialLength?: number;
    /**
     * 
     * @type {string}
     * @memberof SimplePlan
     */
    trialTimeUnit?: SimplePlanTrialTimeUnitEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof SimplePlan
     */
    availableBaseProducts?: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum SimplePlanProductCategoryEnum {
    BASE = 'BASE',
    ADDON = 'ADD_ON',
    STANDALONE = 'STANDALONE'
}
/**
    * @export
    * @enum {string}
    */
export enum SimplePlanCurrencyEnum {
    AED = 'AED',
    AFN = 'AFN',
    ALL = 'ALL',
    AMD = 'AMD',
    ANG = 'ANG',
    AOA = 'AOA',
    ARS = 'ARS',
    AUD = 'AUD',
    AWG = 'AWG',
    AZN = 'AZN',
    BAM = 'BAM',
    BBD = 'BBD',
    BDT = 'BDT',
    BGN = 'BGN',
    BHD = 'BHD',
    BIF = 'BIF',
    BMD = 'BMD',
    BND = 'BND',
    BOB = 'BOB',
    BRL = 'BRL',
    BSD = 'BSD',
    BTN = 'BTN',
    BWP = 'BWP',
    BYR = 'BYR',
    BZD = 'BZD',
    CAD = 'CAD',
    CDF = 'CDF',
    CHF = 'CHF',
    CLP = 'CLP',
    CNY = 'CNY',
    COP = 'COP',
    CRC = 'CRC',
    CUC = 'CUC',
    CUP = 'CUP',
    CVE = 'CVE',
    CZK = 'CZK',
    DJF = 'DJF',
    DKK = 'DKK',
    DOP = 'DOP',
    DZD = 'DZD',
    EGP = 'EGP',
    ERN = 'ERN',
    ETB = 'ETB',
    EUR = 'EUR',
    FJD = 'FJD',
    FKP = 'FKP',
    GBP = 'GBP',
    GEL = 'GEL',
    GGP = 'GGP',
    GHS = 'GHS',
    GIP = 'GIP',
    GMD = 'GMD',
    GNF = 'GNF',
    GTQ = 'GTQ',
    GYD = 'GYD',
    HKD = 'HKD',
    HNL = 'HNL',
    HRK = 'HRK',
    HTG = 'HTG',
    HUF = 'HUF',
    IDR = 'IDR',
    ILS = 'ILS',
    IMP = 'IMP',
    INR = 'INR',
    IQD = 'IQD',
    IRR = 'IRR',
    ISK = 'ISK',
    JEP = 'JEP',
    JMD = 'JMD',
    JOD = 'JOD',
    JPY = 'JPY',
    KES = 'KES',
    KGS = 'KGS',
    KHR = 'KHR',
    KMF = 'KMF',
    KPW = 'KPW',
    KRW = 'KRW',
    KWD = 'KWD',
    KYD = 'KYD',
    KZT = 'KZT',
    LAK = 'LAK',
    LBP = 'LBP',
    LKR = 'LKR',
    LRD = 'LRD',
    LSL = 'LSL',
    LTL = 'LTL',
    LVL = 'LVL',
    LYD = 'LYD',
    MAD = 'MAD',
    MDL = 'MDL',
    MGA = 'MGA',
    MKD = 'MKD',
    MMK = 'MMK',
    MNT = 'MNT',
    MOP = 'MOP',
    MRO = 'MRO',
    MUR = 'MUR',
    MVR = 'MVR',
    MWK = 'MWK',
    MXN = 'MXN',
    MYR = 'MYR',
    MZN = 'MZN',
    NAD = 'NAD',
    NGN = 'NGN',
    NIO = 'NIO',
    NOK = 'NOK',
    NPR = 'NPR',
    NZD = 'NZD',
    OMR = 'OMR',
    PAB = 'PAB',
    PEN = 'PEN',
    PGK = 'PGK',
    PHP = 'PHP',
    PKR = 'PKR',
    PLN = 'PLN',
    PYG = 'PYG',
    QAR = 'QAR',
    RON = 'RON',
    RSD = 'RSD',
    RUB = 'RUB',
    RWF = 'RWF',
    SAR = 'SAR',
    SBD = 'SBD',
    SCR = 'SCR',
    SDG = 'SDG',
    SEK = 'SEK',
    SGD = 'SGD',
    SHP = 'SHP',
    SLL = 'SLL',
    SOS = 'SOS',
    SPL = 'SPL',
    SRD = 'SRD',
    STD = 'STD',
    SVC = 'SVC',
    SYP = 'SYP',
    SZL = 'SZL',
    THB = 'THB',
    TJS = 'TJS',
    TMT = 'TMT',
    TND = 'TND',
    TOP = 'TOP',
    TRY = 'TRY',
    TTD = 'TTD',
    TVD = 'TVD',
    TWD = 'TWD',
    TZS = 'TZS',
    UAH = 'UAH',
    UGX = 'UGX',
    USD = 'USD',
    UYU = 'UYU',
    UZS = 'UZS',
    VEF = 'VEF',
    VND = 'VND',
    VUV = 'VUV',
    WST = 'WST',
    XAF = 'XAF',
    XCD = 'XCD',
    XDR = 'XDR',
    XOF = 'XOF',
    XPF = 'XPF',
    YER = 'YER',
    ZAR = 'ZAR',
    ZMW = 'ZMW',
    ZWD = 'ZWD',
    BTC = 'BTC'
}
/**
    * @export
    * @enum {string}
    */
export enum SimplePlanBillingPeriodEnum {
    DAILY = 'DAILY',
    WEEKLY = 'WEEKLY',
    BIWEEKLY = 'BIWEEKLY',
    THIRTYDAYS = 'THIRTY_DAYS',
    SIXTYDAYS = 'SIXTY_DAYS',
    NINETYDAYS = 'NINETY_DAYS',
    MONTHLY = 'MONTHLY',
    BIMESTRIAL = 'BIMESTRIAL',
    QUARTERLY = 'QUARTERLY',
    TRIANNUAL = 'TRIANNUAL',
    BIANNUAL = 'BIANNUAL',
    ANNUAL = 'ANNUAL',
    BIENNIAL = 'BIENNIAL',
    NOBILLINGPERIOD = 'NO_BILLING_PERIOD'
}
/**
    * @export
    * @enum {string}
    */
export enum SimplePlanTrialTimeUnitEnum {
    DAYS = 'DAYS',
    WEEKS = 'WEEKS',
    MONTHS = 'MONTHS',
    YEARS = 'YEARS',
    UNLIMITED = 'UNLIMITED'
}

/**
 * 
 * @export
 * @interface Subject
 */
export interface Subject {
    /**
     * 
     * @type {string}
     * @memberof Subject
     */
    principal?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Subject
     */
    isAuthenticated?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Subject
     */
    isRemembered?: boolean;
    /**
     * 
     * @type {Session}
     * @memberof Subject
     */
    session?: Session;
}
/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    accountId?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    bundleId?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    bundleExternalKey?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    subscriptionId?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    externalKey?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    productName: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    productCategory?: SubscriptionProductCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    billingPeriod: SubscriptionBillingPeriodEnum;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    phaseType?: SubscriptionPhaseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    priceList: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    planName: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    state?: SubscriptionStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    sourceType?: SubscriptionSourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    cancelledDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    chargedThroughDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    billingStartDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    billingEndDate?: string;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    billCycleDayLocal?: number;
    /**
     * 
     * @type {Array<EventSubscription>}
     * @memberof Subscription
     */
    events?: Array<EventSubscription>;
    /**
     * 
     * @type {Array<PhasePrice>}
     * @memberof Subscription
     */
    priceOverrides?: Array<PhasePrice>;
    /**
     * 
     * @type {Array<PhasePrice>}
     * @memberof Subscription
     */
    prices?: Array<PhasePrice>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof Subscription
     */
    auditLogs?: Array<AuditLog>;
}

/**
    * @export
    * @enum {string}
    */
export enum SubscriptionProductCategoryEnum {
    BASE = 'BASE',
    ADDON = 'ADD_ON',
    STANDALONE = 'STANDALONE'
}
/**
    * @export
    * @enum {string}
    */
export enum SubscriptionBillingPeriodEnum {
    DAILY = 'DAILY',
    WEEKLY = 'WEEKLY',
    BIWEEKLY = 'BIWEEKLY',
    THIRTYDAYS = 'THIRTY_DAYS',
    SIXTYDAYS = 'SIXTY_DAYS',
    NINETYDAYS = 'NINETY_DAYS',
    MONTHLY = 'MONTHLY',
    BIMESTRIAL = 'BIMESTRIAL',
    QUARTERLY = 'QUARTERLY',
    TRIANNUAL = 'TRIANNUAL',
    BIANNUAL = 'BIANNUAL',
    ANNUAL = 'ANNUAL',
    BIENNIAL = 'BIENNIAL',
    NOBILLINGPERIOD = 'NO_BILLING_PERIOD'
}
/**
    * @export
    * @enum {string}
    */
export enum SubscriptionPhaseTypeEnum {
    TRIAL = 'TRIAL',
    DISCOUNT = 'DISCOUNT',
    FIXEDTERM = 'FIXEDTERM',
    EVERGREEN = 'EVERGREEN'
}
/**
    * @export
    * @enum {string}
    */
export enum SubscriptionStateEnum {
    PENDING = 'PENDING',
    ACTIVE = 'ACTIVE',
    BLOCKED = 'BLOCKED',
    CANCELLED = 'CANCELLED',
    EXPIRED = 'EXPIRED'
}
/**
    * @export
    * @enum {string}
    */
export enum SubscriptionSourceTypeEnum {
    NATIVE = 'NATIVE',
    MIGRATED = 'MIGRATED',
    TRANSFERRED = 'TRANSFERRED'
}

/**
 * 
 * @export
 * @interface SubscriptionUsageRecord
 */
export interface SubscriptionUsageRecord {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUsageRecord
     */
    subscriptionId: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUsageRecord
     */
    trackingId?: string;
    /**
     * 
     * @type {Array<UnitUsageRecord>}
     * @memberof SubscriptionUsageRecord
     */
    unitUsageRecords: Array<UnitUsageRecord>;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    tagId?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    objectType?: TagObjectTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    objectId?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    tagDefinitionId?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    tagDefinitionName?: string;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof Tag
     */
    auditLogs?: Array<AuditLog>;
}

/**
    * @export
    * @enum {string}
    */
export enum TagObjectTypeEnum {
    ACCOUNT = 'ACCOUNT',
    ACCOUNTEMAIL = 'ACCOUNT_EMAIL',
    BLOCKINGSTATES = 'BLOCKING_STATES',
    BUNDLE = 'BUNDLE',
    CUSTOMFIELD = 'CUSTOM_FIELD',
    INVOICE = 'INVOICE',
    PAYMENT = 'PAYMENT',
    TRANSACTION = 'TRANSACTION',
    INVOICEITEM = 'INVOICE_ITEM',
    INVOICEPAYMENT = 'INVOICE_PAYMENT',
    SUBSCRIPTION = 'SUBSCRIPTION',
    SUBSCRIPTIONEVENT = 'SUBSCRIPTION_EVENT',
    SERVICEBROADCAST = 'SERVICE_BROADCAST',
    PAYMENTATTEMPT = 'PAYMENT_ATTEMPT',
    PAYMENTMETHOD = 'PAYMENT_METHOD',
    TAG = 'TAG',
    TAGDEFINITION = 'TAG_DEFINITION',
    TENANT = 'TENANT',
    TENANTKVS = 'TENANT_KVS'
}

/**
 * 
 * @export
 * @interface TagDefinition
 */
export interface TagDefinition {
    /**
     * 
     * @type {string}
     * @memberof TagDefinition
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TagDefinition
     */
    isControlTag?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TagDefinition
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof TagDefinition
     */
    description: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TagDefinition
     */
    applicableObjectTypes?: Array<TagDefinitionApplicableObjectTypesEnum>;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof TagDefinition
     */
    auditLogs?: Array<AuditLog>;
}

/**
    * @export
    * @enum {string}
    */
export enum TagDefinitionApplicableObjectTypesEnum {
    ACCOUNT = 'ACCOUNT',
    ACCOUNTEMAIL = 'ACCOUNT_EMAIL',
    BLOCKINGSTATES = 'BLOCKING_STATES',
    BUNDLE = 'BUNDLE',
    CUSTOMFIELD = 'CUSTOM_FIELD',
    INVOICE = 'INVOICE',
    PAYMENT = 'PAYMENT',
    TRANSACTION = 'TRANSACTION',
    INVOICEITEM = 'INVOICE_ITEM',
    INVOICEPAYMENT = 'INVOICE_PAYMENT',
    SUBSCRIPTION = 'SUBSCRIPTION',
    SUBSCRIPTIONEVENT = 'SUBSCRIPTION_EVENT',
    SERVICEBROADCAST = 'SERVICE_BROADCAST',
    PAYMENTATTEMPT = 'PAYMENT_ATTEMPT',
    PAYMENTMETHOD = 'PAYMENT_METHOD',
    TAG = 'TAG',
    TAGDEFINITION = 'TAG_DEFINITION',
    TENANT = 'TENANT',
    TENANTKVS = 'TENANT_KVS'
}

/**
 * 
 * @export
 * @interface Tenant
 */
export interface Tenant {
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    tenantId?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    externalKey?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    apiKey: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    apiSecret: string;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof Tenant
     */
    auditLogs?: Array<AuditLog>;
}
/**
 * 
 * @export
 * @interface TenantKeyValue
 */
export interface TenantKeyValue {
    /**
     * 
     * @type {string}
     * @memberof TenantKeyValue
     */
    key?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TenantKeyValue
     */
    values?: Array<string>;
}
/**
 * 
 * @export
 * @interface Tier
 */
export interface Tier {
    /**
     * 
     * @type {Array<Limit>}
     * @memberof Tier
     */
    limits?: Array<Limit>;
    /**
     * 
     * @type {Array<Price>}
     * @memberof Tier
     */
    fixedPrice?: Array<Price>;
    /**
     * 
     * @type {Array<Price>}
     * @memberof Tier
     */
    recurringPrice?: Array<Price>;
    /**
     * 
     * @type {Array<TieredBlock>}
     * @memberof Tier
     */
    blocks?: Array<TieredBlock>;
}
/**
 * 
 * @export
 * @interface TierPrice
 */
export interface TierPrice {
    /**
     * 
     * @type {Array<BlockPrice>}
     * @memberof TierPrice
     */
    blockPrices?: Array<BlockPrice>;
}
/**
 * 
 * @export
 * @interface TieredBlock
 */
export interface TieredBlock {
    /**
     * 
     * @type {string}
     * @memberof TieredBlock
     */
    unit?: string;
    /**
     * 
     * @type {string}
     * @memberof TieredBlock
     */
    size?: string;
    /**
     * 
     * @type {string}
     * @memberof TieredBlock
     */
    max?: string;
    /**
     * 
     * @type {Array<Price>}
     * @memberof TieredBlock
     */
    prices?: Array<Price>;
}
/**
 * 
 * @export
 * @interface Unit
 */
export interface Unit {
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    prettyName?: string;
}
/**
 * 
 * @export
 * @interface UnitUsageRecord
 */
export interface UnitUsageRecord {
    /**
     * 
     * @type {string}
     * @memberof UnitUsageRecord
     */
    unitType?: string;
    /**
     * 
     * @type {Array<UsageRecord>}
     * @memberof UnitUsageRecord
     */
    usageRecords?: Array<UsageRecord>;
}
/**
 * 
 * @export
 * @interface Usage
 */
export interface Usage {
    /**
     * 
     * @type {string}
     * @memberof Usage
     */
    billingPeriod?: string;
    /**
     * 
     * @type {Array<Tier>}
     * @memberof Usage
     */
    tiers?: Array<Tier>;
}
/**
 * 
 * @export
 * @interface UsagePrice
 */
export interface UsagePrice {
    /**
     * 
     * @type {string}
     * @memberof UsagePrice
     */
    usageName?: string;
    /**
     * 
     * @type {string}
     * @memberof UsagePrice
     */
    usageType?: UsagePriceUsageTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UsagePrice
     */
    billingMode?: UsagePriceBillingModeEnum;
    /**
     * 
     * @type {string}
     * @memberof UsagePrice
     */
    tierBlockPolicy?: UsagePriceTierBlockPolicyEnum;
    /**
     * 
     * @type {Array<TierPrice>}
     * @memberof UsagePrice
     */
    tierPrices?: Array<TierPrice>;
}

/**
    * @export
    * @enum {string}
    */
export enum UsagePriceUsageTypeEnum {
    CAPACITY = 'CAPACITY',
    CONSUMABLE = 'CONSUMABLE'
}
/**
    * @export
    * @enum {string}
    */
export enum UsagePriceBillingModeEnum {
    ADVANCE = 'IN_ADVANCE',
    ARREAR = 'IN_ARREAR'
}
/**
    * @export
    * @enum {string}
    */
export enum UsagePriceTierBlockPolicyEnum {
    ALLTIERS = 'ALL_TIERS',
    TOPTIER = 'TOP_TIER'
}

/**
 * 
 * @export
 * @interface UsageRecord
 */
export interface UsageRecord {
    /**
     * 
     * @type {string}
     * @memberof UsageRecord
     */
    recordDate?: string;
    /**
     * 
     * @type {number}
     * @memberof UsageRecord
     */
    amount?: number;
}
/**
 * 
 * @export
 * @interface UserRoles
 */
export interface UserRoles {
    /**
     * 
     * @type {string}
     * @memberof UserRoles
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof UserRoles
     */
    password: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserRoles
     */
    roles: Array<string>;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Block an account
         * @param {BlockingState} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountBlockingState: async (body: BlockingState, accountId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addAccountBlockingState.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling addAccountBlockingState.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling addAccountBlockingState.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/block`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add account email
         * @param {AccountEmail} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEmail: async (body: AccountEmail, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addEmail.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling addEmail.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling addEmail.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/emails`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Close account
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [cancelAllSubscriptions] 
         * @param {boolean} [writeOffUnpaidInvoices] 
         * @param {boolean} [itemAdjustUnpaidInvoices] 
         * @param {boolean} [removeFutureNotifications] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeAccount: async (accountId: string, xKillbillCreatedBy: string, cancelAllSubscriptions?: boolean, writeOffUnpaidInvoices?: boolean, itemAdjustUnpaidInvoices?: boolean, removeFutureNotifications?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling closeAccount.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling closeAccount.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (cancelAllSubscriptions !== undefined) {
                localVarQueryParameter['cancelAllSubscriptions'] = cancelAllSubscriptions;
            }

            if (writeOffUnpaidInvoices !== undefined) {
                localVarQueryParameter['writeOffUnpaidInvoices'] = writeOffUnpaidInvoices;
            }

            if (itemAdjustUnpaidInvoices !== undefined) {
                localVarQueryParameter['itemAdjustUnpaidInvoices'] = itemAdjustUnpaidInvoices;
            }

            if (removeFutureNotifications !== undefined) {
                localVarQueryParameter['removeFutureNotifications'] = removeFutureNotifications;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create account
         * @param {Account} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (body: Account, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createAccount.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createAccount.');
            }
            const localVarPath = `/1.0/kb/accounts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add custom fields to account
         * @param {Array<CustomField>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountCustomFields: async (body: Array<CustomField>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createAccountCustomFields.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling createAccountCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createAccountCustomFields.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/customFields`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add tags to account
         * @param {Array<string>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountTags: async (body: Array<string>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createAccountTags.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling createAccountTags.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createAccountTags.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/tags`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a payment method
         * @param {PaymentMethod} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [isDefault] 
         * @param {boolean} [payAllUnpaidInvoices] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethod: async (body: PaymentMethod, accountId: string, xKillbillCreatedBy: string, isDefault?: boolean, payAllUnpaidInvoices?: boolean, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPaymentMethod.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling createPaymentMethod.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createPaymentMethod.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/paymentMethods`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (isDefault !== undefined) {
                localVarQueryParameter['isDefault'] = isDefault;
            }

            if (payAllUnpaidInvoices !== undefined) {
                localVarQueryParameter['payAllUnpaidInvoices'] = payAllUnpaidInvoices;
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove custom fields from account
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountCustomFields: async (accountId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling deleteAccountCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deleteAccountCustomFields.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/customFields`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove tags from account
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountTags: async (accountId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling deleteAccountTags.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deleteAccountTags.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/tags`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an account by id
         * @param {string} accountId 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (accountId: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAccount.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (accountWithBalance !== undefined) {
                localVarQueryParameter['accountWithBalance'] = accountWithBalance;
            }

            if (accountWithBalanceAndCBA !== undefined) {
                localVarQueryParameter['accountWithBalanceAndCBA'] = accountWithBalanceAndCBA;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve audit logs by account id
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAuditLogs: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAccountAuditLogs.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/auditLogs`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account audit logs with history by account id
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAuditLogsWithHistory: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAccountAuditLogsWithHistory.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/auditLogsWithHistory`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve bundles for account
         * @param {string} accountId 
         * @param {string} [externalKey] 
         * @param {string} [bundlesFilter] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBundles: async (accountId: string, externalKey?: string, bundlesFilter?: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAccountBundles.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/bundles`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }

            if (bundlesFilter !== undefined) {
                localVarQueryParameter['bundlesFilter'] = bundlesFilter;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an account by external key
         * @param {string} externalKey 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByKey: async (externalKey: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalKey' is not null or undefined
            if (externalKey === null || externalKey === undefined) {
                throw new RequiredError('externalKey','Required parameter externalKey was null or undefined when calling getAccountByKey.');
            }
            const localVarPath = `/1.0/kb/accounts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }

            if (accountWithBalance !== undefined) {
                localVarQueryParameter['accountWithBalance'] = accountWithBalance;
            }

            if (accountWithBalanceAndCBA !== undefined) {
                localVarQueryParameter['accountWithBalanceAndCBA'] = accountWithBalanceAndCBA;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account custom fields
         * @param {string} accountId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountCustomFields: async (accountId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAccountCustomFields.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/customFields`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account email audit logs with history by id
         * @param {string} accountId 
         * @param {string} accountEmailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEmailAuditLogsWithHistory: async (accountId: string, accountEmailId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAccountEmailAuditLogsWithHistory.');
            }
            // verify required parameter 'accountEmailId' is not null or undefined
            if (accountEmailId === null || accountEmailId === undefined) {
                throw new RequiredError('accountEmailId','Required parameter accountEmailId was null or undefined when calling getAccountEmailAuditLogsWithHistory.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/emails/{accountEmailId}/auditLogsWithHistory`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"accountEmailId"}}`, encodeURIComponent(String(accountEmailId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account tags
         * @param {string} accountId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTags: async (accountId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAccountTags.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/tags`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account timeline
         * @param {string} accountId 
         * @param {boolean} [parallel] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTimeline: async (accountId: string, parallel?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAccountTimeline.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/timeline`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (parallel !== undefined) {
                localVarQueryParameter['parallel'] = parallel;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List accounts
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (offset?: number, limit?: number, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/accounts/pagination`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (accountWithBalance !== undefined) {
                localVarQueryParameter['accountWithBalance'] = accountWithBalance;
            }

            if (accountWithBalanceAndCBA !== undefined) {
                localVarQueryParameter['accountWithBalanceAndCBA'] = accountWithBalanceAndCBA;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account customFields
         * @param {string} accountId 
         * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCustomFields: async (accountId: string, objectType?: 'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS', audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAllCustomFields.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/allCustomFields`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (objectType !== undefined) {
                localVarQueryParameter['objectType'] = objectType;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account tags
         * @param {string} accountId 
         * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType] 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags: async (accountId: string, objectType?: 'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS', includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getAllTags.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/allTags`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (objectType !== undefined) {
                localVarQueryParameter['objectType'] = objectType;
            }

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve blocking state audit logs with history by id
         * @param {string} blockingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockingStateAuditLogsWithHistory: async (blockingId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockingId' is not null or undefined
            if (blockingId === null || blockingId === undefined) {
                throw new RequiredError('blockingId','Required parameter blockingId was null or undefined when calling getBlockingStateAuditLogsWithHistory.');
            }
            const localVarPath = `/1.0/kb/accounts/block/{blockingId}/auditLogsWithHistory`
                .replace(`{${"blockingId"}}`, encodeURIComponent(String(blockingId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve blocking states for account
         * @param {string} accountId 
         * @param {Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>} [blockingStateTypes] 
         * @param {Array<string>} [blockingStateSvcs] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockingStates: async (accountId: string, blockingStateTypes?: Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>, blockingStateSvcs?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getBlockingStates.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/block`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (blockingStateTypes) {
                localVarQueryParameter['blockingStateTypes'] = blockingStateTypes;
            }

            if (blockingStateSvcs) {
                localVarQueryParameter['blockingStateSvcs'] = blockingStateSvcs;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List children accounts
         * @param {string} accountId 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChildrenAccounts: async (accountId: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getChildrenAccounts.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/children`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (accountWithBalance !== undefined) {
                localVarQueryParameter['accountWithBalance'] = accountWithBalance;
            }

            if (accountWithBalanceAndCBA !== undefined) {
                localVarQueryParameter['accountWithBalanceAndCBA'] = accountWithBalanceAndCBA;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an account emails
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getEmails.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/emails`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account invoice payments
         * @param {string} accountId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePayments: async (accountId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getInvoicePayments.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/invoicePayments`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account invoices
         * @param {string} accountId 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [withMigrationInvoices] 
         * @param {boolean} [unpaidInvoicesOnly] 
         * @param {boolean} [includeVoidedInvoices] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesForAccount: async (accountId: string, startDate?: string, endDate?: string, withMigrationInvoices?: boolean, unpaidInvoicesOnly?: boolean, includeVoidedInvoices?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getInvoicesForAccount.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/invoices`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substr(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substr(0,10) :
                    endDate;
            }

            if (withMigrationInvoices !== undefined) {
                localVarQueryParameter['withMigrationInvoices'] = withMigrationInvoices;
            }

            if (unpaidInvoicesOnly !== undefined) {
                localVarQueryParameter['unpaidInvoicesOnly'] = unpaidInvoicesOnly;
            }

            if (includeVoidedInvoices !== undefined) {
                localVarQueryParameter['includeVoidedInvoices'] = includeVoidedInvoices;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve overdue state for account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueAccount: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getOverdueAccount.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/overdue`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account payment methods
         * @param {string} accountId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [includedDeleted] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodsForAccount: async (accountId: string, withPluginInfo?: boolean, includedDeleted?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getPaymentMethodsForAccount.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/paymentMethods`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve account payments
         * @param {string} accountId 
         * @param {boolean} [withAttempts] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForAccount: async (accountId: string, withAttempts?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getPaymentsForAccount.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/payments`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify custom fields to account
         * @param {Array<CustomField>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyAccountCustomFields: async (body: Array<CustomField>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling modifyAccountCustomFields.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling modifyAccountCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling modifyAccountCustomFields.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/customFields`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger a payment for all unpaid invoices
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {boolean} [externalPayment] 
         * @param {number} [paymentAmount] 
         * @param {string} [targetDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payAllInvoices: async (accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, externalPayment?: boolean, paymentAmount?: number, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling payAllInvoices.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling payAllInvoices.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/invoicePayments`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (paymentMethodId !== undefined) {
                localVarQueryParameter['paymentMethodId'] = paymentMethodId;
            }

            if (externalPayment !== undefined) {
                localVarQueryParameter['externalPayment'] = externalPayment;
            }

            if (paymentAmount !== undefined) {
                localVarQueryParameter['paymentAmount'] = paymentAmount;
            }

            if (targetDate !== undefined) {
                localVarQueryParameter['targetDate'] = (targetDate as any instanceof Date) ?
                    (targetDate as any).toISOString().substr(0,10) :
                    targetDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger a payment (authorization, purchase or credit)
         * @param {PaymentTransaction} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPayment: async (body: PaymentTransaction, accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processPayment.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling processPayment.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling processPayment.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/payments`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (paymentMethodId !== undefined) {
                localVarQueryParameter['paymentMethodId'] = paymentMethodId;
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger a payment using the account external key (authorization, purchase or credit)
         * @param {PaymentTransaction} body 
         * @param {string} externalKey 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPaymentByExternalKey: async (body: PaymentTransaction, externalKey: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processPaymentByExternalKey.');
            }
            // verify required parameter 'externalKey' is not null or undefined
            if (externalKey === null || externalKey === undefined) {
                throw new RequiredError('externalKey','Required parameter externalKey was null or undefined when calling processPaymentByExternalKey.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling processPaymentByExternalKey.');
            }
            const localVarPath = `/1.0/kb/accounts/payments`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }

            if (paymentMethodId !== undefined) {
                localVarQueryParameter['paymentMethodId'] = paymentMethodId;
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rebalance account CBA
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebalanceExistingCBAOnAccount: async (accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling rebalanceExistingCBAOnAccount.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling rebalanceExistingCBAOnAccount.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/cbaRebalancing`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh account payment methods
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [pluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshPaymentMethods: async (accountId: string, xKillbillCreatedBy: string, pluginName?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling refreshPaymentMethods.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling refreshPaymentMethods.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/paymentMethods/refresh`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (pluginName !== undefined) {
                localVarQueryParameter['pluginName'] = pluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete email from account
         * @param {string} accountId 
         * @param {string} email 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEmail: async (accountId: string, email: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling removeEmail.');
            }
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling removeEmail.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling removeEmail.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/emails/{email}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search accounts
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts: async (searchKey: string, offset?: number, limit?: number, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            if (searchKey === null || searchKey === undefined) {
                throw new RequiredError('searchKey','Required parameter searchKey was null or undefined when calling searchAccounts.');
            }
            const localVarPath = `/1.0/kb/accounts/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (accountWithBalance !== undefined) {
                localVarQueryParameter['accountWithBalance'] = accountWithBalance;
            }

            if (accountWithBalanceAndCBA !== undefined) {
                localVarQueryParameter['accountWithBalanceAndCBA'] = accountWithBalanceAndCBA;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the default payment method
         * @param {string} accountId 
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [payAllUnpaidInvoices] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod: async (accountId: string, paymentMethodId: string, xKillbillCreatedBy: string, payAllUnpaidInvoices?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling setDefaultPaymentMethod.');
            }
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId','Required parameter paymentMethodId was null or undefined when calling setDefaultPaymentMethod.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling setDefaultPaymentMethod.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}/paymentMethods/{paymentMethodId}/setDefault`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (payAllUnpaidInvoices !== undefined) {
                localVarQueryParameter['payAllUnpaidInvoices'] = payAllUnpaidInvoices;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move a given child credit to the parent level
         * @param {string} childAccountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferChildCreditToParent: async (childAccountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'childAccountId' is not null or undefined
            if (childAccountId === null || childAccountId === undefined) {
                throw new RequiredError('childAccountId','Required parameter childAccountId was null or undefined when calling transferChildCreditToParent.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling transferChildCreditToParent.');
            }
            const localVarPath = `/1.0/kb/accounts/{childAccountId}/transferCredit`
                .replace(`{${"childAccountId"}}`, encodeURIComponent(String(childAccountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update account
         * @param {Account} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [treatNullAsReset] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (body: Account, accountId: string, xKillbillCreatedBy: string, treatNullAsReset?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateAccount.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling updateAccount.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling updateAccount.');
            }
            const localVarPath = `/1.0/kb/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (treatNullAsReset !== undefined) {
                localVarQueryParameter['treatNullAsReset'] = treatNullAsReset;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Block an account
         * @param {BlockingState} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAccountBlockingState(body: BlockingState, accountId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlockingState>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).addAccountBlockingState(body, accountId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add account email
         * @param {AccountEmail} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEmail(body: AccountEmail, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountEmail>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).addEmail(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Close account
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [cancelAllSubscriptions] 
         * @param {boolean} [writeOffUnpaidInvoices] 
         * @param {boolean} [itemAdjustUnpaidInvoices] 
         * @param {boolean} [removeFutureNotifications] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeAccount(accountId: string, xKillbillCreatedBy: string, cancelAllSubscriptions?: boolean, writeOffUnpaidInvoices?: boolean, itemAdjustUnpaidInvoices?: boolean, removeFutureNotifications?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).closeAccount(accountId, xKillbillCreatedBy, cancelAllSubscriptions, writeOffUnpaidInvoices, itemAdjustUnpaidInvoices, removeFutureNotifications, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create account
         * @param {Account} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(body: Account, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).createAccount(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add custom fields to account
         * @param {Array<CustomField>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccountCustomFields(body: Array<CustomField>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).createAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add tags to account
         * @param {Array<string>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccountTags(body: Array<string>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).createAccountTags(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add a payment method
         * @param {PaymentMethod} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [isDefault] 
         * @param {boolean} [payAllUnpaidInvoices] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentMethod(body: PaymentMethod, accountId: string, xKillbillCreatedBy: string, isDefault?: boolean, payAllUnpaidInvoices?: boolean, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethod>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).createPaymentMethod(body, accountId, xKillbillCreatedBy, isDefault, payAllUnpaidInvoices, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove custom fields from account
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccountCustomFields(accountId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).deleteAccountCustomFields(accountId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove tags from account
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccountTags(accountId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).deleteAccountTags(accountId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve an account by id
         * @param {string} accountId 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(accountId: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getAccount(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve audit logs by account id
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountAuditLogs(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getAccountAuditLogs(accountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve account audit logs with history by account id
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountAuditLogsWithHistory(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getAccountAuditLogsWithHistory(accountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve bundles for account
         * @param {string} accountId 
         * @param {string} [externalKey] 
         * @param {string} [bundlesFilter] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountBundles(accountId: string, externalKey?: string, bundlesFilter?: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bundle>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getAccountBundles(accountId, externalKey, bundlesFilter, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve an account by external key
         * @param {string} externalKey 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountByKey(externalKey: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getAccountByKey(externalKey, accountWithBalance, accountWithBalanceAndCBA, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve account custom fields
         * @param {string} accountId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountCustomFields(accountId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getAccountCustomFields(accountId, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve account email audit logs with history by id
         * @param {string} accountId 
         * @param {string} accountEmailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountEmailAuditLogsWithHistory(accountId: string, accountEmailId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getAccountEmailAuditLogsWithHistory(accountId, accountEmailId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve account tags
         * @param {string} accountId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountTags(accountId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getAccountTags(accountId, includedDeleted, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve account timeline
         * @param {string} accountId 
         * @param {boolean} [parallel] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountTimeline(accountId: string, parallel?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountTimeline>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getAccountTimeline(accountId, parallel, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List accounts
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(offset?: number, limit?: number, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getAccounts(offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve account customFields
         * @param {string} accountId 
         * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCustomFields(accountId: string, objectType?: 'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS', audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getAllCustomFields(accountId, objectType, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve account tags
         * @param {string} accountId 
         * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType] 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTags(accountId: string, objectType?: 'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS', includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getAllTags(accountId, objectType, includedDeleted, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve blocking state audit logs with history by id
         * @param {string} blockingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockingStateAuditLogsWithHistory(blockingId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getBlockingStateAuditLogsWithHistory(blockingId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve blocking states for account
         * @param {string} accountId 
         * @param {Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>} [blockingStateTypes] 
         * @param {Array<string>} [blockingStateSvcs] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockingStates(accountId: string, blockingStateTypes?: Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>, blockingStateSvcs?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlockingState>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getBlockingStates(accountId, blockingStateTypes, blockingStateSvcs, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List children accounts
         * @param {string} accountId 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChildrenAccounts(accountId: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getChildrenAccounts(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve an account emails
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmails(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountEmail>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getEmails(accountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve account invoice payments
         * @param {string} accountId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoicePayments(accountId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvoicePayment>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getInvoicePayments(accountId, withPluginInfo, withAttempts, pluginProperty, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve account invoices
         * @param {string} accountId 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [withMigrationInvoices] 
         * @param {boolean} [unpaidInvoicesOnly] 
         * @param {boolean} [includeVoidedInvoices] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoicesForAccount(accountId: string, startDate?: string, endDate?: string, withMigrationInvoices?: boolean, unpaidInvoicesOnly?: boolean, includeVoidedInvoices?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getInvoicesForAccount(accountId, startDate, endDate, withMigrationInvoices, unpaidInvoicesOnly, includeVoidedInvoices, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve overdue state for account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOverdueAccount(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OverdueState>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getOverdueAccount(accountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve account payment methods
         * @param {string} accountId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [includedDeleted] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodsForAccount(accountId: string, withPluginInfo?: boolean, includedDeleted?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentMethod>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getPaymentMethodsForAccount(accountId, withPluginInfo, includedDeleted, pluginProperty, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve account payments
         * @param {string} accountId 
         * @param {boolean} [withAttempts] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentsForAccount(accountId: string, withAttempts?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payment>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).getPaymentsForAccount(accountId, withAttempts, withPluginInfo, pluginProperty, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify custom fields to account
         * @param {Array<CustomField>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyAccountCustomFields(body: Array<CustomField>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).modifyAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Trigger a payment for all unpaid invoices
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {boolean} [externalPayment] 
         * @param {number} [paymentAmount] 
         * @param {string} [targetDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payAllInvoices(accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, externalPayment?: boolean, paymentAmount?: number, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).payAllInvoices(accountId, xKillbillCreatedBy, paymentMethodId, externalPayment, paymentAmount, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Trigger a payment (authorization, purchase or credit)
         * @param {PaymentTransaction} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processPayment(body: PaymentTransaction, accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).processPayment(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Trigger a payment using the account external key (authorization, purchase or credit)
         * @param {PaymentTransaction} body 
         * @param {string} externalKey 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processPaymentByExternalKey(body: PaymentTransaction, externalKey: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).processPaymentByExternalKey(body, externalKey, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Rebalance account CBA
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebalanceExistingCBAOnAccount(accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).rebalanceExistingCBAOnAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Refresh account payment methods
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [pluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshPaymentMethods(accountId: string, xKillbillCreatedBy: string, pluginName?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).refreshPaymentMethods(accountId, xKillbillCreatedBy, pluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete email from account
         * @param {string} accountId 
         * @param {string} email 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeEmail(accountId: string, email: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).removeEmail(accountId, email, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Search accounts
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAccounts(searchKey: string, offset?: number, limit?: number, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).searchAccounts(searchKey, offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Set the default payment method
         * @param {string} accountId 
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [payAllUnpaidInvoices] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDefaultPaymentMethod(accountId: string, paymentMethodId: string, xKillbillCreatedBy: string, payAllUnpaidInvoices?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).setDefaultPaymentMethod(accountId, paymentMethodId, xKillbillCreatedBy, payAllUnpaidInvoices, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Move a given child credit to the parent level
         * @param {string} childAccountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transferChildCreditToParent(childAccountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).transferChildCreditToParent(childAccountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update account
         * @param {Account} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [treatNullAsReset] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(body: Account, accountId: string, xKillbillCreatedBy: string, treatNullAsReset?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).updateAccount(body, accountId, xKillbillCreatedBy, treatNullAsReset, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Block an account
         * @param {BlockingState} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountBlockingState(body: BlockingState, accountId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<BlockingState>> {
            return AccountApiFp(configuration).addAccountBlockingState(body, accountId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add account email
         * @param {AccountEmail} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEmail(body: AccountEmail, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<AccountEmail>> {
            return AccountApiFp(configuration).addEmail(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Close account
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [cancelAllSubscriptions] 
         * @param {boolean} [writeOffUnpaidInvoices] 
         * @param {boolean} [itemAdjustUnpaidInvoices] 
         * @param {boolean} [removeFutureNotifications] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeAccount(accountId: string, xKillbillCreatedBy: string, cancelAllSubscriptions?: boolean, writeOffUnpaidInvoices?: boolean, itemAdjustUnpaidInvoices?: boolean, removeFutureNotifications?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return AccountApiFp(configuration).closeAccount(accountId, xKillbillCreatedBy, cancelAllSubscriptions, writeOffUnpaidInvoices, itemAdjustUnpaidInvoices, removeFutureNotifications, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create account
         * @param {Account} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(body: Account, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Account> {
            return AccountApiFp(configuration).createAccount(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add custom fields to account
         * @param {Array<CustomField>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountCustomFields(body: Array<CustomField>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<CustomField>> {
            return AccountApiFp(configuration).createAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add tags to account
         * @param {Array<string>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountTags(body: Array<string>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<Tag>> {
            return AccountApiFp(configuration).createAccountTags(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a payment method
         * @param {PaymentMethod} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [isDefault] 
         * @param {boolean} [payAllUnpaidInvoices] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethod(body: PaymentMethod, accountId: string, xKillbillCreatedBy: string, isDefault?: boolean, payAllUnpaidInvoices?: boolean, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<PaymentMethod> {
            return AccountApiFp(configuration).createPaymentMethod(body, accountId, xKillbillCreatedBy, isDefault, payAllUnpaidInvoices, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove custom fields from account
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountCustomFields(accountId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return AccountApiFp(configuration).deleteAccountCustomFields(accountId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove tags from account
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountTags(accountId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return AccountApiFp(configuration).deleteAccountTags(accountId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an account by id
         * @param {string} accountId 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Account> {
            return AccountApiFp(configuration).getAccount(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve audit logs by account id
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAuditLogs(accountId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return AccountApiFp(configuration).getAccountAuditLogs(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account audit logs with history by account id
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAuditLogsWithHistory(accountId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return AccountApiFp(configuration).getAccountAuditLogsWithHistory(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve bundles for account
         * @param {string} accountId 
         * @param {string} [externalKey] 
         * @param {string} [bundlesFilter] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBundles(accountId: string, externalKey?: string, bundlesFilter?: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Bundle>> {
            return AccountApiFp(configuration).getAccountBundles(accountId, externalKey, bundlesFilter, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an account by external key
         * @param {string} externalKey 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByKey(externalKey: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Account> {
            return AccountApiFp(configuration).getAccountByKey(externalKey, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account custom fields
         * @param {string} accountId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountCustomFields(accountId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return AccountApiFp(configuration).getAccountCustomFields(accountId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account email audit logs with history by id
         * @param {string} accountId 
         * @param {string} accountEmailId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEmailAuditLogsWithHistory(accountId: string, accountEmailId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return AccountApiFp(configuration).getAccountEmailAuditLogsWithHistory(accountId, accountEmailId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account tags
         * @param {string} accountId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTags(accountId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return AccountApiFp(configuration).getAccountTags(accountId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account timeline
         * @param {string} accountId 
         * @param {boolean} [parallel] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTimeline(accountId: string, parallel?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<AccountTimeline> {
            return AccountApiFp(configuration).getAccountTimeline(accountId, parallel, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List accounts
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(offset?: number, limit?: number, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Account>> {
            return AccountApiFp(configuration).getAccounts(offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account customFields
         * @param {string} accountId 
         * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCustomFields(accountId: string, objectType?: 'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS', audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return AccountApiFp(configuration).getAllCustomFields(accountId, objectType, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account tags
         * @param {string} accountId 
         * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType] 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags(accountId: string, objectType?: 'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS', includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return AccountApiFp(configuration).getAllTags(accountId, objectType, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve blocking state audit logs with history by id
         * @param {string} blockingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockingStateAuditLogsWithHistory(blockingId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return AccountApiFp(configuration).getBlockingStateAuditLogsWithHistory(blockingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve blocking states for account
         * @param {string} accountId 
         * @param {Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>} [blockingStateTypes] 
         * @param {Array<string>} [blockingStateSvcs] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockingStates(accountId: string, blockingStateTypes?: Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>, blockingStateSvcs?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<BlockingState>> {
            return AccountApiFp(configuration).getBlockingStates(accountId, blockingStateTypes, blockingStateSvcs, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List children accounts
         * @param {string} accountId 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChildrenAccounts(accountId: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Account>> {
            return AccountApiFp(configuration).getChildrenAccounts(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an account emails
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails(accountId: string, options?: any): AxiosPromise<Array<AccountEmail>> {
            return AccountApiFp(configuration).getEmails(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account invoice payments
         * @param {string} accountId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePayments(accountId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<InvoicePayment>> {
            return AccountApiFp(configuration).getInvoicePayments(accountId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account invoices
         * @param {string} accountId 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [withMigrationInvoices] 
         * @param {boolean} [unpaidInvoicesOnly] 
         * @param {boolean} [includeVoidedInvoices] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesForAccount(accountId: string, startDate?: string, endDate?: string, withMigrationInvoices?: boolean, unpaidInvoicesOnly?: boolean, includeVoidedInvoices?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Invoice>> {
            return AccountApiFp(configuration).getInvoicesForAccount(accountId, startDate, endDate, withMigrationInvoices, unpaidInvoicesOnly, includeVoidedInvoices, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve overdue state for account
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueAccount(accountId: string, options?: any): AxiosPromise<OverdueState> {
            return AccountApiFp(configuration).getOverdueAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account payment methods
         * @param {string} accountId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [includedDeleted] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodsForAccount(accountId: string, withPluginInfo?: boolean, includedDeleted?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<PaymentMethod>> {
            return AccountApiFp(configuration).getPaymentMethodsForAccount(accountId, withPluginInfo, includedDeleted, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve account payments
         * @param {string} accountId 
         * @param {boolean} [withAttempts] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForAccount(accountId: string, withAttempts?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Payment>> {
            return AccountApiFp(configuration).getPaymentsForAccount(accountId, withAttempts, withPluginInfo, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify custom fields to account
         * @param {Array<CustomField>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyAccountCustomFields(body: Array<CustomField>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return AccountApiFp(configuration).modifyAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger a payment for all unpaid invoices
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {boolean} [externalPayment] 
         * @param {number} [paymentAmount] 
         * @param {string} [targetDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payAllInvoices(accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, externalPayment?: boolean, paymentAmount?: number, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return AccountApiFp(configuration).payAllInvoices(accountId, xKillbillCreatedBy, paymentMethodId, externalPayment, paymentAmount, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger a payment (authorization, purchase or credit)
         * @param {PaymentTransaction} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPayment(body: PaymentTransaction, accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return AccountApiFp(configuration).processPayment(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger a payment using the account external key (authorization, purchase or credit)
         * @param {PaymentTransaction} body 
         * @param {string} externalKey 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPaymentByExternalKey(body: PaymentTransaction, externalKey: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return AccountApiFp(configuration).processPaymentByExternalKey(body, externalKey, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rebalance account CBA
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebalanceExistingCBAOnAccount(accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return AccountApiFp(configuration).rebalanceExistingCBAOnAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh account payment methods
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [pluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshPaymentMethods(accountId: string, xKillbillCreatedBy: string, pluginName?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return AccountApiFp(configuration).refreshPaymentMethods(accountId, xKillbillCreatedBy, pluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete email from account
         * @param {string} accountId 
         * @param {string} email 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEmail(accountId: string, email: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return AccountApiFp(configuration).removeEmail(accountId, email, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search accounts
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [accountWithBalance] 
         * @param {boolean} [accountWithBalanceAndCBA] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts(searchKey: string, offset?: number, limit?: number, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Account>> {
            return AccountApiFp(configuration).searchAccounts(searchKey, offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the default payment method
         * @param {string} accountId 
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [payAllUnpaidInvoices] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod(accountId: string, paymentMethodId: string, xKillbillCreatedBy: string, payAllUnpaidInvoices?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return AccountApiFp(configuration).setDefaultPaymentMethod(accountId, paymentMethodId, xKillbillCreatedBy, payAllUnpaidInvoices, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move a given child credit to the parent level
         * @param {string} childAccountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferChildCreditToParent(childAccountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return AccountApiFp(configuration).transferChildCreditToParent(childAccountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update account
         * @param {Account} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [treatNullAsReset] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(body: Account, accountId: string, xKillbillCreatedBy: string, treatNullAsReset?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return AccountApiFp(configuration).updateAccount(body, accountId, xKillbillCreatedBy, treatNullAsReset, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Block an account
     * @param {BlockingState} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public addAccountBlockingState(body: BlockingState, accountId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).addAccountBlockingState(body, accountId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add account email
     * @param {AccountEmail} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public addEmail(body: AccountEmail, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).addEmail(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Close account
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [cancelAllSubscriptions] 
     * @param {boolean} [writeOffUnpaidInvoices] 
     * @param {boolean} [itemAdjustUnpaidInvoices] 
     * @param {boolean} [removeFutureNotifications] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public closeAccount(accountId: string, xKillbillCreatedBy: string, cancelAllSubscriptions?: boolean, writeOffUnpaidInvoices?: boolean, itemAdjustUnpaidInvoices?: boolean, removeFutureNotifications?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).closeAccount(accountId, xKillbillCreatedBy, cancelAllSubscriptions, writeOffUnpaidInvoices, itemAdjustUnpaidInvoices, removeFutureNotifications, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create account
     * @param {Account} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public createAccount(body: Account, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).createAccount(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add custom fields to account
     * @param {Array<CustomField>} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public createAccountCustomFields(body: Array<CustomField>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).createAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add tags to account
     * @param {Array<string>} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public createAccountTags(body: Array<string>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).createAccountTags(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a payment method
     * @param {PaymentMethod} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [isDefault] 
     * @param {boolean} [payAllUnpaidInvoices] 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public createPaymentMethod(body: PaymentMethod, accountId: string, xKillbillCreatedBy: string, isDefault?: boolean, payAllUnpaidInvoices?: boolean, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).createPaymentMethod(body, accountId, xKillbillCreatedBy, isDefault, payAllUnpaidInvoices, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove custom fields from account
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [customField] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public deleteAccountCustomFields(accountId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).deleteAccountCustomFields(accountId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove tags from account
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [tagDef] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public deleteAccountTags(accountId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).deleteAccountTags(accountId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an account by id
     * @param {string} accountId 
     * @param {boolean} [accountWithBalance] 
     * @param {boolean} [accountWithBalanceAndCBA] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccount(accountId: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return AccountApiFp(this.configuration).getAccount(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve audit logs by account id
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountAuditLogs(accountId: string, options?: any) {
        return AccountApiFp(this.configuration).getAccountAuditLogs(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account audit logs with history by account id
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountAuditLogsWithHistory(accountId: string, options?: any) {
        return AccountApiFp(this.configuration).getAccountAuditLogsWithHistory(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve bundles for account
     * @param {string} accountId 
     * @param {string} [externalKey] 
     * @param {string} [bundlesFilter] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountBundles(accountId: string, externalKey?: string, bundlesFilter?: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return AccountApiFp(this.configuration).getAccountBundles(accountId, externalKey, bundlesFilter, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an account by external key
     * @param {string} externalKey 
     * @param {boolean} [accountWithBalance] 
     * @param {boolean} [accountWithBalanceAndCBA] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountByKey(externalKey: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return AccountApiFp(this.configuration).getAccountByKey(externalKey, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account custom fields
     * @param {string} accountId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountCustomFields(accountId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return AccountApiFp(this.configuration).getAccountCustomFields(accountId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account email audit logs with history by id
     * @param {string} accountId 
     * @param {string} accountEmailId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountEmailAuditLogsWithHistory(accountId: string, accountEmailId: string, options?: any) {
        return AccountApiFp(this.configuration).getAccountEmailAuditLogsWithHistory(accountId, accountEmailId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account tags
     * @param {string} accountId 
     * @param {boolean} [includedDeleted] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountTags(accountId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return AccountApiFp(this.configuration).getAccountTags(accountId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account timeline
     * @param {string} accountId 
     * @param {boolean} [parallel] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountTimeline(accountId: string, parallel?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return AccountApiFp(this.configuration).getAccountTimeline(accountId, parallel, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List accounts
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {boolean} [accountWithBalance] 
     * @param {boolean} [accountWithBalanceAndCBA] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccounts(offset?: number, limit?: number, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return AccountApiFp(this.configuration).getAccounts(offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account customFields
     * @param {string} accountId 
     * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAllCustomFields(accountId: string, objectType?: 'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS', audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return AccountApiFp(this.configuration).getAllCustomFields(accountId, objectType, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account tags
     * @param {string} accountId 
     * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType] 
     * @param {boolean} [includedDeleted] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAllTags(accountId: string, objectType?: 'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS', includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return AccountApiFp(this.configuration).getAllTags(accountId, objectType, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve blocking state audit logs with history by id
     * @param {string} blockingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getBlockingStateAuditLogsWithHistory(blockingId: string, options?: any) {
        return AccountApiFp(this.configuration).getBlockingStateAuditLogsWithHistory(blockingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve blocking states for account
     * @param {string} accountId 
     * @param {Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>} [blockingStateTypes] 
     * @param {Array<string>} [blockingStateSvcs] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getBlockingStates(accountId: string, blockingStateTypes?: Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>, blockingStateSvcs?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return AccountApiFp(this.configuration).getBlockingStates(accountId, blockingStateTypes, blockingStateSvcs, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List children accounts
     * @param {string} accountId 
     * @param {boolean} [accountWithBalance] 
     * @param {boolean} [accountWithBalanceAndCBA] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getChildrenAccounts(accountId: string, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return AccountApiFp(this.configuration).getChildrenAccounts(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an account emails
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getEmails(accountId: string, options?: any) {
        return AccountApiFp(this.configuration).getEmails(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account invoice payments
     * @param {string} accountId 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [withAttempts] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getInvoicePayments(accountId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return AccountApiFp(this.configuration).getInvoicePayments(accountId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account invoices
     * @param {string} accountId 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {boolean} [withMigrationInvoices] 
     * @param {boolean} [unpaidInvoicesOnly] 
     * @param {boolean} [includeVoidedInvoices] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getInvoicesForAccount(accountId: string, startDate?: string, endDate?: string, withMigrationInvoices?: boolean, unpaidInvoicesOnly?: boolean, includeVoidedInvoices?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return AccountApiFp(this.configuration).getInvoicesForAccount(accountId, startDate, endDate, withMigrationInvoices, unpaidInvoicesOnly, includeVoidedInvoices, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve overdue state for account
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getOverdueAccount(accountId: string, options?: any) {
        return AccountApiFp(this.configuration).getOverdueAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account payment methods
     * @param {string} accountId 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [includedDeleted] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getPaymentMethodsForAccount(accountId: string, withPluginInfo?: boolean, includedDeleted?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return AccountApiFp(this.configuration).getPaymentMethodsForAccount(accountId, withPluginInfo, includedDeleted, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve account payments
     * @param {string} accountId 
     * @param {boolean} [withAttempts] 
     * @param {boolean} [withPluginInfo] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getPaymentsForAccount(accountId: string, withAttempts?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return AccountApiFp(this.configuration).getPaymentsForAccount(accountId, withAttempts, withPluginInfo, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify custom fields to account
     * @param {Array<CustomField>} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public modifyAccountCustomFields(body: Array<CustomField>, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).modifyAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger a payment for all unpaid invoices
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [paymentMethodId] 
     * @param {boolean} [externalPayment] 
     * @param {number} [paymentAmount] 
     * @param {string} [targetDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public payAllInvoices(accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, externalPayment?: boolean, paymentAmount?: number, targetDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).payAllInvoices(accountId, xKillbillCreatedBy, paymentMethodId, externalPayment, paymentAmount, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger a payment (authorization, purchase or credit)
     * @param {PaymentTransaction} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [paymentMethodId] 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public processPayment(body: PaymentTransaction, accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).processPayment(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger a payment using the account external key (authorization, purchase or credit)
     * @param {PaymentTransaction} body 
     * @param {string} externalKey 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [paymentMethodId] 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public processPaymentByExternalKey(body: PaymentTransaction, externalKey: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).processPaymentByExternalKey(body, externalKey, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rebalance account CBA
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public rebalanceExistingCBAOnAccount(accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).rebalanceExistingCBAOnAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh account payment methods
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [pluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public refreshPaymentMethods(accountId: string, xKillbillCreatedBy: string, pluginName?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).refreshPaymentMethods(accountId, xKillbillCreatedBy, pluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete email from account
     * @param {string} accountId 
     * @param {string} email 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public removeEmail(accountId: string, email: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).removeEmail(accountId, email, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search accounts
     * @param {string} searchKey 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {boolean} [accountWithBalance] 
     * @param {boolean} [accountWithBalanceAndCBA] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public searchAccounts(searchKey: string, offset?: number, limit?: number, accountWithBalance?: boolean, accountWithBalanceAndCBA?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return AccountApiFp(this.configuration).searchAccounts(searchKey, offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the default payment method
     * @param {string} accountId 
     * @param {string} paymentMethodId 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [payAllUnpaidInvoices] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public setDefaultPaymentMethod(accountId: string, paymentMethodId: string, xKillbillCreatedBy: string, payAllUnpaidInvoices?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).setDefaultPaymentMethod(accountId, paymentMethodId, xKillbillCreatedBy, payAllUnpaidInvoices, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move a given child credit to the parent level
     * @param {string} childAccountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public transferChildCreditToParent(childAccountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).transferChildCreditToParent(childAccountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update account
     * @param {Account} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [treatNullAsReset] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public updateAccount(body: Account, accountId: string, xKillbillCreatedBy: string, treatNullAsReset?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AccountApiFp(this.configuration).updateAccount(body, accountId, xKillbillCreatedBy, treatNullAsReset, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get queues entries
         * @param {string} [accountId] 
         * @param {string} [queueName] 
         * @param {string} [serviceName] 
         * @param {boolean} [withHistory] 
         * @param {string} [minDate] 
         * @param {string} [maxDate] 
         * @param {boolean} [withInProcessing] 
         * @param {boolean} [withBusEvents] 
         * @param {boolean} [withNotifications] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueEntries: async (accountId?: string, queueName?: string, serviceName?: string, withHistory?: boolean, minDate?: string, maxDate?: string, withInProcessing?: boolean, withBusEvents?: boolean, withNotifications?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/admin/queues`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (queueName !== undefined) {
                localVarQueryParameter['queueName'] = queueName;
            }

            if (serviceName !== undefined) {
                localVarQueryParameter['serviceName'] = serviceName;
            }

            if (withHistory !== undefined) {
                localVarQueryParameter['withHistory'] = withHistory;
            }

            if (minDate !== undefined) {
                localVarQueryParameter['minDate'] = minDate;
            }

            if (maxDate !== undefined) {
                localVarQueryParameter['maxDate'] = maxDate;
            }

            if (withInProcessing !== undefined) {
                localVarQueryParameter['withInProcessing'] = withInProcessing;
            }

            if (withBusEvents !== undefined) {
                localVarQueryParameter['withBusEvents'] = withBusEvents;
            }

            if (withNotifications !== undefined) {
                localVarQueryParameter['withNotifications'] = withNotifications;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidates the given Cache if specified, otherwise invalidates all caches
         * @param {string} [cacheName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCache: async (cacheName?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/admin/cache`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (cacheName !== undefined) {
                localVarQueryParameter['cacheName'] = cacheName;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidates Caches per account level
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCacheByAccount: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling invalidatesCacheByAccount.');
            }
            const localVarPath = `/1.0/kb/admin/cache/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidates Caches per tenant level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCacheByTenant: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/admin/cache/tenants`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put the host back into rotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInRotation: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/admin/healthcheck`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put the host out of rotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOutOfRotation: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/admin/healthcheck`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger an invoice generation for all parked accounts
         * @param {string} xKillbillCreatedBy 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerInvoiceGenerationForParkedAccounts: async (xKillbillCreatedBy: string, offset?: number, limit?: number, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling triggerInvoiceGenerationForParkedAccounts.');
            }
            const localVarPath = `/1.0/kb/admin/invoices`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update existing paymentTransaction and associated payment state
         * @param {AdminPayment} body 
         * @param {string} paymentId 
         * @param {string} paymentTransactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentTransactionState: async (body: AdminPayment, paymentId: string, paymentTransactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePaymentTransactionState.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling updatePaymentTransactionState.');
            }
            // verify required parameter 'paymentTransactionId' is not null or undefined
            if (paymentTransactionId === null || paymentTransactionId === undefined) {
                throw new RequiredError('paymentTransactionId','Required parameter paymentTransactionId was null or undefined when calling updatePaymentTransactionState.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling updatePaymentTransactionState.');
            }
            const localVarPath = `/1.0/kb/admin/payments/{paymentId}/transactions/{paymentTransactionId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)))
                .replace(`{${"paymentTransactionId"}}`, encodeURIComponent(String(paymentTransactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get queues entries
         * @param {string} [accountId] 
         * @param {string} [queueName] 
         * @param {string} [serviceName] 
         * @param {boolean} [withHistory] 
         * @param {string} [minDate] 
         * @param {string} [maxDate] 
         * @param {boolean} [withInProcessing] 
         * @param {boolean} [withBusEvents] 
         * @param {boolean} [withNotifications] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueEntries(accountId?: string, queueName?: string, serviceName?: string, withHistory?: boolean, minDate?: string, maxDate?: string, withInProcessing?: boolean, withBusEvents?: boolean, withNotifications?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).getQueueEntries(accountId, queueName, serviceName, withHistory, minDate, maxDate, withInProcessing, withBusEvents, withNotifications, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Invalidates the given Cache if specified, otherwise invalidates all caches
         * @param {string} [cacheName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invalidatesCache(cacheName?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).invalidatesCache(cacheName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Invalidates Caches per account level
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invalidatesCacheByAccount(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).invalidatesCacheByAccount(accountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Invalidates Caches per tenant level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invalidatesCacheByTenant(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).invalidatesCacheByTenant(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Put the host back into rotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putInRotation(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).putInRotation(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Put the host out of rotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putOutOfRotation(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).putOutOfRotation(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Trigger an invoice generation for all parked accounts
         * @param {string} xKillbillCreatedBy 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerInvoiceGenerationForParkedAccounts(xKillbillCreatedBy: string, offset?: number, limit?: number, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).triggerInvoiceGenerationForParkedAccounts(xKillbillCreatedBy, offset, limit, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update existing paymentTransaction and associated payment state
         * @param {AdminPayment} body 
         * @param {string} paymentId 
         * @param {string} paymentTransactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePaymentTransactionState(body: AdminPayment, paymentId: string, paymentTransactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).updatePaymentTransactionState(body, paymentId, paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get queues entries
         * @param {string} [accountId] 
         * @param {string} [queueName] 
         * @param {string} [serviceName] 
         * @param {boolean} [withHistory] 
         * @param {string} [minDate] 
         * @param {string} [maxDate] 
         * @param {boolean} [withInProcessing] 
         * @param {boolean} [withBusEvents] 
         * @param {boolean} [withNotifications] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueEntries(accountId?: string, queueName?: string, serviceName?: string, withHistory?: boolean, minDate?: string, maxDate?: string, withInProcessing?: boolean, withBusEvents?: boolean, withNotifications?: boolean, options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).getQueueEntries(accountId, queueName, serviceName, withHistory, minDate, maxDate, withInProcessing, withBusEvents, withNotifications, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invalidates the given Cache if specified, otherwise invalidates all caches
         * @param {string} [cacheName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCache(cacheName?: string, options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).invalidatesCache(cacheName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invalidates Caches per account level
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCacheByAccount(accountId: string, options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).invalidatesCacheByAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invalidates Caches per tenant level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCacheByTenant(options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).invalidatesCacheByTenant(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put the host back into rotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInRotation(options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).putInRotation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put the host out of rotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOutOfRotation(options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).putOutOfRotation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger an invoice generation for all parked accounts
         * @param {string} xKillbillCreatedBy 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerInvoiceGenerationForParkedAccounts(xKillbillCreatedBy: string, offset?: number, limit?: number, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).triggerInvoiceGenerationForParkedAccounts(xKillbillCreatedBy, offset, limit, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update existing paymentTransaction and associated payment state
         * @param {AdminPayment} body 
         * @param {string} paymentId 
         * @param {string} paymentTransactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentTransactionState(body: AdminPayment, paymentId: string, paymentTransactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return AdminApiFp(configuration).updatePaymentTransactionState(body, paymentId, paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @summary Get queues entries
     * @param {string} [accountId] 
     * @param {string} [queueName] 
     * @param {string} [serviceName] 
     * @param {boolean} [withHistory] 
     * @param {string} [minDate] 
     * @param {string} [maxDate] 
     * @param {boolean} [withInProcessing] 
     * @param {boolean} [withBusEvents] 
     * @param {boolean} [withNotifications] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getQueueEntries(accountId?: string, queueName?: string, serviceName?: string, withHistory?: boolean, minDate?: string, maxDate?: string, withInProcessing?: boolean, withBusEvents?: boolean, withNotifications?: boolean, options?: any) {
        return AdminApiFp(this.configuration).getQueueEntries(accountId, queueName, serviceName, withHistory, minDate, maxDate, withInProcessing, withBusEvents, withNotifications, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invalidates the given Cache if specified, otherwise invalidates all caches
     * @param {string} [cacheName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public invalidatesCache(cacheName?: string, options?: any) {
        return AdminApiFp(this.configuration).invalidatesCache(cacheName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invalidates Caches per account level
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public invalidatesCacheByAccount(accountId: string, options?: any) {
        return AdminApiFp(this.configuration).invalidatesCacheByAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invalidates Caches per tenant level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public invalidatesCacheByTenant(options?: any) {
        return AdminApiFp(this.configuration).invalidatesCacheByTenant(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put the host back into rotation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public putInRotation(options?: any) {
        return AdminApiFp(this.configuration).putInRotation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put the host out of rotation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public putOutOfRotation(options?: any) {
        return AdminApiFp(this.configuration).putOutOfRotation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger an invoice generation for all parked accounts
     * @param {string} xKillbillCreatedBy 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public triggerInvoiceGenerationForParkedAccounts(xKillbillCreatedBy: string, offset?: number, limit?: number, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AdminApiFp(this.configuration).triggerInvoiceGenerationForParkedAccounts(xKillbillCreatedBy, offset, limit, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update existing paymentTransaction and associated payment state
     * @param {AdminPayment} body 
     * @param {string} paymentId 
     * @param {string} paymentTransactionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updatePaymentTransactionState(body: AdminPayment, paymentId: string, paymentTransactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return AdminApiFp(this.configuration).updatePaymentTransactionState(body, paymentId, paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * BundleApi - axios parameter creator
 * @export
 */
export const BundleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Block a bundle
         * @param {BlockingState} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBundleBlockingState: async (body: BlockingState, bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addBundleBlockingState.');
            }
            // verify required parameter 'bundleId' is not null or undefined
            if (bundleId === null || bundleId === undefined) {
                throw new RequiredError('bundleId','Required parameter bundleId was null or undefined when calling addBundleBlockingState.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling addBundleBlockingState.');
            }
            const localVarPath = `/1.0/kb/bundles/{bundleId}/block`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add custom fields to bundle
         * @param {Array<CustomField>} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundleCustomFields: async (body: Array<CustomField>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createBundleCustomFields.');
            }
            // verify required parameter 'bundleId' is not null or undefined
            if (bundleId === null || bundleId === undefined) {
                throw new RequiredError('bundleId','Required parameter bundleId was null or undefined when calling createBundleCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createBundleCustomFields.');
            }
            const localVarPath = `/1.0/kb/bundles/{bundleId}/customFields`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add tags to bundle
         * @param {Array<string>} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundleTags: async (body: Array<string>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createBundleTags.');
            }
            // verify required parameter 'bundleId' is not null or undefined
            if (bundleId === null || bundleId === undefined) {
                throw new RequiredError('bundleId','Required parameter bundleId was null or undefined when calling createBundleTags.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createBundleTags.');
            }
            const localVarPath = `/1.0/kb/bundles/{bundleId}/tags`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove custom fields from bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBundleCustomFields: async (bundleId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            if (bundleId === null || bundleId === undefined) {
                throw new RequiredError('bundleId','Required parameter bundleId was null or undefined when calling deleteBundleCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deleteBundleCustomFields.');
            }
            const localVarPath = `/1.0/kb/bundles/{bundleId}/customFields`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove tags from bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBundleTags: async (bundleId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            if (bundleId === null || bundleId === undefined) {
                throw new RequiredError('bundleId','Required parameter bundleId was null or undefined when calling deleteBundleTags.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deleteBundleTags.');
            }
            const localVarPath = `/1.0/kb/bundles/{bundleId}/tags`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a bundle by id
         * @param {string} bundleId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundle: async (bundleId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            if (bundleId === null || bundleId === undefined) {
                throw new RequiredError('bundleId','Required parameter bundleId was null or undefined when calling getBundle.');
            }
            const localVarPath = `/1.0/kb/bundles/{bundleId}`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve bundle audit logs with history by id
         * @param {string} bundleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleAuditLogsWithHistory: async (bundleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            if (bundleId === null || bundleId === undefined) {
                throw new RequiredError('bundleId','Required parameter bundleId was null or undefined when calling getBundleAuditLogsWithHistory.');
            }
            const localVarPath = `/1.0/kb/bundles/{bundleId}/auditLogsWithHistory`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a bundle by external key
         * @param {string} externalKey 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleByKey: async (externalKey: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalKey' is not null or undefined
            if (externalKey === null || externalKey === undefined) {
                throw new RequiredError('externalKey','Required parameter externalKey was null or undefined when calling getBundleByKey.');
            }
            const localVarPath = `/1.0/kb/bundles`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve bundle custom fields
         * @param {string} bundleId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleCustomFields: async (bundleId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            if (bundleId === null || bundleId === undefined) {
                throw new RequiredError('bundleId','Required parameter bundleId was null or undefined when calling getBundleCustomFields.');
            }
            const localVarPath = `/1.0/kb/bundles/{bundleId}/customFields`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve bundle tags
         * @param {string} bundleId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleTags: async (bundleId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            if (bundleId === null || bundleId === undefined) {
                throw new RequiredError('bundleId','Required parameter bundleId was null or undefined when calling getBundleTags.');
            }
            const localVarPath = `/1.0/kb/bundles/{bundleId}/tags`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bundles
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundles: async (offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/bundles/pagination`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify custom fields to bundle
         * @param {Array<CustomField>} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyBundleCustomFields: async (body: Array<CustomField>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling modifyBundleCustomFields.');
            }
            // verify required parameter 'bundleId' is not null or undefined
            if (bundleId === null || bundleId === undefined) {
                throw new RequiredError('bundleId','Required parameter bundleId was null or undefined when calling modifyBundleCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling modifyBundleCustomFields.');
            }
            const localVarPath = `/1.0/kb/bundles/{bundleId}/customFields`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pause a bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseBundle: async (bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            if (bundleId === null || bundleId === undefined) {
                throw new RequiredError('bundleId','Required parameter bundleId was null or undefined when calling pauseBundle.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling pauseBundle.');
            }
            const localVarPath = `/1.0/kb/bundles/{bundleId}/pause`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a bundle externalKey
         * @param {Bundle} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameExternalKey: async (body: Bundle, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling renameExternalKey.');
            }
            // verify required parameter 'bundleId' is not null or undefined
            if (bundleId === null || bundleId === undefined) {
                throw new RequiredError('bundleId','Required parameter bundleId was null or undefined when calling renameExternalKey.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling renameExternalKey.');
            }
            const localVarPath = `/1.0/kb/bundles/{bundleId}/renameKey`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resume a bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeBundle: async (bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleId' is not null or undefined
            if (bundleId === null || bundleId === undefined) {
                throw new RequiredError('bundleId','Required parameter bundleId was null or undefined when calling resumeBundle.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling resumeBundle.');
            }
            const localVarPath = `/1.0/kb/bundles/{bundleId}/resume`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search bundles
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBundles: async (searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            if (searchKey === null || searchKey === undefined) {
                throw new RequiredError('searchKey','Required parameter searchKey was null or undefined when calling searchBundles.');
            }
            const localVarPath = `/1.0/kb/bundles/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfer a bundle to another account
         * @param {Bundle} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferBundle: async (body: Bundle, bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling transferBundle.');
            }
            // verify required parameter 'bundleId' is not null or undefined
            if (bundleId === null || bundleId === undefined) {
                throw new RequiredError('bundleId','Required parameter bundleId was null or undefined when calling transferBundle.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling transferBundle.');
            }
            const localVarPath = `/1.0/kb/bundles/{bundleId}`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (billingPolicy !== undefined) {
                localVarQueryParameter['billingPolicy'] = billingPolicy;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BundleApi - functional programming interface
 * @export
 */
export const BundleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Block a bundle
         * @param {BlockingState} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBundleBlockingState(body: BlockingState, bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlockingState>>> {
            const localVarAxiosArgs = await BundleApiAxiosParamCreator(configuration).addBundleBlockingState(body, bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add custom fields to bundle
         * @param {Array<CustomField>} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBundleCustomFields(body: Array<CustomField>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await BundleApiAxiosParamCreator(configuration).createBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add tags to bundle
         * @param {Array<string>} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBundleTags(body: Array<string>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await BundleApiAxiosParamCreator(configuration).createBundleTags(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove custom fields from bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBundleCustomFields(bundleId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BundleApiAxiosParamCreator(configuration).deleteBundleCustomFields(bundleId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove tags from bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBundleTags(bundleId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BundleApiAxiosParamCreator(configuration).deleteBundleTags(bundleId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a bundle by id
         * @param {string} bundleId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBundle(bundleId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bundle>> {
            const localVarAxiosArgs = await BundleApiAxiosParamCreator(configuration).getBundle(bundleId, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve bundle audit logs with history by id
         * @param {string} bundleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBundleAuditLogsWithHistory(bundleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await BundleApiAxiosParamCreator(configuration).getBundleAuditLogsWithHistory(bundleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a bundle by external key
         * @param {string} externalKey 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBundleByKey(externalKey: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bundle>>> {
            const localVarAxiosArgs = await BundleApiAxiosParamCreator(configuration).getBundleByKey(externalKey, includedDeleted, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve bundle custom fields
         * @param {string} bundleId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBundleCustomFields(bundleId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await BundleApiAxiosParamCreator(configuration).getBundleCustomFields(bundleId, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve bundle tags
         * @param {string} bundleId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBundleTags(bundleId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await BundleApiAxiosParamCreator(configuration).getBundleTags(bundleId, includedDeleted, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List bundles
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBundles(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bundle>>> {
            const localVarAxiosArgs = await BundleApiAxiosParamCreator(configuration).getBundles(offset, limit, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify custom fields to bundle
         * @param {Array<CustomField>} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyBundleCustomFields(body: Array<CustomField>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BundleApiAxiosParamCreator(configuration).modifyBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Pause a bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pauseBundle(bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BundleApiAxiosParamCreator(configuration).pauseBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a bundle externalKey
         * @param {Bundle} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameExternalKey(body: Bundle, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BundleApiAxiosParamCreator(configuration).renameExternalKey(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Resume a bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resumeBundle(bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BundleApiAxiosParamCreator(configuration).resumeBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Search bundles
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchBundles(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bundle>>> {
            const localVarAxiosArgs = await BundleApiAxiosParamCreator(configuration).searchBundles(searchKey, offset, limit, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Transfer a bundle to another account
         * @param {Bundle} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transferBundle(body: Bundle, bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bundle>> {
            const localVarAxiosArgs = await BundleApiAxiosParamCreator(configuration).transferBundle(body, bundleId, xKillbillCreatedBy, requestedDate, billingPolicy, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BundleApi - factory interface
 * @export
 */
export const BundleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Block a bundle
         * @param {BlockingState} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBundleBlockingState(body: BlockingState, bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<BlockingState>> {
            return BundleApiFp(configuration).addBundleBlockingState(body, bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add custom fields to bundle
         * @param {Array<CustomField>} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundleCustomFields(body: Array<CustomField>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<CustomField>> {
            return BundleApiFp(configuration).createBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add tags to bundle
         * @param {Array<string>} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundleTags(body: Array<string>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<Tag>> {
            return BundleApiFp(configuration).createBundleTags(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove custom fields from bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBundleCustomFields(bundleId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return BundleApiFp(configuration).deleteBundleCustomFields(bundleId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove tags from bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBundleTags(bundleId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return BundleApiFp(configuration).deleteBundleTags(bundleId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a bundle by id
         * @param {string} bundleId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundle(bundleId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Bundle> {
            return BundleApiFp(configuration).getBundle(bundleId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve bundle audit logs with history by id
         * @param {string} bundleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleAuditLogsWithHistory(bundleId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return BundleApiFp(configuration).getBundleAuditLogsWithHistory(bundleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a bundle by external key
         * @param {string} externalKey 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleByKey(externalKey: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Bundle>> {
            return BundleApiFp(configuration).getBundleByKey(externalKey, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve bundle custom fields
         * @param {string} bundleId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleCustomFields(bundleId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return BundleApiFp(configuration).getBundleCustomFields(bundleId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve bundle tags
         * @param {string} bundleId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleTags(bundleId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return BundleApiFp(configuration).getBundleTags(bundleId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List bundles
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundles(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Bundle>> {
            return BundleApiFp(configuration).getBundles(offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify custom fields to bundle
         * @param {Array<CustomField>} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyBundleCustomFields(body: Array<CustomField>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return BundleApiFp(configuration).modifyBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pause a bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseBundle(bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return BundleApiFp(configuration).pauseBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a bundle externalKey
         * @param {Bundle} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameExternalKey(body: Bundle, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return BundleApiFp(configuration).renameExternalKey(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resume a bundle
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeBundle(bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return BundleApiFp(configuration).resumeBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search bundles
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBundles(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Bundle>> {
            return BundleApiFp(configuration).searchBundles(searchKey, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfer a bundle to another account
         * @param {Bundle} body 
         * @param {string} bundleId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferBundle(body: Bundle, bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Bundle> {
            return BundleApiFp(configuration).transferBundle(body, bundleId, xKillbillCreatedBy, requestedDate, billingPolicy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BundleApi - object-oriented interface
 * @export
 * @class BundleApi
 * @extends {BaseAPI}
 */
export class BundleApi extends BaseAPI {
    /**
     * 
     * @summary Block a bundle
     * @param {BlockingState} body 
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public addBundleBlockingState(body: BlockingState, bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return BundleApiFp(this.configuration).addBundleBlockingState(body, bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add custom fields to bundle
     * @param {Array<CustomField>} body 
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public createBundleCustomFields(body: Array<CustomField>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return BundleApiFp(this.configuration).createBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add tags to bundle
     * @param {Array<string>} body 
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public createBundleTags(body: Array<string>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return BundleApiFp(this.configuration).createBundleTags(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove custom fields from bundle
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [customField] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public deleteBundleCustomFields(bundleId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return BundleApiFp(this.configuration).deleteBundleCustomFields(bundleId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove tags from bundle
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [tagDef] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public deleteBundleTags(bundleId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return BundleApiFp(this.configuration).deleteBundleTags(bundleId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a bundle by id
     * @param {string} bundleId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public getBundle(bundleId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return BundleApiFp(this.configuration).getBundle(bundleId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve bundle audit logs with history by id
     * @param {string} bundleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public getBundleAuditLogsWithHistory(bundleId: string, options?: any) {
        return BundleApiFp(this.configuration).getBundleAuditLogsWithHistory(bundleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a bundle by external key
     * @param {string} externalKey 
     * @param {boolean} [includedDeleted] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public getBundleByKey(externalKey: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return BundleApiFp(this.configuration).getBundleByKey(externalKey, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve bundle custom fields
     * @param {string} bundleId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public getBundleCustomFields(bundleId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return BundleApiFp(this.configuration).getBundleCustomFields(bundleId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve bundle tags
     * @param {string} bundleId 
     * @param {boolean} [includedDeleted] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public getBundleTags(bundleId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return BundleApiFp(this.configuration).getBundleTags(bundleId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List bundles
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public getBundles(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return BundleApiFp(this.configuration).getBundles(offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify custom fields to bundle
     * @param {Array<CustomField>} body 
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public modifyBundleCustomFields(body: Array<CustomField>, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return BundleApiFp(this.configuration).modifyBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pause a bundle
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public pauseBundle(bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return BundleApiFp(this.configuration).pauseBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a bundle externalKey
     * @param {Bundle} body 
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public renameExternalKey(body: Bundle, bundleId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return BundleApiFp(this.configuration).renameExternalKey(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resume a bundle
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public resumeBundle(bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return BundleApiFp(this.configuration).resumeBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search bundles
     * @param {string} searchKey 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public searchBundles(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return BundleApiFp(this.configuration).searchBundles(searchKey, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transfer a bundle to another account
     * @param {Bundle} body 
     * @param {string} bundleId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    public transferBundle(body: Bundle, bundleId: string, xKillbillCreatedBy: string, requestedDate?: string, billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return BundleApiFp(this.configuration).transferBundle(body, bundleId, xKillbillCreatedBy, requestedDate, billingPolicy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * CatalogApi - axios parameter creator
 * @export
 */
export const CatalogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a simple plan entry in the current version of the catalog
         * @param {SimplePlan} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSimplePlan: async (body: SimplePlan, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addSimplePlan.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling addSimplePlan.');
            }
            const localVarPath = `/1.0/kb/catalog/simplePlan`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all versions for a per tenant catalog
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCatalog: async (xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deleteCatalog.');
            }
            const localVarPath = `/1.0/kb/catalog`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve available add-ons for a given product
         * @param {string} [baseProductName] 
         * @param {string} [priceListName] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableAddons: async (baseProductName?: string, priceListName?: string, accountId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/catalog/availableAddons`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (baseProductName !== undefined) {
                localVarQueryParameter['baseProductName'] = baseProductName;
            }

            if (priceListName !== undefined) {
                localVarQueryParameter['priceListName'] = priceListName;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve available base plans
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableBasePlans: async (accountId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/catalog/availableBasePlans`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the catalog as JSON
         * @param {string} [requestedDate] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogJson: async (requestedDate?: string, accountId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/catalog`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString() :
                    requestedDate;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a list of catalog versions
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogVersions: async (accountId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/catalog/versions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the full catalog as XML
         * @param {string} [requestedDate] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogXml: async (requestedDate?: string, accountId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/catalog/xml`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString() :
                    requestedDate;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve phase for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhaseForSubscriptionAndDate: async (subscriptionId?: string, requestedDate?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/catalog/phase`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (subscriptionId !== undefined) {
                localVarQueryParameter['subscriptionId'] = subscriptionId;
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve plan for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlanForSubscriptionAndDate: async (subscriptionId?: string, requestedDate?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/catalog/plan`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (subscriptionId !== undefined) {
                localVarQueryParameter['subscriptionId'] = subscriptionId;
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve priceList for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPriceListForSubscriptionAndDate: async (subscriptionId?: string, requestedDate?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/catalog/priceList`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (subscriptionId !== undefined) {
                localVarQueryParameter['subscriptionId'] = subscriptionId;
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve product for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductForSubscriptionAndDate: async (subscriptionId?: string, requestedDate?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/catalog/product`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (subscriptionId !== undefined) {
                localVarQueryParameter['subscriptionId'] = subscriptionId;
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload the full catalog as XML
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCatalogXml: async (body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadCatalogXml.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling uploadCatalogXml.');
            }
            const localVarPath = `/1.0/kb/catalog/xml`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/xml';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogApi - functional programming interface
 * @export
 */
export const CatalogApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a simple plan entry in the current version of the catalog
         * @param {SimplePlan} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSimplePlan(body: SimplePlan, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CatalogApiAxiosParamCreator(configuration).addSimplePlan(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete all versions for a per tenant catalog
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCatalog(xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CatalogApiAxiosParamCreator(configuration).deleteCatalog(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve available add-ons for a given product
         * @param {string} [baseProductName] 
         * @param {string} [priceListName] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableAddons(baseProductName?: string, priceListName?: string, accountId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlanDetail>>> {
            const localVarAxiosArgs = await CatalogApiAxiosParamCreator(configuration).getAvailableAddons(baseProductName, priceListName, accountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve available base plans
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableBasePlans(accountId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlanDetail>>> {
            const localVarAxiosArgs = await CatalogApiAxiosParamCreator(configuration).getAvailableBasePlans(accountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve the catalog as JSON
         * @param {string} [requestedDate] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalogJson(requestedDate?: string, accountId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Catalog>>> {
            const localVarAxiosArgs = await CatalogApiAxiosParamCreator(configuration).getCatalogJson(requestedDate, accountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a list of catalog versions
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalogVersions(accountId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await CatalogApiAxiosParamCreator(configuration).getCatalogVersions(accountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve the full catalog as XML
         * @param {string} [requestedDate] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalogXml(requestedDate?: string, accountId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CatalogApiAxiosParamCreator(configuration).getCatalogXml(requestedDate, accountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve phase for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhaseForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Phase>> {
            const localVarAxiosArgs = await CatalogApiAxiosParamCreator(configuration).getPhaseForSubscriptionAndDate(subscriptionId, requestedDate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve plan for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlanForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plan>> {
            const localVarAxiosArgs = await CatalogApiAxiosParamCreator(configuration).getPlanForSubscriptionAndDate(subscriptionId, requestedDate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve priceList for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPriceListForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PriceList>> {
            const localVarAxiosArgs = await CatalogApiAxiosParamCreator(configuration).getPriceListForSubscriptionAndDate(subscriptionId, requestedDate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve product for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await CatalogApiAxiosParamCreator(configuration).getProductForSubscriptionAndDate(subscriptionId, requestedDate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Upload the full catalog as XML
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCatalogXml(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await CatalogApiAxiosParamCreator(configuration).uploadCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CatalogApi - factory interface
 * @export
 */
export const CatalogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Add a simple plan entry in the current version of the catalog
         * @param {SimplePlan} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSimplePlan(body: SimplePlan, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<string> {
            return CatalogApiFp(configuration).addSimplePlan(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all versions for a per tenant catalog
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCatalog(xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return CatalogApiFp(configuration).deleteCatalog(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve available add-ons for a given product
         * @param {string} [baseProductName] 
         * @param {string} [priceListName] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableAddons(baseProductName?: string, priceListName?: string, accountId?: string, options?: any): AxiosPromise<Array<PlanDetail>> {
            return CatalogApiFp(configuration).getAvailableAddons(baseProductName, priceListName, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve available base plans
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableBasePlans(accountId?: string, options?: any): AxiosPromise<Array<PlanDetail>> {
            return CatalogApiFp(configuration).getAvailableBasePlans(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the catalog as JSON
         * @param {string} [requestedDate] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogJson(requestedDate?: string, accountId?: string, options?: any): AxiosPromise<Array<Catalog>> {
            return CatalogApiFp(configuration).getCatalogJson(requestedDate, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a list of catalog versions
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogVersions(accountId?: string, options?: any): AxiosPromise<Array<string>> {
            return CatalogApiFp(configuration).getCatalogVersions(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the full catalog as XML
         * @param {string} [requestedDate] 
         * @param {string} [accountId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogXml(requestedDate?: string, accountId?: string, options?: any): AxiosPromise<string> {
            return CatalogApiFp(configuration).getCatalogXml(requestedDate, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve phase for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhaseForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: any): AxiosPromise<Phase> {
            return CatalogApiFp(configuration).getPhaseForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve plan for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlanForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: any): AxiosPromise<Plan> {
            return CatalogApiFp(configuration).getPlanForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve priceList for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPriceListForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: any): AxiosPromise<PriceList> {
            return CatalogApiFp(configuration).getPriceListForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve product for a given subscription and date
         * @param {string} [subscriptionId] 
         * @param {string} [requestedDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: any): AxiosPromise<Product> {
            return CatalogApiFp(configuration).getProductForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload the full catalog as XML
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCatalogXml(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<string> {
            return CatalogApiFp(configuration).uploadCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CatalogApi - object-oriented interface
 * @export
 * @class CatalogApi
 * @extends {BaseAPI}
 */
export class CatalogApi extends BaseAPI {
    /**
     * 
     * @summary Add a simple plan entry in the current version of the catalog
     * @param {SimplePlan} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public addSimplePlan(body: SimplePlan, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return CatalogApiFp(this.configuration).addSimplePlan(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all versions for a per tenant catalog
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public deleteCatalog(xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return CatalogApiFp(this.configuration).deleteCatalog(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve available add-ons for a given product
     * @param {string} [baseProductName] 
     * @param {string} [priceListName] 
     * @param {string} [accountId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getAvailableAddons(baseProductName?: string, priceListName?: string, accountId?: string, options?: any) {
        return CatalogApiFp(this.configuration).getAvailableAddons(baseProductName, priceListName, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve available base plans
     * @param {string} [accountId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getAvailableBasePlans(accountId?: string, options?: any) {
        return CatalogApiFp(this.configuration).getAvailableBasePlans(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the catalog as JSON
     * @param {string} [requestedDate] 
     * @param {string} [accountId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getCatalogJson(requestedDate?: string, accountId?: string, options?: any) {
        return CatalogApiFp(this.configuration).getCatalogJson(requestedDate, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a list of catalog versions
     * @param {string} [accountId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getCatalogVersions(accountId?: string, options?: any) {
        return CatalogApiFp(this.configuration).getCatalogVersions(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the full catalog as XML
     * @param {string} [requestedDate] 
     * @param {string} [accountId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getCatalogXml(requestedDate?: string, accountId?: string, options?: any) {
        return CatalogApiFp(this.configuration).getCatalogXml(requestedDate, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve phase for a given subscription and date
     * @param {string} [subscriptionId] 
     * @param {string} [requestedDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getPhaseForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: any) {
        return CatalogApiFp(this.configuration).getPhaseForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve plan for a given subscription and date
     * @param {string} [subscriptionId] 
     * @param {string} [requestedDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getPlanForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: any) {
        return CatalogApiFp(this.configuration).getPlanForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve priceList for a given subscription and date
     * @param {string} [subscriptionId] 
     * @param {string} [requestedDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getPriceListForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: any) {
        return CatalogApiFp(this.configuration).getPriceListForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve product for a given subscription and date
     * @param {string} [subscriptionId] 
     * @param {string} [requestedDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public getProductForSubscriptionAndDate(subscriptionId?: string, requestedDate?: string, options?: any) {
        return CatalogApiFp(this.configuration).getProductForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload the full catalog as XML
     * @param {string} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    public uploadCatalogXml(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return CatalogApiFp(this.configuration).uploadCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * CreditApi - axios parameter creator
 * @export
 */
export const CreditApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a credit
         * @param {Array<InvoiceItem>} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [autoCommit] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredits: async (body: Array<InvoiceItem>, xKillbillCreatedBy: string, autoCommit?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCredits.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createCredits.');
            }
            const localVarPath = `/1.0/kb/credits`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (autoCommit !== undefined) {
                localVarQueryParameter['autoCommit'] = autoCommit;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a credit by id
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredit: async (creditId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'creditId' is not null or undefined
            if (creditId === null || creditId === undefined) {
                throw new RequiredError('creditId','Required parameter creditId was null or undefined when calling getCredit.');
            }
            const localVarPath = `/1.0/kb/credits/{creditId}`
                .replace(`{${"creditId"}}`, encodeURIComponent(String(creditId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditApi - functional programming interface
 * @export
 */
export const CreditApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a credit
         * @param {Array<InvoiceItem>} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [autoCommit] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCredits(body: Array<InvoiceItem>, xKillbillCreatedBy: string, autoCommit?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvoiceItem>>> {
            const localVarAxiosArgs = await CreditApiAxiosParamCreator(configuration).createCredits(body, xKillbillCreatedBy, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a credit by id
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCredit(creditId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceItem>> {
            const localVarAxiosArgs = await CreditApiAxiosParamCreator(configuration).getCredit(creditId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CreditApi - factory interface
 * @export
 */
export const CreditApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a credit
         * @param {Array<InvoiceItem>} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [autoCommit] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredits(body: Array<InvoiceItem>, xKillbillCreatedBy: string, autoCommit?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<InvoiceItem>> {
            return CreditApiFp(configuration).createCredits(body, xKillbillCreatedBy, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a credit by id
         * @param {string} creditId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredit(creditId: string, options?: any): AxiosPromise<InvoiceItem> {
            return CreditApiFp(configuration).getCredit(creditId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditApi - object-oriented interface
 * @export
 * @class CreditApi
 * @extends {BaseAPI}
 */
export class CreditApi extends BaseAPI {
    /**
     * 
     * @summary Create a credit
     * @param {Array<InvoiceItem>} body 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [autoCommit] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public createCredits(body: Array<InvoiceItem>, xKillbillCreatedBy: string, autoCommit?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return CreditApiFp(this.configuration).createCredits(body, xKillbillCreatedBy, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a credit by id
     * @param {string} creditId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    public getCredit(creditId: string, options?: any) {
        return CreditApiFp(this.configuration).getCredit(creditId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * CustomFieldApi - axios parameter creator
 * @export
 */
export const CustomFieldApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve custom field audit logs with history by id
         * @param {string} customFieldId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomFieldAuditLogsWithHistory: async (customFieldId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customFieldId' is not null or undefined
            if (customFieldId === null || customFieldId === undefined) {
                throw new RequiredError('customFieldId','Required parameter customFieldId was null or undefined when calling getCustomFieldAuditLogsWithHistory.');
            }
            const localVarPath = `/1.0/kb/customFields/{customFieldId}/auditLogsWithHistory`
                .replace(`{${"customFieldId"}}`, encodeURIComponent(String(customFieldId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List custom fields
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomFields: async (offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/customFields/pagination`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search custom fields
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCustomFields: async (searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            if (searchKey === null || searchKey === undefined) {
                throw new RequiredError('searchKey','Required parameter searchKey was null or undefined when calling searchCustomFields.');
            }
            const localVarPath = `/1.0/kb/customFields/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search custom fields by type, name and optional value
         * @param {string} [objectType] 
         * @param {string} [fieldName] 
         * @param {string} [fieldValue] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCustomFieldsByTypeName: async (objectType?: string, fieldName?: string, fieldValue?: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/customFields/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (objectType !== undefined) {
                localVarQueryParameter['objectType'] = objectType;
            }

            if (fieldName !== undefined) {
                localVarQueryParameter['fieldName'] = fieldName;
            }

            if (fieldValue !== undefined) {
                localVarQueryParameter['fieldValue'] = fieldValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomFieldApi - functional programming interface
 * @export
 */
export const CustomFieldApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve custom field audit logs with history by id
         * @param {string} customFieldId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomFieldAuditLogsWithHistory(customFieldId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await CustomFieldApiAxiosParamCreator(configuration).getCustomFieldAuditLogsWithHistory(customFieldId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List custom fields
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomFields(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await CustomFieldApiAxiosParamCreator(configuration).getCustomFields(offset, limit, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Search custom fields
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCustomFields(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await CustomFieldApiAxiosParamCreator(configuration).searchCustomFields(searchKey, offset, limit, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Search custom fields by type, name and optional value
         * @param {string} [objectType] 
         * @param {string} [fieldName] 
         * @param {string} [fieldValue] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchCustomFieldsByTypeName(objectType?: string, fieldName?: string, fieldValue?: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await CustomFieldApiAxiosParamCreator(configuration).searchCustomFieldsByTypeName(objectType, fieldName, fieldValue, offset, limit, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CustomFieldApi - factory interface
 * @export
 */
export const CustomFieldApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Retrieve custom field audit logs with history by id
         * @param {string} customFieldId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomFieldAuditLogsWithHistory(customFieldId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return CustomFieldApiFp(configuration).getCustomFieldAuditLogsWithHistory(customFieldId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List custom fields
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomFields(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return CustomFieldApiFp(configuration).getCustomFields(offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search custom fields
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCustomFields(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return CustomFieldApiFp(configuration).searchCustomFields(searchKey, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search custom fields by type, name and optional value
         * @param {string} [objectType] 
         * @param {string} [fieldName] 
         * @param {string} [fieldValue] 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCustomFieldsByTypeName(objectType?: string, fieldName?: string, fieldValue?: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return CustomFieldApiFp(configuration).searchCustomFieldsByTypeName(objectType, fieldName, fieldValue, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomFieldApi - object-oriented interface
 * @export
 * @class CustomFieldApi
 * @extends {BaseAPI}
 */
export class CustomFieldApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve custom field audit logs with history by id
     * @param {string} customFieldId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldApi
     */
    public getCustomFieldAuditLogsWithHistory(customFieldId: string, options?: any) {
        return CustomFieldApiFp(this.configuration).getCustomFieldAuditLogsWithHistory(customFieldId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List custom fields
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldApi
     */
    public getCustomFields(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return CustomFieldApiFp(this.configuration).getCustomFields(offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search custom fields
     * @param {string} searchKey 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldApi
     */
    public searchCustomFields(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return CustomFieldApiFp(this.configuration).searchCustomFields(searchKey, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search custom fields by type, name and optional value
     * @param {string} [objectType] 
     * @param {string} [fieldName] 
     * @param {string} [fieldValue] 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldApi
     */
    public searchCustomFieldsByTypeName(objectType?: string, fieldName?: string, fieldValue?: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return CustomFieldApiFp(this.configuration).searchCustomFieldsByTypeName(objectType, fieldName, fieldValue, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ExportApi - axios parameter creator
 * @export
 */
export const ExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Export account data
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportDataForAccount: async (accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling exportDataForAccount.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling exportDataForAccount.');
            }
            const localVarPath = `/1.0/kb/export/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportApi - functional programming interface
 * @export
 */
export const ExportApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Export account data
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportDataForAccount(accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ExportApiAxiosParamCreator(configuration).exportDataForAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ExportApi - factory interface
 * @export
 */
export const ExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Export account data
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportDataForAccount(accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return ExportApiFp(configuration).exportDataForAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExportApi - object-oriented interface
 * @export
 * @class ExportApi
 * @extends {BaseAPI}
 */
export class ExportApi extends BaseAPI {
    /**
     * 
     * @summary Export account data
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportDataForAccount(accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return ExportApiFp(this.configuration).exportDataForAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * InvoiceApi - axios parameter creator
 * @export
 */
export const InvoiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adjust an invoice item
         * @param {InvoiceItem} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustInvoiceItem: async (body: InvoiceItem, invoiceId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling adjustInvoiceItem.');
            }
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling adjustInvoiceItem.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling adjustInvoiceItem.');
            }
            const localVarPath = `/1.0/kb/invoices/{invoiceId}`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform the invoice status transition from DRAFT to COMMITTED
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitInvoice: async (invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling commitInvoice.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling commitInvoice.');
            }
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/commitInvoice`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create external charge(s)
         * @param {Array<InvoiceItem>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {boolean} [autoCommit] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalCharges: async (body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, requestedDate?: string, autoCommit?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createExternalCharges.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling createExternalCharges.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createExternalCharges.');
            }
            const localVarPath = `/1.0/kb/invoices/charges/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (autoCommit !== undefined) {
                localVarQueryParameter['autoCommit'] = autoCommit;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger an invoice generation
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFutureInvoice: async (accountId: string, xKillbillCreatedBy: string, targetDate?: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling createFutureInvoice.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createFutureInvoice.');
            }
            const localVarPath = `/1.0/kb/invoices`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (targetDate !== undefined) {
                localVarQueryParameter['targetDate'] = (targetDate as any instanceof Date) ?
                    (targetDate as any).toISOString().substr(0,10) :
                    targetDate;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger a payment for invoice
         * @param {InvoicePayment} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [externalPayment] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstantPayment: async (body: InvoicePayment, invoiceId: string, xKillbillCreatedBy: string, externalPayment?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createInstantPayment.');
            }
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling createInstantPayment.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createInstantPayment.');
            }
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/payments`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (externalPayment !== undefined) {
                localVarQueryParameter['externalPayment'] = externalPayment;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add custom fields to invoice
         * @param {Array<CustomField>} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceCustomFields: async (body: Array<CustomField>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createInvoiceCustomFields.');
            }
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling createInvoiceCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createInvoiceCustomFields.');
            }
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/customFields`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add tags to invoice
         * @param {Array<string>} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceTags: async (body: Array<string>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createInvoiceTags.');
            }
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling createInvoiceTags.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createInvoiceTags.');
            }
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/tags`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a migration invoice
         * @param {Array<InvoiceItem>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMigrationInvoice: async (body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, targetDate?: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createMigrationInvoice.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling createMigrationInvoice.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createMigrationInvoice.');
            }
            const localVarPath = `/1.0/kb/invoices/migration/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (targetDate !== undefined) {
                localVarQueryParameter['targetDate'] = (targetDate as any instanceof Date) ?
                    (targetDate as any).toISOString().substr(0,10) :
                    targetDate;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create tax items
         * @param {Array<InvoiceItem>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [autoCommit] 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaxItems: async (body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, autoCommit?: boolean, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTaxItems.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling createTaxItems.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createTaxItems.');
            }
            const localVarPath = `/1.0/kb/invoices/taxes/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (autoCommit !== undefined) {
                localVarQueryParameter['autoCommit'] = autoCommit;
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a CBA item
         * @param {string} invoiceId 
         * @param {string} invoiceItemId 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCBA: async (invoiceId: string, invoiceItemId: string, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling deleteCBA.');
            }
            // verify required parameter 'invoiceItemId' is not null or undefined
            if (invoiceItemId === null || invoiceItemId === undefined) {
                throw new RequiredError('invoiceItemId','Required parameter invoiceItemId was null or undefined when calling deleteCBA.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling deleteCBA.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deleteCBA.');
            }
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/{invoiceItemId}/cba`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)))
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove custom fields from invoice
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceCustomFields: async (invoiceId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling deleteInvoiceCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deleteInvoiceCustomFields.');
            }
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/customFields`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove tags from invoice
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceTags: async (invoiceId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling deleteInvoiceTags.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deleteInvoiceTags.');
            }
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/tags`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a dryRun invoice
         * @param {InvoiceDryRun} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateDryRunInvoice: async (body: InvoiceDryRun, accountId: string, xKillbillCreatedBy: string, targetDate?: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling generateDryRunInvoice.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling generateDryRunInvoice.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling generateDryRunInvoice.');
            }
            const localVarPath = `/1.0/kb/invoices/dryRun`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (targetDate !== undefined) {
                localVarQueryParameter['targetDate'] = (targetDate as any instanceof Date) ?
                    (targetDate as any).toISOString().substr(0,10) :
                    targetDate;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the catalog translation for the tenant
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogTranslation: async (locale: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locale' is not null or undefined
            if (locale === null || locale === undefined) {
                throw new RequiredError('locale','Required parameter locale was null or undefined when calling getCatalogTranslation.');
            }
            const localVarPath = `/1.0/kb/invoices/catalogTranslation/{locale}`
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an invoice by id
         * @param {string} invoiceId 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice: async (invoiceId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling getInvoice.');
            }
            const localVarPath = `/1.0/kb/invoices/{invoiceId}`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (withChildrenItems !== undefined) {
                localVarQueryParameter['withChildrenItems'] = withChildrenItems;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Render an invoice as HTML
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAsHTML: async (invoiceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling getInvoiceAsHTML.');
            }
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/html`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve invoice audit logs with history by id
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAuditLogsWithHistory: async (invoiceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling getInvoiceAuditLogsWithHistory.');
            }
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/auditLogsWithHistory`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an invoice by invoice item id
         * @param {string} itemId 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceByItemId: async (itemId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getInvoiceByItemId.');
            }
            const localVarPath = `/1.0/kb/invoices/byItemId/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (withChildrenItems !== undefined) {
                localVarQueryParameter['withChildrenItems'] = withChildrenItems;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an invoice by number
         * @param {number} invoiceNumber 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceByNumber: async (invoiceNumber: number, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceNumber' is not null or undefined
            if (invoiceNumber === null || invoiceNumber === undefined) {
                throw new RequiredError('invoiceNumber','Required parameter invoiceNumber was null or undefined when calling getInvoiceByNumber.');
            }
            const localVarPath = `/1.0/kb/invoices/byNumber/{invoiceNumber}`
                .replace(`{${"invoiceNumber"}}`, encodeURIComponent(String(invoiceNumber)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (withChildrenItems !== undefined) {
                localVarQueryParameter['withChildrenItems'] = withChildrenItems;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve invoice custom fields
         * @param {string} invoiceId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceCustomFields: async (invoiceId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling getInvoiceCustomFields.');
            }
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/customFields`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the manualPay invoice template for the tenant
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceMPTemplate: async (locale: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locale' is not null or undefined
            if (locale === null || locale === undefined) {
                throw new RequiredError('locale','Required parameter locale was null or undefined when calling getInvoiceMPTemplate.');
            }
            const localVarPath = `/1.0/kb/invoices/manualPayTemplate/{locale}`
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve invoice tags
         * @param {string} invoiceId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTags: async (invoiceId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling getInvoiceTags.');
            }
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/tags`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the invoice template for the tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTemplate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/invoices/template`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the invoice translation for the tenant
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTranslation: async (locale: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'locale' is not null or undefined
            if (locale === null || locale === undefined) {
                throw new RequiredError('locale','Required parameter locale was null or undefined when calling getInvoiceTranslation.');
            }
            const localVarPath = `/1.0/kb/invoices/translation/{locale}`
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List invoices
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices: async (offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/invoices/pagination`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payments associated with an invoice
         * @param {string} invoiceId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForInvoice: async (invoiceId: string, withPluginInfo?: boolean, withAttempts?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling getPaymentsForInvoice.');
            }
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/payments`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify custom fields to invoice
         * @param {Array<CustomField>} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoiceCustomFields: async (body: Array<CustomField>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling modifyInvoiceCustomFields.');
            }
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling modifyInvoiceCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling modifyInvoiceCustomFields.');
            }
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/customFields`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search invoices
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInvoices: async (searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            if (searchKey === null || searchKey === undefined) {
                throw new RequiredError('searchKey','Required parameter searchKey was null or undefined when calling searchInvoices.');
            }
            const localVarPath = `/1.0/kb/invoices/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload the catalog translation for the tenant
         * @param {string} body 
         * @param {string} locale 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCatalogTranslation: async (body: string, locale: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadCatalogTranslation.');
            }
            // verify required parameter 'locale' is not null or undefined
            if (locale === null || locale === undefined) {
                throw new RequiredError('locale','Required parameter locale was null or undefined when calling uploadCatalogTranslation.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling uploadCatalogTranslation.');
            }
            const localVarPath = `/1.0/kb/invoices/catalogTranslation/{locale}`
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (deleteIfExists !== undefined) {
                localVarQueryParameter['deleteIfExists'] = deleteIfExists;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload the manualPay invoice template for the tenant
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceMPTemplate: async (body: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadInvoiceMPTemplate.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling uploadInvoiceMPTemplate.');
            }
            const localVarPath = `/1.0/kb/invoices/manualPayTemplate`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (deleteIfExists !== undefined) {
                localVarQueryParameter['deleteIfExists'] = deleteIfExists;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/html';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload the invoice template for the tenant
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceTemplate: async (body: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadInvoiceTemplate.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling uploadInvoiceTemplate.');
            }
            const localVarPath = `/1.0/kb/invoices/template`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (deleteIfExists !== undefined) {
                localVarQueryParameter['deleteIfExists'] = deleteIfExists;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/html';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload the invoice translation for the tenant
         * @param {string} body 
         * @param {string} locale 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceTranslation: async (body: string, locale: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadInvoiceTranslation.');
            }
            // verify required parameter 'locale' is not null or undefined
            if (locale === null || locale === undefined) {
                throw new RequiredError('locale','Required parameter locale was null or undefined when calling uploadInvoiceTranslation.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling uploadInvoiceTranslation.');
            }
            const localVarPath = `/1.0/kb/invoices/translation/{locale}`
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (deleteIfExists !== undefined) {
                localVarQueryParameter['deleteIfExists'] = deleteIfExists;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform the action of voiding an invoice
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidInvoice: async (invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling voidInvoice.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling voidInvoice.');
            }
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/voidInvoice`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceApi - functional programming interface
 * @export
 */
export const InvoiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adjust an invoice item
         * @param {InvoiceItem} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adjustInvoiceItem(body: InvoiceItem, invoiceId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).adjustInvoiceItem(body, invoiceId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Perform the invoice status transition from DRAFT to COMMITTED
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commitInvoice(invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).commitInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create external charge(s)
         * @param {Array<InvoiceItem>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {boolean} [autoCommit] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExternalCharges(body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, requestedDate?: string, autoCommit?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvoiceItem>>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).createExternalCharges(body, accountId, xKillbillCreatedBy, requestedDate, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Trigger an invoice generation
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFutureInvoice(accountId: string, xKillbillCreatedBy: string, targetDate?: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).createFutureInvoice(accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Trigger a payment for invoice
         * @param {InvoicePayment} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [externalPayment] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInstantPayment(body: InvoicePayment, invoiceId: string, xKillbillCreatedBy: string, externalPayment?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoicePayment>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).createInstantPayment(body, invoiceId, xKillbillCreatedBy, externalPayment, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add custom fields to invoice
         * @param {Array<CustomField>} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoiceCustomFields(body: Array<CustomField>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).createInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add tags to invoice
         * @param {Array<string>} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoiceTags(body: Array<string>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).createInvoiceTags(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a migration invoice
         * @param {Array<InvoiceItem>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMigrationInvoice(body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, targetDate?: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).createMigrationInvoice(body, accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create tax items
         * @param {Array<InvoiceItem>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [autoCommit] 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaxItems(body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, autoCommit?: boolean, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvoiceItem>>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).createTaxItems(body, accountId, xKillbillCreatedBy, autoCommit, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a CBA item
         * @param {string} invoiceId 
         * @param {string} invoiceItemId 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCBA(invoiceId: string, invoiceItemId: string, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).deleteCBA(invoiceId, invoiceItemId, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove custom fields from invoice
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoiceCustomFields(invoiceId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).deleteInvoiceCustomFields(invoiceId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove tags from invoice
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoiceTags(invoiceId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).deleteInvoiceTags(invoiceId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Generate a dryRun invoice
         * @param {InvoiceDryRun} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateDryRunInvoice(body: InvoiceDryRun, accountId: string, xKillbillCreatedBy: string, targetDate?: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).generateDryRunInvoice(body, accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieves the catalog translation for the tenant
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCatalogTranslation(locale: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).getCatalogTranslation(locale, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve an invoice by id
         * @param {string} invoiceId 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoice(invoiceId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).getInvoice(invoiceId, withChildrenItems, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Render an invoice as HTML
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceAsHTML(invoiceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).getInvoiceAsHTML(invoiceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve invoice audit logs with history by id
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceAuditLogsWithHistory(invoiceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).getInvoiceAuditLogsWithHistory(invoiceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve an invoice by invoice item id
         * @param {string} itemId 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceByItemId(itemId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).getInvoiceByItemId(itemId, withChildrenItems, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve an invoice by number
         * @param {number} invoiceNumber 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceByNumber(invoiceNumber: number, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).getInvoiceByNumber(invoiceNumber, withChildrenItems, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve invoice custom fields
         * @param {string} invoiceId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceCustomFields(invoiceId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).getInvoiceCustomFields(invoiceId, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieves the manualPay invoice template for the tenant
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceMPTemplate(locale: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).getInvoiceMPTemplate(locale, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve invoice tags
         * @param {string} invoiceId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceTags(invoiceId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).getInvoiceTags(invoiceId, includedDeleted, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieves the invoice template for the tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceTemplate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).getInvoiceTemplate(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieves the invoice translation for the tenant
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceTranslation(locale: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).getInvoiceTranslation(locale, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List invoices
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoices(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).getInvoices(offset, limit, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve payments associated with an invoice
         * @param {string} invoiceId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentsForInvoice(invoiceId: string, withPluginInfo?: boolean, withAttempts?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvoicePayment>>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).getPaymentsForInvoice(invoiceId, withPluginInfo, withAttempts, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify custom fields to invoice
         * @param {Array<CustomField>} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyInvoiceCustomFields(body: Array<CustomField>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).modifyInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Search invoices
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchInvoices(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).searchInvoices(searchKey, offset, limit, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Upload the catalog translation for the tenant
         * @param {string} body 
         * @param {string} locale 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCatalogTranslation(body: string, locale: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).uploadCatalogTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Upload the manualPay invoice template for the tenant
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadInvoiceMPTemplate(body: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).uploadInvoiceMPTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Upload the invoice template for the tenant
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadInvoiceTemplate(body: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).uploadInvoiceTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Upload the invoice translation for the tenant
         * @param {string} body 
         * @param {string} locale 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadInvoiceTranslation(body: string, locale: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).uploadInvoiceTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Perform the action of voiding an invoice
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidInvoice(invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InvoiceApiAxiosParamCreator(configuration).voidInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InvoiceApi - factory interface
 * @export
 */
export const InvoiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Adjust an invoice item
         * @param {InvoiceItem} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustInvoiceItem(body: InvoiceItem, invoiceId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Invoice> {
            return InvoiceApiFp(configuration).adjustInvoiceItem(body, invoiceId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Perform the invoice status transition from DRAFT to COMMITTED
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitInvoice(invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return InvoiceApiFp(configuration).commitInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create external charge(s)
         * @param {Array<InvoiceItem>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {boolean} [autoCommit] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalCharges(body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, requestedDate?: string, autoCommit?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<InvoiceItem>> {
            return InvoiceApiFp(configuration).createExternalCharges(body, accountId, xKillbillCreatedBy, requestedDate, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger an invoice generation
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFutureInvoice(accountId: string, xKillbillCreatedBy: string, targetDate?: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Invoice> {
            return InvoiceApiFp(configuration).createFutureInvoice(accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger a payment for invoice
         * @param {InvoicePayment} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [externalPayment] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstantPayment(body: InvoicePayment, invoiceId: string, xKillbillCreatedBy: string, externalPayment?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<InvoicePayment> {
            return InvoiceApiFp(configuration).createInstantPayment(body, invoiceId, xKillbillCreatedBy, externalPayment, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add custom fields to invoice
         * @param {Array<CustomField>} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceCustomFields(body: Array<CustomField>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<CustomField>> {
            return InvoiceApiFp(configuration).createInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add tags to invoice
         * @param {Array<string>} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceTags(body: Array<string>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<Tag>> {
            return InvoiceApiFp(configuration).createInvoiceTags(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a migration invoice
         * @param {Array<InvoiceItem>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMigrationInvoice(body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, targetDate?: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Invoice> {
            return InvoiceApiFp(configuration).createMigrationInvoice(body, accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create tax items
         * @param {Array<InvoiceItem>} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [autoCommit] 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaxItems(body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, autoCommit?: boolean, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<InvoiceItem>> {
            return InvoiceApiFp(configuration).createTaxItems(body, accountId, xKillbillCreatedBy, autoCommit, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a CBA item
         * @param {string} invoiceId 
         * @param {string} invoiceItemId 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCBA(invoiceId: string, invoiceItemId: string, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return InvoiceApiFp(configuration).deleteCBA(invoiceId, invoiceItemId, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove custom fields from invoice
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceCustomFields(invoiceId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return InvoiceApiFp(configuration).deleteInvoiceCustomFields(invoiceId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove tags from invoice
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceTags(invoiceId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return InvoiceApiFp(configuration).deleteInvoiceTags(invoiceId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a dryRun invoice
         * @param {InvoiceDryRun} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [targetDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateDryRunInvoice(body: InvoiceDryRun, accountId: string, xKillbillCreatedBy: string, targetDate?: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Invoice> {
            return InvoiceApiFp(configuration).generateDryRunInvoice(body, accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the catalog translation for the tenant
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogTranslation(locale: string, options?: any): AxiosPromise<string> {
            return InvoiceApiFp(configuration).getCatalogTranslation(locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an invoice by id
         * @param {string} invoiceId 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice(invoiceId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Invoice> {
            return InvoiceApiFp(configuration).getInvoice(invoiceId, withChildrenItems, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Render an invoice as HTML
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAsHTML(invoiceId: string, options?: any): AxiosPromise<string> {
            return InvoiceApiFp(configuration).getInvoiceAsHTML(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve invoice audit logs with history by id
         * @param {string} invoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAuditLogsWithHistory(invoiceId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return InvoiceApiFp(configuration).getInvoiceAuditLogsWithHistory(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an invoice by invoice item id
         * @param {string} itemId 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceByItemId(itemId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Invoice> {
            return InvoiceApiFp(configuration).getInvoiceByItemId(itemId, withChildrenItems, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an invoice by number
         * @param {number} invoiceNumber 
         * @param {boolean} [withChildrenItems] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceByNumber(invoiceNumber: number, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Invoice> {
            return InvoiceApiFp(configuration).getInvoiceByNumber(invoiceNumber, withChildrenItems, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve invoice custom fields
         * @param {string} invoiceId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceCustomFields(invoiceId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return InvoiceApiFp(configuration).getInvoiceCustomFields(invoiceId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the manualPay invoice template for the tenant
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceMPTemplate(locale: string, options?: any): AxiosPromise<string> {
            return InvoiceApiFp(configuration).getInvoiceMPTemplate(locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve invoice tags
         * @param {string} invoiceId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTags(invoiceId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return InvoiceApiFp(configuration).getInvoiceTags(invoiceId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the invoice template for the tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTemplate(options?: any): AxiosPromise<string> {
            return InvoiceApiFp(configuration).getInvoiceTemplate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the invoice translation for the tenant
         * @param {string} locale 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTranslation(locale: string, options?: any): AxiosPromise<string> {
            return InvoiceApiFp(configuration).getInvoiceTranslation(locale, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List invoices
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Invoice>> {
            return InvoiceApiFp(configuration).getInvoices(offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payments associated with an invoice
         * @param {string} invoiceId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForInvoice(invoiceId: string, withPluginInfo?: boolean, withAttempts?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<InvoicePayment>> {
            return InvoiceApiFp(configuration).getPaymentsForInvoice(invoiceId, withPluginInfo, withAttempts, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify custom fields to invoice
         * @param {Array<CustomField>} body 
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoiceCustomFields(body: Array<CustomField>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return InvoiceApiFp(configuration).modifyInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search invoices
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInvoices(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Invoice>> {
            return InvoiceApiFp(configuration).searchInvoices(searchKey, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload the catalog translation for the tenant
         * @param {string} body 
         * @param {string} locale 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCatalogTranslation(body: string, locale: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<string> {
            return InvoiceApiFp(configuration).uploadCatalogTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload the manualPay invoice template for the tenant
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceMPTemplate(body: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<string> {
            return InvoiceApiFp(configuration).uploadInvoiceMPTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload the invoice template for the tenant
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceTemplate(body: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<string> {
            return InvoiceApiFp(configuration).uploadInvoiceTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload the invoice translation for the tenant
         * @param {string} body 
         * @param {string} locale 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteIfExists] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceTranslation(body: string, locale: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<string> {
            return InvoiceApiFp(configuration).uploadInvoiceTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Perform the action of voiding an invoice
         * @param {string} invoiceId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidInvoice(invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return InvoiceApiFp(configuration).voidInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoiceApi - object-oriented interface
 * @export
 * @class InvoiceApi
 * @extends {BaseAPI}
 */
export class InvoiceApi extends BaseAPI {
    /**
     * 
     * @summary Adjust an invoice item
     * @param {InvoiceItem} body 
     * @param {string} invoiceId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public adjustInvoiceItem(body: InvoiceItem, invoiceId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).adjustInvoiceItem(body, invoiceId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Perform the invoice status transition from DRAFT to COMMITTED
     * @param {string} invoiceId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public commitInvoice(invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).commitInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create external charge(s)
     * @param {Array<InvoiceItem>} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {boolean} [autoCommit] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public createExternalCharges(body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, requestedDate?: string, autoCommit?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).createExternalCharges(body, accountId, xKillbillCreatedBy, requestedDate, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger an invoice generation
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [targetDate] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public createFutureInvoice(accountId: string, xKillbillCreatedBy: string, targetDate?: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).createFutureInvoice(accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger a payment for invoice
     * @param {InvoicePayment} body 
     * @param {string} invoiceId 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [externalPayment] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public createInstantPayment(body: InvoicePayment, invoiceId: string, xKillbillCreatedBy: string, externalPayment?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).createInstantPayment(body, invoiceId, xKillbillCreatedBy, externalPayment, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add custom fields to invoice
     * @param {Array<CustomField>} body 
     * @param {string} invoiceId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public createInvoiceCustomFields(body: Array<CustomField>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).createInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add tags to invoice
     * @param {Array<string>} body 
     * @param {string} invoiceId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public createInvoiceTags(body: Array<string>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).createInvoiceTags(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a migration invoice
     * @param {Array<InvoiceItem>} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [targetDate] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public createMigrationInvoice(body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, targetDate?: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).createMigrationInvoice(body, accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create tax items
     * @param {Array<InvoiceItem>} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [autoCommit] 
     * @param {string} [requestedDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public createTaxItems(body: Array<InvoiceItem>, accountId: string, xKillbillCreatedBy: string, autoCommit?: boolean, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).createTaxItems(body, accountId, xKillbillCreatedBy, autoCommit, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a CBA item
     * @param {string} invoiceId 
     * @param {string} invoiceItemId 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public deleteCBA(invoiceId: string, invoiceItemId: string, accountId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).deleteCBA(invoiceId, invoiceItemId, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove custom fields from invoice
     * @param {string} invoiceId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [customField] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public deleteInvoiceCustomFields(invoiceId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).deleteInvoiceCustomFields(invoiceId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove tags from invoice
     * @param {string} invoiceId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [tagDef] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public deleteInvoiceTags(invoiceId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).deleteInvoiceTags(invoiceId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a dryRun invoice
     * @param {InvoiceDryRun} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [targetDate] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public generateDryRunInvoice(body: InvoiceDryRun, accountId: string, xKillbillCreatedBy: string, targetDate?: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).generateDryRunInvoice(body, accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the catalog translation for the tenant
     * @param {string} locale 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getCatalogTranslation(locale: string, options?: any) {
        return InvoiceApiFp(this.configuration).getCatalogTranslation(locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an invoice by id
     * @param {string} invoiceId 
     * @param {boolean} [withChildrenItems] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoice(invoiceId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return InvoiceApiFp(this.configuration).getInvoice(invoiceId, withChildrenItems, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Render an invoice as HTML
     * @param {string} invoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceAsHTML(invoiceId: string, options?: any) {
        return InvoiceApiFp(this.configuration).getInvoiceAsHTML(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve invoice audit logs with history by id
     * @param {string} invoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceAuditLogsWithHistory(invoiceId: string, options?: any) {
        return InvoiceApiFp(this.configuration).getInvoiceAuditLogsWithHistory(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an invoice by invoice item id
     * @param {string} itemId 
     * @param {boolean} [withChildrenItems] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceByItemId(itemId: string, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return InvoiceApiFp(this.configuration).getInvoiceByItemId(itemId, withChildrenItems, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an invoice by number
     * @param {number} invoiceNumber 
     * @param {boolean} [withChildrenItems] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceByNumber(invoiceNumber: number, withChildrenItems?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return InvoiceApiFp(this.configuration).getInvoiceByNumber(invoiceNumber, withChildrenItems, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve invoice custom fields
     * @param {string} invoiceId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceCustomFields(invoiceId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return InvoiceApiFp(this.configuration).getInvoiceCustomFields(invoiceId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the manualPay invoice template for the tenant
     * @param {string} locale 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceMPTemplate(locale: string, options?: any) {
        return InvoiceApiFp(this.configuration).getInvoiceMPTemplate(locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve invoice tags
     * @param {string} invoiceId 
     * @param {boolean} [includedDeleted] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceTags(invoiceId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return InvoiceApiFp(this.configuration).getInvoiceTags(invoiceId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the invoice template for the tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceTemplate(options?: any) {
        return InvoiceApiFp(this.configuration).getInvoiceTemplate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the invoice translation for the tenant
     * @param {string} locale 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceTranslation(locale: string, options?: any) {
        return InvoiceApiFp(this.configuration).getInvoiceTranslation(locale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List invoices
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoices(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return InvoiceApiFp(this.configuration).getInvoices(offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payments associated with an invoice
     * @param {string} invoiceId 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [withAttempts] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getPaymentsForInvoice(invoiceId: string, withPluginInfo?: boolean, withAttempts?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return InvoiceApiFp(this.configuration).getPaymentsForInvoice(invoiceId, withPluginInfo, withAttempts, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify custom fields to invoice
     * @param {Array<CustomField>} body 
     * @param {string} invoiceId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public modifyInvoiceCustomFields(body: Array<CustomField>, invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).modifyInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search invoices
     * @param {string} searchKey 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public searchInvoices(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return InvoiceApiFp(this.configuration).searchInvoices(searchKey, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload the catalog translation for the tenant
     * @param {string} body 
     * @param {string} locale 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [deleteIfExists] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public uploadCatalogTranslation(body: string, locale: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).uploadCatalogTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload the manualPay invoice template for the tenant
     * @param {string} body 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [deleteIfExists] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public uploadInvoiceMPTemplate(body: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).uploadInvoiceMPTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload the invoice template for the tenant
     * @param {string} body 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [deleteIfExists] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public uploadInvoiceTemplate(body: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).uploadInvoiceTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload the invoice translation for the tenant
     * @param {string} body 
     * @param {string} locale 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [deleteIfExists] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public uploadInvoiceTranslation(body: string, locale: string, xKillbillCreatedBy: string, deleteIfExists?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).uploadInvoiceTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Perform the action of voiding an invoice
     * @param {string} invoiceId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public voidInvoice(invoiceId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceApiFp(this.configuration).voidInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * InvoiceItemApi - axios parameter creator
 * @export
 */
export const InvoiceItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add custom fields to invoice item
         * @param {Array<CustomField>} body 
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceItemCustomFields: async (body: Array<CustomField>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createInvoiceItemCustomFields.');
            }
            // verify required parameter 'invoiceItemId' is not null or undefined
            if (invoiceItemId === null || invoiceItemId === undefined) {
                throw new RequiredError('invoiceItemId','Required parameter invoiceItemId was null or undefined when calling createInvoiceItemCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createInvoiceItemCustomFields.');
            }
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/customFields`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add tags to invoice item
         * @param {Array<string>} body 
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceItemTags: async (body: Array<string>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createInvoiceItemTags.');
            }
            // verify required parameter 'invoiceItemId' is not null or undefined
            if (invoiceItemId === null || invoiceItemId === undefined) {
                throw new RequiredError('invoiceItemId','Required parameter invoiceItemId was null or undefined when calling createInvoiceItemTags.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createInvoiceItemTags.');
            }
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/tags`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove custom fields from invoice item
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceItemCustomFields: async (invoiceItemId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceItemId' is not null or undefined
            if (invoiceItemId === null || invoiceItemId === undefined) {
                throw new RequiredError('invoiceItemId','Required parameter invoiceItemId was null or undefined when calling deleteInvoiceItemCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deleteInvoiceItemCustomFields.');
            }
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/customFields`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove tags from invoice item
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceItemTags: async (invoiceItemId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceItemId' is not null or undefined
            if (invoiceItemId === null || invoiceItemId === undefined) {
                throw new RequiredError('invoiceItemId','Required parameter invoiceItemId was null or undefined when calling deleteInvoiceItemTags.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deleteInvoiceItemTags.');
            }
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/tags`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve invoice item audit logs with history by id
         * @param {string} invoiceItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemAuditLogsWithHistory: async (invoiceItemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceItemId' is not null or undefined
            if (invoiceItemId === null || invoiceItemId === undefined) {
                throw new RequiredError('invoiceItemId','Required parameter invoiceItemId was null or undefined when calling getInvoiceItemAuditLogsWithHistory.');
            }
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/auditLogsWithHistory`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve invoice item custom fields
         * @param {string} invoiceItemId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemCustomFields: async (invoiceItemId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceItemId' is not null or undefined
            if (invoiceItemId === null || invoiceItemId === undefined) {
                throw new RequiredError('invoiceItemId','Required parameter invoiceItemId was null or undefined when calling getInvoiceItemCustomFields.');
            }
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/customFields`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve invoice item tags
         * @param {string} invoiceItemId 
         * @param {string} accountId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemTags: async (invoiceItemId: string, accountId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceItemId' is not null or undefined
            if (invoiceItemId === null || invoiceItemId === undefined) {
                throw new RequiredError('invoiceItemId','Required parameter invoiceItemId was null or undefined when calling getInvoiceItemTags.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling getInvoiceItemTags.');
            }
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/tags`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify custom fields to invoice item
         * @param {Array<CustomField>} body 
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoiceItemCustomFields: async (body: Array<CustomField>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling modifyInvoiceItemCustomFields.');
            }
            // verify required parameter 'invoiceItemId' is not null or undefined
            if (invoiceItemId === null || invoiceItemId === undefined) {
                throw new RequiredError('invoiceItemId','Required parameter invoiceItemId was null or undefined when calling modifyInvoiceItemCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling modifyInvoiceItemCustomFields.');
            }
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/customFields`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceItemApi - functional programming interface
 * @export
 */
export const InvoiceItemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add custom fields to invoice item
         * @param {Array<CustomField>} body 
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoiceItemCustomFields(body: Array<CustomField>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await InvoiceItemApiAxiosParamCreator(configuration).createInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add tags to invoice item
         * @param {Array<string>} body 
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoiceItemTags(body: Array<string>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await InvoiceItemApiAxiosParamCreator(configuration).createInvoiceItemTags(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove custom fields from invoice item
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoiceItemCustomFields(invoiceItemId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InvoiceItemApiAxiosParamCreator(configuration).deleteInvoiceItemCustomFields(invoiceItemId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove tags from invoice item
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoiceItemTags(invoiceItemId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InvoiceItemApiAxiosParamCreator(configuration).deleteInvoiceItemTags(invoiceItemId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve invoice item audit logs with history by id
         * @param {string} invoiceItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceItemAuditLogsWithHistory(invoiceItemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await InvoiceItemApiAxiosParamCreator(configuration).getInvoiceItemAuditLogsWithHistory(invoiceItemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve invoice item custom fields
         * @param {string} invoiceItemId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceItemCustomFields(invoiceItemId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await InvoiceItemApiAxiosParamCreator(configuration).getInvoiceItemCustomFields(invoiceItemId, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve invoice item tags
         * @param {string} invoiceItemId 
         * @param {string} accountId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceItemTags(invoiceItemId: string, accountId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await InvoiceItemApiAxiosParamCreator(configuration).getInvoiceItemTags(invoiceItemId, accountId, includedDeleted, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify custom fields to invoice item
         * @param {Array<CustomField>} body 
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyInvoiceItemCustomFields(body: Array<CustomField>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InvoiceItemApiAxiosParamCreator(configuration).modifyInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InvoiceItemApi - factory interface
 * @export
 */
export const InvoiceItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Add custom fields to invoice item
         * @param {Array<CustomField>} body 
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceItemCustomFields(body: Array<CustomField>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<CustomField>> {
            return InvoiceItemApiFp(configuration).createInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add tags to invoice item
         * @param {Array<string>} body 
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceItemTags(body: Array<string>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<Tag>> {
            return InvoiceItemApiFp(configuration).createInvoiceItemTags(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove custom fields from invoice item
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceItemCustomFields(invoiceItemId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return InvoiceItemApiFp(configuration).deleteInvoiceItemCustomFields(invoiceItemId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove tags from invoice item
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceItemTags(invoiceItemId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return InvoiceItemApiFp(configuration).deleteInvoiceItemTags(invoiceItemId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve invoice item audit logs with history by id
         * @param {string} invoiceItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemAuditLogsWithHistory(invoiceItemId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return InvoiceItemApiFp(configuration).getInvoiceItemAuditLogsWithHistory(invoiceItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve invoice item custom fields
         * @param {string} invoiceItemId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemCustomFields(invoiceItemId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return InvoiceItemApiFp(configuration).getInvoiceItemCustomFields(invoiceItemId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve invoice item tags
         * @param {string} invoiceItemId 
         * @param {string} accountId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemTags(invoiceItemId: string, accountId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return InvoiceItemApiFp(configuration).getInvoiceItemTags(invoiceItemId, accountId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify custom fields to invoice item
         * @param {Array<CustomField>} body 
         * @param {string} invoiceItemId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoiceItemCustomFields(body: Array<CustomField>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return InvoiceItemApiFp(configuration).modifyInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoiceItemApi - object-oriented interface
 * @export
 * @class InvoiceItemApi
 * @extends {BaseAPI}
 */
export class InvoiceItemApi extends BaseAPI {
    /**
     * 
     * @summary Add custom fields to invoice item
     * @param {Array<CustomField>} body 
     * @param {string} invoiceItemId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    public createInvoiceItemCustomFields(body: Array<CustomField>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceItemApiFp(this.configuration).createInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add tags to invoice item
     * @param {Array<string>} body 
     * @param {string} invoiceItemId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    public createInvoiceItemTags(body: Array<string>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceItemApiFp(this.configuration).createInvoiceItemTags(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove custom fields from invoice item
     * @param {string} invoiceItemId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [customField] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    public deleteInvoiceItemCustomFields(invoiceItemId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceItemApiFp(this.configuration).deleteInvoiceItemCustomFields(invoiceItemId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove tags from invoice item
     * @param {string} invoiceItemId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [tagDef] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    public deleteInvoiceItemTags(invoiceItemId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceItemApiFp(this.configuration).deleteInvoiceItemTags(invoiceItemId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve invoice item audit logs with history by id
     * @param {string} invoiceItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    public getInvoiceItemAuditLogsWithHistory(invoiceItemId: string, options?: any) {
        return InvoiceItemApiFp(this.configuration).getInvoiceItemAuditLogsWithHistory(invoiceItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve invoice item custom fields
     * @param {string} invoiceItemId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    public getInvoiceItemCustomFields(invoiceItemId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return InvoiceItemApiFp(this.configuration).getInvoiceItemCustomFields(invoiceItemId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve invoice item tags
     * @param {string} invoiceItemId 
     * @param {string} accountId 
     * @param {boolean} [includedDeleted] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    public getInvoiceItemTags(invoiceItemId: string, accountId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return InvoiceItemApiFp(this.configuration).getInvoiceItemTags(invoiceItemId, accountId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify custom fields to invoice item
     * @param {Array<CustomField>} body 
     * @param {string} invoiceItemId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    public modifyInvoiceItemCustomFields(body: Array<CustomField>, invoiceItemId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoiceItemApiFp(this.configuration).modifyInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * InvoicePaymentApi - axios parameter creator
 * @export
 */
export const InvoicePaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeInvoicePaymentTransaction: async (body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling completeInvoicePaymentTransaction.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling completeInvoicePaymentTransaction.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling completeInvoicePaymentTransaction.');
            }
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record a chargeback
         * @param {InvoicePaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChargeback: async (body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createChargeback.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling createChargeback.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createChargeback.');
            }
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/chargebacks`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record a chargebackReversal
         * @param {InvoicePaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChargebackReversal: async (body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createChargebackReversal.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling createChargebackReversal.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createChargebackReversal.');
            }
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/chargebackReversals`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoicePaymentCustomFields: async (body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createInvoicePaymentCustomFields.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling createInvoicePaymentCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createInvoicePaymentCustomFields.');
            }
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add tags to payment
         * @param {Array<string>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoicePaymentTags: async (body: Array<string>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createInvoicePaymentTags.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling createInvoicePaymentTags.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createInvoicePaymentTags.');
            }
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/tags`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refund a payment, and adjust the invoice if needed
         * @param {InvoicePaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [externalPayment] 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefundWithAdjustments: async (body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, externalPayment?: boolean, paymentMethodId?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRefundWithAdjustments.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling createRefundWithAdjustments.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createRefundWithAdjustments.');
            }
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/refunds`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (externalPayment !== undefined) {
                localVarQueryParameter['externalPayment'] = externalPayment;
            }

            if (paymentMethodId !== undefined) {
                localVarQueryParameter['paymentMethodId'] = paymentMethodId;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove custom fields from payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoicePaymentCustomFields: async (paymentId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling deleteInvoicePaymentCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deleteInvoicePaymentCustomFields.');
            }
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove tags from payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoicePaymentTags: async (paymentId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling deleteInvoicePaymentTags.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deleteInvoicePaymentTags.');
            }
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/tags`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a payment by id
         * @param {string} paymentId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePayment: async (paymentId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling getInvoicePayment.');
            }
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve invoice payment audit logs with history by id
         * @param {string} invoicePaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentAuditLogsWithHistory: async (invoicePaymentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoicePaymentId' is not null or undefined
            if (invoicePaymentId === null || invoicePaymentId === undefined) {
                throw new RequiredError('invoicePaymentId','Required parameter invoicePaymentId was null or undefined when calling getInvoicePaymentAuditLogsWithHistory.');
            }
            const localVarPath = `/1.0/kb/invoicePayments/{invoicePaymentId}/auditLogsWithHistory`
                .replace(`{${"invoicePaymentId"}}`, encodeURIComponent(String(invoicePaymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment custom fields
         * @param {string} paymentId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentCustomFields: async (paymentId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling getInvoicePaymentCustomFields.');
            }
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment tags
         * @param {string} paymentId 
         * @param {boolean} [includedDeleted] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentTags: async (paymentId: string, includedDeleted?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling getInvoicePaymentTags.');
            }
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/tags`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoicePaymentCustomFields: async (body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling modifyInvoicePaymentCustomFields.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling modifyInvoicePaymentCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling modifyInvoicePaymentCustomFields.');
            }
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicePaymentApi - functional programming interface
 * @export
 */
export const InvoicePaymentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeInvoicePaymentTransaction(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InvoicePaymentApiAxiosParamCreator(configuration).completeInvoicePaymentTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Record a chargeback
         * @param {InvoicePaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChargeback(body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoicePayment>> {
            const localVarAxiosArgs = await InvoicePaymentApiAxiosParamCreator(configuration).createChargeback(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Record a chargebackReversal
         * @param {InvoicePaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChargebackReversal(body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoicePayment>> {
            const localVarAxiosArgs = await InvoicePaymentApiAxiosParamCreator(configuration).createChargebackReversal(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoicePaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await InvoicePaymentApiAxiosParamCreator(configuration).createInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add tags to payment
         * @param {Array<string>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoicePaymentTags(body: Array<string>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await InvoicePaymentApiAxiosParamCreator(configuration).createInvoicePaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Refund a payment, and adjust the invoice if needed
         * @param {InvoicePaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [externalPayment] 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRefundWithAdjustments(body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, externalPayment?: boolean, paymentMethodId?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoicePayment>> {
            const localVarAxiosArgs = await InvoicePaymentApiAxiosParamCreator(configuration).createRefundWithAdjustments(body, paymentId, xKillbillCreatedBy, externalPayment, paymentMethodId, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove custom fields from payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoicePaymentCustomFields(paymentId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InvoicePaymentApiAxiosParamCreator(configuration).deleteInvoicePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove tags from payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoicePaymentTags(paymentId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InvoicePaymentApiAxiosParamCreator(configuration).deleteInvoicePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a payment by id
         * @param {string} paymentId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoicePayment(paymentId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoicePayment>> {
            const localVarAxiosArgs = await InvoicePaymentApiAxiosParamCreator(configuration).getInvoicePayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve invoice payment audit logs with history by id
         * @param {string} invoicePaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoicePaymentAuditLogsWithHistory(invoicePaymentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await InvoicePaymentApiAxiosParamCreator(configuration).getInvoicePaymentAuditLogsWithHistory(invoicePaymentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve payment custom fields
         * @param {string} paymentId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoicePaymentCustomFields(paymentId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await InvoicePaymentApiAxiosParamCreator(configuration).getInvoicePaymentCustomFields(paymentId, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve payment tags
         * @param {string} paymentId 
         * @param {boolean} [includedDeleted] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoicePaymentTags(paymentId: string, includedDeleted?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await InvoicePaymentApiAxiosParamCreator(configuration).getInvoicePaymentTags(paymentId, includedDeleted, pluginProperty, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyInvoicePaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InvoicePaymentApiAxiosParamCreator(configuration).modifyInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InvoicePaymentApi - factory interface
 * @export
 */
export const InvoicePaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeInvoicePaymentTransaction(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return InvoicePaymentApiFp(configuration).completeInvoicePaymentTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Record a chargeback
         * @param {InvoicePaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChargeback(body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<InvoicePayment> {
            return InvoicePaymentApiFp(configuration).createChargeback(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Record a chargebackReversal
         * @param {InvoicePaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChargebackReversal(body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<InvoicePayment> {
            return InvoicePaymentApiFp(configuration).createChargebackReversal(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoicePaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<CustomField>> {
            return InvoicePaymentApiFp(configuration).createInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add tags to payment
         * @param {Array<string>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoicePaymentTags(body: Array<string>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<Tag>> {
            return InvoicePaymentApiFp(configuration).createInvoicePaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refund a payment, and adjust the invoice if needed
         * @param {InvoicePaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [externalPayment] 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefundWithAdjustments(body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, externalPayment?: boolean, paymentMethodId?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<InvoicePayment> {
            return InvoicePaymentApiFp(configuration).createRefundWithAdjustments(body, paymentId, xKillbillCreatedBy, externalPayment, paymentMethodId, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove custom fields from payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoicePaymentCustomFields(paymentId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return InvoicePaymentApiFp(configuration).deleteInvoicePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove tags from payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoicePaymentTags(paymentId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return InvoicePaymentApiFp(configuration).deleteInvoicePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a payment by id
         * @param {string} paymentId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePayment(paymentId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<InvoicePayment> {
            return InvoicePaymentApiFp(configuration).getInvoicePayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve invoice payment audit logs with history by id
         * @param {string} invoicePaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentAuditLogsWithHistory(invoicePaymentId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return InvoicePaymentApiFp(configuration).getInvoicePaymentAuditLogsWithHistory(invoicePaymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment custom fields
         * @param {string} paymentId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentCustomFields(paymentId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return InvoicePaymentApiFp(configuration).getInvoicePaymentCustomFields(paymentId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment tags
         * @param {string} paymentId 
         * @param {boolean} [includedDeleted] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentTags(paymentId: string, includedDeleted?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return InvoicePaymentApiFp(configuration).getInvoicePaymentTags(paymentId, includedDeleted, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoicePaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return InvoicePaymentApiFp(configuration).modifyInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoicePaymentApi - object-oriented interface
 * @export
 * @class InvoicePaymentApi
 * @extends {BaseAPI}
 */
export class InvoicePaymentApi extends BaseAPI {
    /**
     * 
     * @summary Complete an existing transaction
     * @param {PaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public completeInvoicePaymentTransaction(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoicePaymentApiFp(this.configuration).completeInvoicePaymentTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Record a chargeback
     * @param {InvoicePaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public createChargeback(body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoicePaymentApiFp(this.configuration).createChargeback(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Record a chargebackReversal
     * @param {InvoicePaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public createChargebackReversal(body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoicePaymentApiFp(this.configuration).createChargebackReversal(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add custom fields to payment
     * @param {Array<CustomField>} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public createInvoicePaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoicePaymentApiFp(this.configuration).createInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add tags to payment
     * @param {Array<string>} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public createInvoicePaymentTags(body: Array<string>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoicePaymentApiFp(this.configuration).createInvoicePaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refund a payment, and adjust the invoice if needed
     * @param {InvoicePaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [externalPayment] 
     * @param {string} [paymentMethodId] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public createRefundWithAdjustments(body: InvoicePaymentTransaction, paymentId: string, xKillbillCreatedBy: string, externalPayment?: boolean, paymentMethodId?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoicePaymentApiFp(this.configuration).createRefundWithAdjustments(body, paymentId, xKillbillCreatedBy, externalPayment, paymentMethodId, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove custom fields from payment
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [customField] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public deleteInvoicePaymentCustomFields(paymentId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoicePaymentApiFp(this.configuration).deleteInvoicePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove tags from payment
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [tagDef] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public deleteInvoicePaymentTags(paymentId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoicePaymentApiFp(this.configuration).deleteInvoicePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a payment by id
     * @param {string} paymentId 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [withAttempts] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public getInvoicePayment(paymentId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return InvoicePaymentApiFp(this.configuration).getInvoicePayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve invoice payment audit logs with history by id
     * @param {string} invoicePaymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public getInvoicePaymentAuditLogsWithHistory(invoicePaymentId: string, options?: any) {
        return InvoicePaymentApiFp(this.configuration).getInvoicePaymentAuditLogsWithHistory(invoicePaymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment custom fields
     * @param {string} paymentId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public getInvoicePaymentCustomFields(paymentId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return InvoicePaymentApiFp(this.configuration).getInvoicePaymentCustomFields(paymentId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment tags
     * @param {string} paymentId 
     * @param {boolean} [includedDeleted] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public getInvoicePaymentTags(paymentId: string, includedDeleted?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return InvoicePaymentApiFp(this.configuration).getInvoicePaymentTags(paymentId, includedDeleted, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify custom fields to payment
     * @param {Array<CustomField>} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    public modifyInvoicePaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return InvoicePaymentApiFp(this.configuration).modifyInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * NodesInfoApi - axios parameter creator
 * @export
 */
export const NodesInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve all the nodes infos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodesInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/nodesInfo`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger a node command
         * @param {NodeCommand} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [localNodeOnly] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerNodeCommand: async (body: NodeCommand, xKillbillCreatedBy: string, localNodeOnly?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling triggerNodeCommand.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling triggerNodeCommand.');
            }
            const localVarPath = `/1.0/kb/nodesInfo`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (localNodeOnly !== undefined) {
                localVarQueryParameter['localNodeOnly'] = localNodeOnly;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodesInfoApi - functional programming interface
 * @export
 */
export const NodesInfoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve all the nodes infos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodesInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PluginInfo>>> {
            const localVarAxiosArgs = await NodesInfoApiAxiosParamCreator(configuration).getNodesInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Trigger a node command
         * @param {NodeCommand} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [localNodeOnly] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerNodeCommand(body: NodeCommand, xKillbillCreatedBy: string, localNodeOnly?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NodesInfoApiAxiosParamCreator(configuration).triggerNodeCommand(body, xKillbillCreatedBy, localNodeOnly, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NodesInfoApi - factory interface
 * @export
 */
export const NodesInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Retrieve all the nodes infos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodesInfo(options?: any): AxiosPromise<Array<PluginInfo>> {
            return NodesInfoApiFp(configuration).getNodesInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Trigger a node command
         * @param {NodeCommand} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [localNodeOnly] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerNodeCommand(body: NodeCommand, xKillbillCreatedBy: string, localNodeOnly?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return NodesInfoApiFp(configuration).triggerNodeCommand(body, xKillbillCreatedBy, localNodeOnly, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodesInfoApi - object-oriented interface
 * @export
 * @class NodesInfoApi
 * @extends {BaseAPI}
 */
export class NodesInfoApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve all the nodes infos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesInfoApi
     */
    public getNodesInfo(options?: any) {
        return NodesInfoApiFp(this.configuration).getNodesInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Trigger a node command
     * @param {NodeCommand} body 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [localNodeOnly] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesInfoApi
     */
    public triggerNodeCommand(body: NodeCommand, xKillbillCreatedBy: string, localNodeOnly?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return NodesInfoApiFp(this.configuration).triggerNodeCommand(body, xKillbillCreatedBy, localNodeOnly, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * OverdueApi - axios parameter creator
 * @export
 */
export const OverdueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the overdue config as JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueConfigJson: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/overdue`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the overdue config as XML
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueConfigXml: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/overdue/xml`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload the full overdue config as JSON
         * @param {Overdue} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOverdueConfigJson: async (body: Overdue, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadOverdueConfigJson.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling uploadOverdueConfigJson.');
            }
            const localVarPath = `/1.0/kb/overdue`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload the full overdue config as XML
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOverdueConfigXml: async (body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadOverdueConfigXml.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling uploadOverdueConfigXml.');
            }
            const localVarPath = `/1.0/kb/overdue/xml`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/xml';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OverdueApi - functional programming interface
 * @export
 */
export const OverdueApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the overdue config as JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOverdueConfigJson(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Overdue>> {
            const localVarAxiosArgs = await OverdueApiAxiosParamCreator(configuration).getOverdueConfigJson(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve the overdue config as XML
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOverdueConfigXml(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await OverdueApiAxiosParamCreator(configuration).getOverdueConfigXml(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Upload the full overdue config as JSON
         * @param {Overdue} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadOverdueConfigJson(body: Overdue, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Overdue>> {
            const localVarAxiosArgs = await OverdueApiAxiosParamCreator(configuration).uploadOverdueConfigJson(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Upload the full overdue config as XML
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadOverdueConfigXml(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await OverdueApiAxiosParamCreator(configuration).uploadOverdueConfigXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OverdueApi - factory interface
 * @export
 */
export const OverdueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Retrieve the overdue config as JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueConfigJson(options?: any): AxiosPromise<Overdue> {
            return OverdueApiFp(configuration).getOverdueConfigJson(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the overdue config as XML
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueConfigXml(options?: any): AxiosPromise<string> {
            return OverdueApiFp(configuration).getOverdueConfigXml(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload the full overdue config as JSON
         * @param {Overdue} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOverdueConfigJson(body: Overdue, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Overdue> {
            return OverdueApiFp(configuration).uploadOverdueConfigJson(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload the full overdue config as XML
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOverdueConfigXml(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<string> {
            return OverdueApiFp(configuration).uploadOverdueConfigXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OverdueApi - object-oriented interface
 * @export
 * @class OverdueApi
 * @extends {BaseAPI}
 */
export class OverdueApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the overdue config as JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverdueApi
     */
    public getOverdueConfigJson(options?: any) {
        return OverdueApiFp(this.configuration).getOverdueConfigJson(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the overdue config as XML
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverdueApi
     */
    public getOverdueConfigXml(options?: any) {
        return OverdueApiFp(this.configuration).getOverdueConfigXml(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload the full overdue config as JSON
     * @param {Overdue} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverdueApi
     */
    public uploadOverdueConfigJson(body: Overdue, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return OverdueApiFp(this.configuration).uploadOverdueConfigJson(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload the full overdue config as XML
     * @param {string} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverdueApi
     */
    public uploadOverdueConfigXml(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return OverdueApiFp(this.configuration).uploadOverdueConfigXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * PaymentApi - axios parameter creator
 * @export
 */
export const PaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancels a scheduled payment attempt retry
         * @param {string} transactionExternalKey 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelScheduledPaymentTransactionByExternalKey: async (transactionExternalKey: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionExternalKey' is not null or undefined
            if (transactionExternalKey === null || transactionExternalKey === undefined) {
                throw new RequiredError('transactionExternalKey','Required parameter transactionExternalKey was null or undefined when calling cancelScheduledPaymentTransactionByExternalKey.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling cancelScheduledPaymentTransactionByExternalKey.');
            }
            const localVarPath = `/1.0/kb/payments/cancelScheduledPaymentTransaction`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (transactionExternalKey !== undefined) {
                localVarQueryParameter['transactionExternalKey'] = transactionExternalKey;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancels a scheduled payment attempt retry
         * @param {string} paymentTransactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelScheduledPaymentTransactionById: async (paymentTransactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentTransactionId' is not null or undefined
            if (paymentTransactionId === null || paymentTransactionId === undefined) {
                throw new RequiredError('paymentTransactionId','Required parameter paymentTransactionId was null or undefined when calling cancelScheduledPaymentTransactionById.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling cancelScheduledPaymentTransactionById.');
            }
            const localVarPath = `/1.0/kb/payments/{paymentTransactionId}/cancelScheduledPaymentTransaction`
                .replace(`{${"paymentTransactionId"}}`, encodeURIComponent(String(paymentTransactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Capture an existing authorization
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureAuthorization: async (body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling captureAuthorization.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling captureAuthorization.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling captureAuthorization.');
            }
            const localVarPath = `/1.0/kb/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Capture an existing authorization
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureAuthorizationByExternalKey: async (body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling captureAuthorizationByExternalKey.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling captureAuthorizationByExternalKey.');
            }
            const localVarPath = `/1.0/kb/payments`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record a chargeback
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackPayment: async (body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling chargebackPayment.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling chargebackPayment.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling chargebackPayment.');
            }
            const localVarPath = `/1.0/kb/payments/{paymentId}/chargebacks`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record a chargeback
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackPaymentByExternalKey: async (body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling chargebackPaymentByExternalKey.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling chargebackPaymentByExternalKey.');
            }
            const localVarPath = `/1.0/kb/payments/chargebacks`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record a chargeback reversal
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackReversalPayment: async (body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling chargebackReversalPayment.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling chargebackReversalPayment.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling chargebackReversalPayment.');
            }
            const localVarPath = `/1.0/kb/payments/{paymentId}/chargebackReversals`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record a chargeback reversal
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackReversalPaymentByExternalKey: async (body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling chargebackReversalPaymentByExternalKey.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling chargebackReversalPaymentByExternalKey.');
            }
            const localVarPath = `/1.0/kb/payments/chargebackReversals`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTransaction: async (body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling completeTransaction.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling completeTransaction.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling completeTransaction.');
            }
            const localVarPath = `/1.0/kb/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTransactionByExternalKey: async (body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling completeTransactionByExternalKey.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling completeTransactionByExternalKey.');
            }
            const localVarPath = `/1.0/kb/payments`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Combo api to create a new payment transaction on a existing (or not) account 
         * @param {ComboPaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComboPayment: async (body: ComboPaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createComboPayment.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createComboPayment.');
            }
            const localVarPath = `/1.0/kb/payments/combo`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentCustomFields: async (body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPaymentCustomFields.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling createPaymentCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createPaymentCustomFields.');
            }
            const localVarPath = `/1.0/kb/payments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add tags to payment payment
         * @param {Array<string>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentTags: async (body: Array<string>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPaymentTags.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling createPaymentTags.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createPaymentTags.');
            }
            const localVarPath = `/1.0/kb/payments/{paymentId}/tags`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove custom fields from payment payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentCustomFields: async (paymentId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling deletePaymentCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deletePaymentCustomFields.');
            }
            const localVarPath = `/1.0/kb/payments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove tags from payment payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentTags: async (paymentId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling deletePaymentTags.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deletePaymentTags.');
            }
            const localVarPath = `/1.0/kb/payments/{paymentId}/tags`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a payment by id
         * @param {string} paymentId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment: async (paymentId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling getPayment.');
            }
            const localVarPath = `/1.0/kb/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment attempt audit logs with history by id
         * @param {string} paymentAttemptId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentAttemptAuditLogsWithHistory: async (paymentAttemptId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentAttemptId' is not null or undefined
            if (paymentAttemptId === null || paymentAttemptId === undefined) {
                throw new RequiredError('paymentAttemptId','Required parameter paymentAttemptId was null or undefined when calling getPaymentAttemptAuditLogsWithHistory.');
            }
            const localVarPath = `/1.0/kb/payments/attempts/{paymentAttemptId}/auditLogsWithHistory`
                .replace(`{${"paymentAttemptId"}}`, encodeURIComponent(String(paymentAttemptId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment audit logs with history by id
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentAuditLogsWithHistory: async (paymentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling getPaymentAuditLogsWithHistory.');
            }
            const localVarPath = `/1.0/kb/payments/{paymentId}/auditLogsWithHistory`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a payment by external key
         * @param {string} externalKey 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByExternalKey: async (externalKey: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalKey' is not null or undefined
            if (externalKey === null || externalKey === undefined) {
                throw new RequiredError('externalKey','Required parameter externalKey was null or undefined when calling getPaymentByExternalKey.');
            }
            const localVarPath = `/1.0/kb/payments`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment custom fields
         * @param {string} paymentId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentCustomFields: async (paymentId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling getPaymentCustomFields.');
            }
            const localVarPath = `/1.0/kb/payments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment payment tags
         * @param {string} paymentId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentTags: async (paymentId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling getPaymentTags.');
            }
            const localVarPath = `/1.0/kb/payments/{paymentId}/tags`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get payments
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [pluginName] 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayments: async (offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/payments/pagination`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (pluginName !== undefined) {
                localVarQueryParameter['pluginName'] = pluginName;
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPaymentCustomFields: async (body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling modifyPaymentCustomFields.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling modifyPaymentCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling modifyPaymentCustomFields.');
            }
            const localVarPath = `/1.0/kb/payments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refund an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment: async (body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling refundPayment.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling refundPayment.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling refundPayment.');
            }
            const localVarPath = `/1.0/kb/payments/{paymentId}/refunds`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refund an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPaymentByExternalKey: async (body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling refundPaymentByExternalKey.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling refundPaymentByExternalKey.');
            }
            const localVarPath = `/1.0/kb/payments/refunds`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search payments
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {string} [pluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPayments: async (searchKey: string, offset?: number, limit?: number, withPluginInfo?: boolean, withAttempts?: boolean, pluginName?: string, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            if (searchKey === null || searchKey === undefined) {
                throw new RequiredError('searchKey','Required parameter searchKey was null or undefined when calling searchPayments.');
            }
            const localVarPath = `/1.0/kb/payments/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (pluginName !== undefined) {
                localVarQueryParameter['pluginName'] = pluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Void an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidPayment: async (body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling voidPayment.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling voidPayment.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling voidPayment.');
            }
            const localVarPath = `/1.0/kb/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Void an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidPaymentByExternalKey: async (body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling voidPaymentByExternalKey.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling voidPaymentByExternalKey.');
            }
            const localVarPath = `/1.0/kb/payments`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentApi - functional programming interface
 * @export
 */
export const PaymentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancels a scheduled payment attempt retry
         * @param {string} transactionExternalKey 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelScheduledPaymentTransactionByExternalKey(transactionExternalKey: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).cancelScheduledPaymentTransactionByExternalKey(transactionExternalKey, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Cancels a scheduled payment attempt retry
         * @param {string} paymentTransactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelScheduledPaymentTransactionById(paymentTransactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).cancelScheduledPaymentTransactionById(paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Capture an existing authorization
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async captureAuthorization(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).captureAuthorization(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Capture an existing authorization
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async captureAuthorizationByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).captureAuthorizationByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Record a chargeback
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chargebackPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).chargebackPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Record a chargeback
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chargebackPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).chargebackPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Record a chargeback reversal
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chargebackReversalPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).chargebackReversalPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Record a chargeback reversal
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chargebackReversalPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).chargebackReversalPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeTransaction(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).completeTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeTransactionByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).completeTransactionByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Combo api to create a new payment transaction on a existing (or not) account 
         * @param {ComboPaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createComboPayment(body: ComboPaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).createComboPayment(body, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).createPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add tags to payment payment
         * @param {Array<string>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentTags(body: Array<string>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).createPaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove custom fields from payment payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentCustomFields(paymentId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).deletePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove tags from payment payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentTags(paymentId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).deletePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a payment by id
         * @param {string} paymentId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayment(paymentId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).getPayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve payment attempt audit logs with history by id
         * @param {string} paymentAttemptId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentAttemptAuditLogsWithHistory(paymentAttemptId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).getPaymentAttemptAuditLogsWithHistory(paymentAttemptId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve payment audit logs with history by id
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentAuditLogsWithHistory(paymentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).getPaymentAuditLogsWithHistory(paymentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a payment by external key
         * @param {string} externalKey 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentByExternalKey(externalKey: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).getPaymentByExternalKey(externalKey, withPluginInfo, withAttempts, pluginProperty, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve payment custom fields
         * @param {string} paymentId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentCustomFields(paymentId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).getPaymentCustomFields(paymentId, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve payment payment tags
         * @param {string} paymentId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentTags(paymentId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).getPaymentTags(paymentId, includedDeleted, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get payments
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [pluginName] 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayments(offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payment>>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).getPayments(offset, limit, pluginName, withPluginInfo, withAttempts, pluginProperty, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyPaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).modifyPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Refund an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).refundPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Refund an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).refundPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Search payments
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {string} [pluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPayments(searchKey: string, offset?: number, limit?: number, withPluginInfo?: boolean, withAttempts?: boolean, pluginName?: string, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payment>>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).searchPayments(searchKey, offset, limit, withPluginInfo, withAttempts, pluginName, pluginProperty, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Void an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).voidPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Void an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PaymentApiAxiosParamCreator(configuration).voidPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PaymentApi - factory interface
 * @export
 */
export const PaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Cancels a scheduled payment attempt retry
         * @param {string} transactionExternalKey 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelScheduledPaymentTransactionByExternalKey(transactionExternalKey: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return PaymentApiFp(configuration).cancelScheduledPaymentTransactionByExternalKey(transactionExternalKey, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancels a scheduled payment attempt retry
         * @param {string} paymentTransactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelScheduledPaymentTransactionById(paymentTransactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return PaymentApiFp(configuration).cancelScheduledPaymentTransactionById(paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Capture an existing authorization
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureAuthorization(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return PaymentApiFp(configuration).captureAuthorization(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Capture an existing authorization
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureAuthorizationByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return PaymentApiFp(configuration).captureAuthorizationByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Record a chargeback
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return PaymentApiFp(configuration).chargebackPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Record a chargeback
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return PaymentApiFp(configuration).chargebackPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Record a chargeback reversal
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackReversalPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return PaymentApiFp(configuration).chargebackReversalPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Record a chargeback reversal
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackReversalPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return PaymentApiFp(configuration).chargebackReversalPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTransaction(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return PaymentApiFp(configuration).completeTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTransactionByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return PaymentApiFp(configuration).completeTransactionByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Combo api to create a new payment transaction on a existing (or not) account 
         * @param {ComboPaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComboPayment(body: ComboPaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return PaymentApiFp(configuration).createComboPayment(body, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<CustomField>> {
            return PaymentApiFp(configuration).createPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add tags to payment payment
         * @param {Array<string>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentTags(body: Array<string>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<Tag>> {
            return PaymentApiFp(configuration).createPaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove custom fields from payment payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentCustomFields(paymentId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return PaymentApiFp(configuration).deletePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove tags from payment payment
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentTags(paymentId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return PaymentApiFp(configuration).deletePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a payment by id
         * @param {string} paymentId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(paymentId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Payment> {
            return PaymentApiFp(configuration).getPayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment attempt audit logs with history by id
         * @param {string} paymentAttemptId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentAttemptAuditLogsWithHistory(paymentAttemptId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return PaymentApiFp(configuration).getPaymentAttemptAuditLogsWithHistory(paymentAttemptId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment audit logs with history by id
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentAuditLogsWithHistory(paymentId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return PaymentApiFp(configuration).getPaymentAuditLogsWithHistory(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a payment by external key
         * @param {string} externalKey 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByExternalKey(externalKey: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Payment> {
            return PaymentApiFp(configuration).getPaymentByExternalKey(externalKey, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment custom fields
         * @param {string} paymentId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentCustomFields(paymentId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return PaymentApiFp(configuration).getPaymentCustomFields(paymentId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment payment tags
         * @param {string} paymentId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentTags(paymentId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return PaymentApiFp(configuration).getPaymentTags(paymentId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get payments
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [pluginName] 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayments(offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Payment>> {
            return PaymentApiFp(configuration).getPayments(offset, limit, pluginName, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify custom fields to payment
         * @param {Array<CustomField>} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return PaymentApiFp(configuration).modifyPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refund an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return PaymentApiFp(configuration).refundPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refund an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return PaymentApiFp(configuration).refundPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search payments
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {string} [pluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPayments(searchKey: string, offset?: number, limit?: number, withPluginInfo?: boolean, withAttempts?: boolean, pluginName?: string, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Payment>> {
            return PaymentApiFp(configuration).searchPayments(searchKey, offset, limit, withPluginInfo, withAttempts, pluginName, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Void an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} paymentId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return PaymentApiFp(configuration).voidPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Void an existing payment
         * @param {PaymentTransaction} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return PaymentApiFp(configuration).voidPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export class PaymentApi extends BaseAPI {
    /**
     * 
     * @summary Cancels a scheduled payment attempt retry
     * @param {string} transactionExternalKey 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public cancelScheduledPaymentTransactionByExternalKey(transactionExternalKey: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).cancelScheduledPaymentTransactionByExternalKey(transactionExternalKey, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancels a scheduled payment attempt retry
     * @param {string} paymentTransactionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public cancelScheduledPaymentTransactionById(paymentTransactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).cancelScheduledPaymentTransactionById(paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Capture an existing authorization
     * @param {PaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public captureAuthorization(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).captureAuthorization(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Capture an existing authorization
     * @param {PaymentTransaction} body 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public captureAuthorizationByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).captureAuthorizationByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Record a chargeback
     * @param {PaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public chargebackPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).chargebackPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Record a chargeback
     * @param {PaymentTransaction} body 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public chargebackPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).chargebackPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Record a chargeback reversal
     * @param {PaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public chargebackReversalPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).chargebackReversalPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Record a chargeback reversal
     * @param {PaymentTransaction} body 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public chargebackReversalPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).chargebackReversalPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Complete an existing transaction
     * @param {PaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public completeTransaction(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).completeTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Complete an existing transaction
     * @param {PaymentTransaction} body 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public completeTransactionByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).completeTransactionByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Combo api to create a new payment transaction on a existing (or not) account 
     * @param {ComboPaymentTransaction} body 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public createComboPayment(body: ComboPaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).createComboPayment(body, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add custom fields to payment
     * @param {Array<CustomField>} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public createPaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).createPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add tags to payment payment
     * @param {Array<string>} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public createPaymentTags(body: Array<string>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).createPaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove custom fields from payment payment
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [customField] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public deletePaymentCustomFields(paymentId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).deletePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove tags from payment payment
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [tagDef] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public deletePaymentTags(paymentId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).deletePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a payment by id
     * @param {string} paymentId 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [withAttempts] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPayment(paymentId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return PaymentApiFp(this.configuration).getPayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment attempt audit logs with history by id
     * @param {string} paymentAttemptId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPaymentAttemptAuditLogsWithHistory(paymentAttemptId: string, options?: any) {
        return PaymentApiFp(this.configuration).getPaymentAttemptAuditLogsWithHistory(paymentAttemptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment audit logs with history by id
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPaymentAuditLogsWithHistory(paymentId: string, options?: any) {
        return PaymentApiFp(this.configuration).getPaymentAuditLogsWithHistory(paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a payment by external key
     * @param {string} externalKey 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [withAttempts] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPaymentByExternalKey(externalKey: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return PaymentApiFp(this.configuration).getPaymentByExternalKey(externalKey, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment custom fields
     * @param {string} paymentId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPaymentCustomFields(paymentId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return PaymentApiFp(this.configuration).getPaymentCustomFields(paymentId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment payment tags
     * @param {string} paymentId 
     * @param {boolean} [includedDeleted] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPaymentTags(paymentId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return PaymentApiFp(this.configuration).getPaymentTags(paymentId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get payments
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [pluginName] 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [withAttempts] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPayments(offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return PaymentApiFp(this.configuration).getPayments(offset, limit, pluginName, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify custom fields to payment
     * @param {Array<CustomField>} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public modifyPaymentCustomFields(body: Array<CustomField>, paymentId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).modifyPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refund an existing payment
     * @param {PaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public refundPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).refundPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refund an existing payment
     * @param {PaymentTransaction} body 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public refundPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).refundPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search payments
     * @param {string} searchKey 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [withAttempts] 
     * @param {string} [pluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public searchPayments(searchKey: string, offset?: number, limit?: number, withPluginInfo?: boolean, withAttempts?: boolean, pluginName?: string, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return PaymentApiFp(this.configuration).searchPayments(searchKey, offset, limit, withPluginInfo, withAttempts, pluginName, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Void an existing payment
     * @param {PaymentTransaction} body 
     * @param {string} paymentId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public voidPayment(body: PaymentTransaction, paymentId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).voidPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Void an existing payment
     * @param {PaymentTransaction} body 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public voidPaymentByExternalKey(body: PaymentTransaction, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentApiFp(this.configuration).voidPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * PaymentGatewayApi - axios parameter creator
 * @export
 */
export const PaymentGatewayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Combo API to generate form data to redirect the customer to the gateway
         * @param {ComboHostedPaymentPage} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildComboFormDescriptor: async (body: ComboHostedPaymentPage, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling buildComboFormDescriptor.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling buildComboFormDescriptor.');
            }
            const localVarPath = `/1.0/kb/paymentGateways/hosted/form`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate form data to redirect the customer to the gateway
         * @param {HostedPaymentPageFields} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildFormDescriptor: async (body: HostedPaymentPageFields, accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling buildFormDescriptor.');
            }
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling buildFormDescriptor.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling buildFormDescriptor.');
            }
            const localVarPath = `/1.0/kb/paymentGateways/hosted/form/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (paymentMethodId !== undefined) {
                localVarQueryParameter['paymentMethodId'] = paymentMethodId;
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The response is built by the appropriate plugin
         * @summary Process a gateway notification
         * @param {string} body 
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processNotification: async (body: string, pluginName: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling processNotification.');
            }
            // verify required parameter 'pluginName' is not null or undefined
            if (pluginName === null || pluginName === undefined) {
                throw new RequiredError('pluginName','Required parameter pluginName was null or undefined when calling processNotification.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling processNotification.');
            }
            const localVarPath = `/1.0/kb/paymentGateways/notification/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentGatewayApi - functional programming interface
 * @export
 */
export const PaymentGatewayApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Combo API to generate form data to redirect the customer to the gateway
         * @param {ComboHostedPaymentPage} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildComboFormDescriptor(body: ComboHostedPaymentPage, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostedPaymentPageFormDescriptor>> {
            const localVarAxiosArgs = await PaymentGatewayApiAxiosParamCreator(configuration).buildComboFormDescriptor(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Generate form data to redirect the customer to the gateway
         * @param {HostedPaymentPageFields} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildFormDescriptor(body: HostedPaymentPageFields, accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HostedPaymentPageFormDescriptor>> {
            const localVarAxiosArgs = await PaymentGatewayApiAxiosParamCreator(configuration).buildFormDescriptor(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The response is built by the appropriate plugin
         * @summary Process a gateway notification
         * @param {string} body 
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processNotification(body: string, pluginName: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PaymentGatewayApiAxiosParamCreator(configuration).processNotification(body, pluginName, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PaymentGatewayApi - factory interface
 * @export
 */
export const PaymentGatewayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Combo API to generate form data to redirect the customer to the gateway
         * @param {ComboHostedPaymentPage} body 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildComboFormDescriptor(body: ComboHostedPaymentPage, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<HostedPaymentPageFormDescriptor> {
            return PaymentGatewayApiFp(configuration).buildComboFormDescriptor(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate form data to redirect the customer to the gateway
         * @param {HostedPaymentPageFields} body 
         * @param {string} accountId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [paymentMethodId] 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildFormDescriptor(body: HostedPaymentPageFields, accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<HostedPaymentPageFormDescriptor> {
            return PaymentGatewayApiFp(configuration).buildFormDescriptor(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * The response is built by the appropriate plugin
         * @summary Process a gateway notification
         * @param {string} body 
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processNotification(body: string, pluginName: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return PaymentGatewayApiFp(configuration).processNotification(body, pluginName, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentGatewayApi - object-oriented interface
 * @export
 * @class PaymentGatewayApi
 * @extends {BaseAPI}
 */
export class PaymentGatewayApi extends BaseAPI {
    /**
     * 
     * @summary Combo API to generate form data to redirect the customer to the gateway
     * @param {ComboHostedPaymentPage} body 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentGatewayApi
     */
    public buildComboFormDescriptor(body: ComboHostedPaymentPage, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentGatewayApiFp(this.configuration).buildComboFormDescriptor(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate form data to redirect the customer to the gateway
     * @param {HostedPaymentPageFields} body 
     * @param {string} accountId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [paymentMethodId] 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentGatewayApi
     */
    public buildFormDescriptor(body: HostedPaymentPageFields, accountId: string, xKillbillCreatedBy: string, paymentMethodId?: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentGatewayApiFp(this.configuration).buildFormDescriptor(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The response is built by the appropriate plugin
     * @summary Process a gateway notification
     * @param {string} body 
     * @param {string} pluginName 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentGatewayApi
     */
    public processNotification(body: string, pluginName: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentGatewayApiFp(this.configuration).processNotification(body, pluginName, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * PaymentMethodApi - axios parameter creator
 * @export
 */
export const PaymentMethodApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add custom fields to payment method
         * @param {Array<CustomField>} body 
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethodCustomFields: async (body: Array<CustomField>, paymentMethodId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPaymentMethodCustomFields.');
            }
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId','Required parameter paymentMethodId was null or undefined when calling createPaymentMethodCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createPaymentMethodCustomFields.');
            }
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}/customFields`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a payment method
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteDefaultPmWithAutoPayOff] 
         * @param {boolean} [forceDefaultPmDeletion] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethod: async (paymentMethodId: string, xKillbillCreatedBy: string, deleteDefaultPmWithAutoPayOff?: boolean, forceDefaultPmDeletion?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId','Required parameter paymentMethodId was null or undefined when calling deletePaymentMethod.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deletePaymentMethod.');
            }
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (deleteDefaultPmWithAutoPayOff !== undefined) {
                localVarQueryParameter['deleteDefaultPmWithAutoPayOff'] = deleteDefaultPmWithAutoPayOff;
            }

            if (forceDefaultPmDeletion !== undefined) {
                localVarQueryParameter['forceDefaultPmDeletion'] = forceDefaultPmDeletion;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove custom fields from payment method
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethodCustomFields: async (paymentMethodId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId','Required parameter paymentMethodId was null or undefined when calling deletePaymentMethodCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deletePaymentMethodCustomFields.');
            }
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}/customFields`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a payment method by id
         * @param {string} paymentMethodId 
         * @param {boolean} [includedDeleted] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod: async (paymentMethodId: string, includedDeleted?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId','Required parameter paymentMethodId was null or undefined when calling getPaymentMethod.');
            }
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment method audit logs with history by id
         * @param {string} paymentMethodId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodAuditLogsWithHistory: async (paymentMethodId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId','Required parameter paymentMethodId was null or undefined when calling getPaymentMethodAuditLogsWithHistory.');
            }
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}/auditLogsWithHistory`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a payment method by external key
         * @param {string} externalKey 
         * @param {boolean} [includedDeleted] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodByKey: async (externalKey: string, includedDeleted?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalKey' is not null or undefined
            if (externalKey === null || externalKey === undefined) {
                throw new RequiredError('externalKey','Required parameter externalKey was null or undefined when calling getPaymentMethodByKey.');
            }
            const localVarPath = `/1.0/kb/paymentMethods`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment method custom fields
         * @param {string} paymentMethodId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodCustomFields: async (paymentMethodId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId','Required parameter paymentMethodId was null or undefined when calling getPaymentMethodCustomFields.');
            }
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}/customFields`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List payment methods
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [pluginName] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethods: async (offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/paymentMethods/pagination`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (pluginName !== undefined) {
                localVarQueryParameter['pluginName'] = pluginName;
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify custom fields to payment method
         * @param {Array<CustomField>} body 
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPaymentMethodCustomFields: async (body: Array<CustomField>, paymentMethodId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling modifyPaymentMethodCustomFields.');
            }
            // verify required parameter 'paymentMethodId' is not null or undefined
            if (paymentMethodId === null || paymentMethodId === undefined) {
                throw new RequiredError('paymentMethodId','Required parameter paymentMethodId was null or undefined when calling modifyPaymentMethodCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling modifyPaymentMethodCustomFields.');
            }
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}/customFields`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search payment methods
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [pluginName] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPaymentMethods: async (searchKey: string, offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            if (searchKey === null || searchKey === undefined) {
                throw new RequiredError('searchKey','Required parameter searchKey was null or undefined when calling searchPaymentMethods.');
            }
            const localVarPath = `/1.0/kb/paymentMethods/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (pluginName !== undefined) {
                localVarQueryParameter['pluginName'] = pluginName;
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentMethodApi - functional programming interface
 * @export
 */
export const PaymentMethodApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add custom fields to payment method
         * @param {Array<CustomField>} body 
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentMethodCustomFields(body: Array<CustomField>, paymentMethodId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await PaymentMethodApiAxiosParamCreator(configuration).createPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a payment method
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteDefaultPmWithAutoPayOff] 
         * @param {boolean} [forceDefaultPmDeletion] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentMethod(paymentMethodId: string, xKillbillCreatedBy: string, deleteDefaultPmWithAutoPayOff?: boolean, forceDefaultPmDeletion?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PaymentMethodApiAxiosParamCreator(configuration).deletePaymentMethod(paymentMethodId, xKillbillCreatedBy, deleteDefaultPmWithAutoPayOff, forceDefaultPmDeletion, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove custom fields from payment method
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePaymentMethodCustomFields(paymentMethodId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PaymentMethodApiAxiosParamCreator(configuration).deletePaymentMethodCustomFields(paymentMethodId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a payment method by id
         * @param {string} paymentMethodId 
         * @param {boolean} [includedDeleted] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethod(paymentMethodId: string, includedDeleted?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethod>> {
            const localVarAxiosArgs = await PaymentMethodApiAxiosParamCreator(configuration).getPaymentMethod(paymentMethodId, includedDeleted, withPluginInfo, pluginProperty, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve payment method audit logs with history by id
         * @param {string} paymentMethodId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodAuditLogsWithHistory(paymentMethodId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await PaymentMethodApiAxiosParamCreator(configuration).getPaymentMethodAuditLogsWithHistory(paymentMethodId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a payment method by external key
         * @param {string} externalKey 
         * @param {boolean} [includedDeleted] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodByKey(externalKey: string, includedDeleted?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentMethod>> {
            const localVarAxiosArgs = await PaymentMethodApiAxiosParamCreator(configuration).getPaymentMethodByKey(externalKey, includedDeleted, withPluginInfo, pluginProperty, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve payment method custom fields
         * @param {string} paymentMethodId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethodCustomFields(paymentMethodId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await PaymentMethodApiAxiosParamCreator(configuration).getPaymentMethodCustomFields(paymentMethodId, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List payment methods
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [pluginName] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentMethods(offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentMethod>>> {
            const localVarAxiosArgs = await PaymentMethodApiAxiosParamCreator(configuration).getPaymentMethods(offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify custom fields to payment method
         * @param {Array<CustomField>} body 
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyPaymentMethodCustomFields(body: Array<CustomField>, paymentMethodId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PaymentMethodApiAxiosParamCreator(configuration).modifyPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Search payment methods
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [pluginName] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPaymentMethods(searchKey: string, offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentMethod>>> {
            const localVarAxiosArgs = await PaymentMethodApiAxiosParamCreator(configuration).searchPaymentMethods(searchKey, offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PaymentMethodApi - factory interface
 * @export
 */
export const PaymentMethodApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Add custom fields to payment method
         * @param {Array<CustomField>} body 
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethodCustomFields(body: Array<CustomField>, paymentMethodId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<CustomField>> {
            return PaymentMethodApiFp(configuration).createPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a payment method
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [deleteDefaultPmWithAutoPayOff] 
         * @param {boolean} [forceDefaultPmDeletion] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethod(paymentMethodId: string, xKillbillCreatedBy: string, deleteDefaultPmWithAutoPayOff?: boolean, forceDefaultPmDeletion?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return PaymentMethodApiFp(configuration).deletePaymentMethod(paymentMethodId, xKillbillCreatedBy, deleteDefaultPmWithAutoPayOff, forceDefaultPmDeletion, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove custom fields from payment method
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethodCustomFields(paymentMethodId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return PaymentMethodApiFp(configuration).deletePaymentMethodCustomFields(paymentMethodId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a payment method by id
         * @param {string} paymentMethodId 
         * @param {boolean} [includedDeleted] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod(paymentMethodId: string, includedDeleted?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<PaymentMethod> {
            return PaymentMethodApiFp(configuration).getPaymentMethod(paymentMethodId, includedDeleted, withPluginInfo, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment method audit logs with history by id
         * @param {string} paymentMethodId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodAuditLogsWithHistory(paymentMethodId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return PaymentMethodApiFp(configuration).getPaymentMethodAuditLogsWithHistory(paymentMethodId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a payment method by external key
         * @param {string} externalKey 
         * @param {boolean} [includedDeleted] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodByKey(externalKey: string, includedDeleted?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<PaymentMethod> {
            return PaymentMethodApiFp(configuration).getPaymentMethodByKey(externalKey, includedDeleted, withPluginInfo, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment method custom fields
         * @param {string} paymentMethodId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodCustomFields(paymentMethodId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return PaymentMethodApiFp(configuration).getPaymentMethodCustomFields(paymentMethodId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List payment methods
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [pluginName] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethods(offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<PaymentMethod>> {
            return PaymentMethodApiFp(configuration).getPaymentMethods(offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify custom fields to payment method
         * @param {Array<CustomField>} body 
         * @param {string} paymentMethodId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPaymentMethodCustomFields(body: Array<CustomField>, paymentMethodId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return PaymentMethodApiFp(configuration).modifyPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search payment methods
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {string} [pluginName] 
         * @param {boolean} [withPluginInfo] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPaymentMethods(searchKey: string, offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<PaymentMethod>> {
            return PaymentMethodApiFp(configuration).searchPaymentMethods(searchKey, offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentMethodApi - object-oriented interface
 * @export
 * @class PaymentMethodApi
 * @extends {BaseAPI}
 */
export class PaymentMethodApi extends BaseAPI {
    /**
     * 
     * @summary Add custom fields to payment method
     * @param {Array<CustomField>} body 
     * @param {string} paymentMethodId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public createPaymentMethodCustomFields(body: Array<CustomField>, paymentMethodId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentMethodApiFp(this.configuration).createPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a payment method
     * @param {string} paymentMethodId 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [deleteDefaultPmWithAutoPayOff] 
     * @param {boolean} [forceDefaultPmDeletion] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public deletePaymentMethod(paymentMethodId: string, xKillbillCreatedBy: string, deleteDefaultPmWithAutoPayOff?: boolean, forceDefaultPmDeletion?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentMethodApiFp(this.configuration).deletePaymentMethod(paymentMethodId, xKillbillCreatedBy, deleteDefaultPmWithAutoPayOff, forceDefaultPmDeletion, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove custom fields from payment method
     * @param {string} paymentMethodId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [customField] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public deletePaymentMethodCustomFields(paymentMethodId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentMethodApiFp(this.configuration).deletePaymentMethodCustomFields(paymentMethodId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a payment method by id
     * @param {string} paymentMethodId 
     * @param {boolean} [includedDeleted] 
     * @param {boolean} [withPluginInfo] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public getPaymentMethod(paymentMethodId: string, includedDeleted?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return PaymentMethodApiFp(this.configuration).getPaymentMethod(paymentMethodId, includedDeleted, withPluginInfo, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment method audit logs with history by id
     * @param {string} paymentMethodId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public getPaymentMethodAuditLogsWithHistory(paymentMethodId: string, options?: any) {
        return PaymentMethodApiFp(this.configuration).getPaymentMethodAuditLogsWithHistory(paymentMethodId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a payment method by external key
     * @param {string} externalKey 
     * @param {boolean} [includedDeleted] 
     * @param {boolean} [withPluginInfo] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public getPaymentMethodByKey(externalKey: string, includedDeleted?: boolean, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return PaymentMethodApiFp(this.configuration).getPaymentMethodByKey(externalKey, includedDeleted, withPluginInfo, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment method custom fields
     * @param {string} paymentMethodId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public getPaymentMethodCustomFields(paymentMethodId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return PaymentMethodApiFp(this.configuration).getPaymentMethodCustomFields(paymentMethodId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List payment methods
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [pluginName] 
     * @param {boolean} [withPluginInfo] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public getPaymentMethods(offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return PaymentMethodApiFp(this.configuration).getPaymentMethods(offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify custom fields to payment method
     * @param {Array<CustomField>} body 
     * @param {string} paymentMethodId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public modifyPaymentMethodCustomFields(body: Array<CustomField>, paymentMethodId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentMethodApiFp(this.configuration).modifyPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search payment methods
     * @param {string} searchKey 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {string} [pluginName] 
     * @param {boolean} [withPluginInfo] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public searchPaymentMethods(searchKey: string, offset?: number, limit?: number, pluginName?: string, withPluginInfo?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return PaymentMethodApiFp(this.configuration).searchPaymentMethods(searchKey, offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * PaymentTransactionApi - axios parameter creator
 * @export
 */
export const PaymentTransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add custom fields to payment transaction
         * @param {Array<CustomField>} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionCustomFields: async (body: Array<CustomField>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTransactionCustomFields.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling createTransactionCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createTransactionCustomFields.');
            }
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/customFields`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add tags to payment transaction
         * @param {Array<string>} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionTags: async (body: Array<string>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTransactionTags.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling createTransactionTags.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createTransactionTags.');
            }
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/tags`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove custom fields from payment transaction
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionCustomFields: async (transactionId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling deleteTransactionCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deleteTransactionCustomFields.');
            }
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/customFields`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove tags from payment transaction
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionTags: async (transactionId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling deleteTransactionTags.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deleteTransactionTags.');
            }
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/tags`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a payment by transaction external key
         * @param {string} transactionExternalKey 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByTransactionExternalKey: async (transactionExternalKey: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionExternalKey' is not null or undefined
            if (transactionExternalKey === null || transactionExternalKey === undefined) {
                throw new RequiredError('transactionExternalKey','Required parameter transactionExternalKey was null or undefined when calling getPaymentByTransactionExternalKey.');
            }
            const localVarPath = `/1.0/kb/paymentTransactions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (transactionExternalKey !== undefined) {
                localVarQueryParameter['transactionExternalKey'] = transactionExternalKey;
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a payment by transaction id
         * @param {string} transactionId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByTransactionId: async (transactionId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling getPaymentByTransactionId.');
            }
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }

            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment transaction audit logs with history by id
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionAuditLogsWithHistory: async (transactionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling getTransactionAuditLogsWithHistory.');
            }
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/auditLogsWithHistory`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment transaction custom fields
         * @param {string} transactionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionCustomFields: async (transactionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling getTransactionCustomFields.');
            }
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/customFields`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve payment transaction tags
         * @param {string} transactionId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionTags: async (transactionId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling getTransactionTags.');
            }
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/tags`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify custom fields to payment transaction
         * @param {Array<CustomField>} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTransactionCustomFields: async (body: Array<CustomField>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling modifyTransactionCustomFields.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling modifyTransactionCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling modifyTransactionCustomFields.');
            }
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/customFields`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Mark a pending payment transaction as succeeded or failed
         * @param {PaymentTransaction} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyStateChanged: async (body: PaymentTransaction, transactionId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling notifyStateChanged.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling notifyStateChanged.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling notifyStateChanged.');
            }
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentTransactionApi - functional programming interface
 * @export
 */
export const PaymentTransactionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add custom fields to payment transaction
         * @param {Array<CustomField>} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransactionCustomFields(body: Array<CustomField>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await PaymentTransactionApiAxiosParamCreator(configuration).createTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add tags to payment transaction
         * @param {Array<string>} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransactionTags(body: Array<string>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await PaymentTransactionApiAxiosParamCreator(configuration).createTransactionTags(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove custom fields from payment transaction
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransactionCustomFields(transactionId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PaymentTransactionApiAxiosParamCreator(configuration).deleteTransactionCustomFields(transactionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove tags from payment transaction
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransactionTags(transactionId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PaymentTransactionApiAxiosParamCreator(configuration).deleteTransactionTags(transactionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a payment by transaction external key
         * @param {string} transactionExternalKey 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentByTransactionExternalKey(transactionExternalKey: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentTransactionApiAxiosParamCreator(configuration).getPaymentByTransactionExternalKey(transactionExternalKey, withPluginInfo, withAttempts, pluginProperty, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a payment by transaction id
         * @param {string} transactionId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentByTransactionId(transactionId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentTransactionApiAxiosParamCreator(configuration).getPaymentByTransactionId(transactionId, withPluginInfo, withAttempts, pluginProperty, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve payment transaction audit logs with history by id
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionAuditLogsWithHistory(transactionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await PaymentTransactionApiAxiosParamCreator(configuration).getTransactionAuditLogsWithHistory(transactionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve payment transaction custom fields
         * @param {string} transactionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionCustomFields(transactionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await PaymentTransactionApiAxiosParamCreator(configuration).getTransactionCustomFields(transactionId, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve payment transaction tags
         * @param {string} transactionId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionTags(transactionId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await PaymentTransactionApiAxiosParamCreator(configuration).getTransactionTags(transactionId, includedDeleted, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify custom fields to payment transaction
         * @param {Array<CustomField>} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyTransactionCustomFields(body: Array<CustomField>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PaymentTransactionApiAxiosParamCreator(configuration).modifyTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Mark a pending payment transaction as succeeded or failed
         * @param {PaymentTransaction} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyStateChanged(body: PaymentTransaction, transactionId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await PaymentTransactionApiAxiosParamCreator(configuration).notifyStateChanged(body, transactionId, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PaymentTransactionApi - factory interface
 * @export
 */
export const PaymentTransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Add custom fields to payment transaction
         * @param {Array<CustomField>} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionCustomFields(body: Array<CustomField>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<CustomField>> {
            return PaymentTransactionApiFp(configuration).createTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add tags to payment transaction
         * @param {Array<string>} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionTags(body: Array<string>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<Tag>> {
            return PaymentTransactionApiFp(configuration).createTransactionTags(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove custom fields from payment transaction
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionCustomFields(transactionId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return PaymentTransactionApiFp(configuration).deleteTransactionCustomFields(transactionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove tags from payment transaction
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionTags(transactionId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return PaymentTransactionApiFp(configuration).deleteTransactionTags(transactionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a payment by transaction external key
         * @param {string} transactionExternalKey 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByTransactionExternalKey(transactionExternalKey: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Payment> {
            return PaymentTransactionApiFp(configuration).getPaymentByTransactionExternalKey(transactionExternalKey, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a payment by transaction id
         * @param {string} transactionId 
         * @param {boolean} [withPluginInfo] 
         * @param {boolean} [withAttempts] 
         * @param {Array<string>} [pluginProperty] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByTransactionId(transactionId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Payment> {
            return PaymentTransactionApiFp(configuration).getPaymentByTransactionId(transactionId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment transaction audit logs with history by id
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionAuditLogsWithHistory(transactionId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return PaymentTransactionApiFp(configuration).getTransactionAuditLogsWithHistory(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment transaction custom fields
         * @param {string} transactionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionCustomFields(transactionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return PaymentTransactionApiFp(configuration).getTransactionCustomFields(transactionId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve payment transaction tags
         * @param {string} transactionId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionTags(transactionId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return PaymentTransactionApiFp(configuration).getTransactionTags(transactionId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify custom fields to payment transaction
         * @param {Array<CustomField>} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTransactionCustomFields(body: Array<CustomField>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return PaymentTransactionApiFp(configuration).modifyTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Mark a pending payment transaction as succeeded or failed
         * @param {PaymentTransaction} body 
         * @param {string} transactionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [controlPluginName] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyStateChanged(body: PaymentTransaction, transactionId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Payment> {
            return PaymentTransactionApiFp(configuration).notifyStateChanged(body, transactionId, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentTransactionApi - object-oriented interface
 * @export
 * @class PaymentTransactionApi
 * @extends {BaseAPI}
 */
export class PaymentTransactionApi extends BaseAPI {
    /**
     * 
     * @summary Add custom fields to payment transaction
     * @param {Array<CustomField>} body 
     * @param {string} transactionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public createTransactionCustomFields(body: Array<CustomField>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentTransactionApiFp(this.configuration).createTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add tags to payment transaction
     * @param {Array<string>} body 
     * @param {string} transactionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public createTransactionTags(body: Array<string>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentTransactionApiFp(this.configuration).createTransactionTags(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove custom fields from payment transaction
     * @param {string} transactionId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [customField] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public deleteTransactionCustomFields(transactionId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentTransactionApiFp(this.configuration).deleteTransactionCustomFields(transactionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove tags from payment transaction
     * @param {string} transactionId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [tagDef] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public deleteTransactionTags(transactionId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentTransactionApiFp(this.configuration).deleteTransactionTags(transactionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a payment by transaction external key
     * @param {string} transactionExternalKey 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [withAttempts] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public getPaymentByTransactionExternalKey(transactionExternalKey: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return PaymentTransactionApiFp(this.configuration).getPaymentByTransactionExternalKey(transactionExternalKey, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a payment by transaction id
     * @param {string} transactionId 
     * @param {boolean} [withPluginInfo] 
     * @param {boolean} [withAttempts] 
     * @param {Array<string>} [pluginProperty] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public getPaymentByTransactionId(transactionId: string, withPluginInfo?: boolean, withAttempts?: boolean, pluginProperty?: Array<string>, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return PaymentTransactionApiFp(this.configuration).getPaymentByTransactionId(transactionId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment transaction audit logs with history by id
     * @param {string} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public getTransactionAuditLogsWithHistory(transactionId: string, options?: any) {
        return PaymentTransactionApiFp(this.configuration).getTransactionAuditLogsWithHistory(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment transaction custom fields
     * @param {string} transactionId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public getTransactionCustomFields(transactionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return PaymentTransactionApiFp(this.configuration).getTransactionCustomFields(transactionId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve payment transaction tags
     * @param {string} transactionId 
     * @param {boolean} [includedDeleted] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public getTransactionTags(transactionId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return PaymentTransactionApiFp(this.configuration).getTransactionTags(transactionId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify custom fields to payment transaction
     * @param {Array<CustomField>} body 
     * @param {string} transactionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public modifyTransactionCustomFields(body: Array<CustomField>, transactionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentTransactionApiFp(this.configuration).modifyTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Mark a pending payment transaction as succeeded or failed
     * @param {PaymentTransaction} body 
     * @param {string} transactionId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [controlPluginName] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    public notifyStateChanged(body: PaymentTransaction, transactionId: string, xKillbillCreatedBy: string, controlPluginName?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return PaymentTransactionApiFp(this.configuration).notifyStateChanged(body, transactionId, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * PluginInfoApi - axios parameter creator
 * @export
 */
export const PluginInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the list of registered plugins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginsInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/pluginsInfo`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PluginInfoApi - functional programming interface
 * @export
 */
export const PluginInfoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve the list of registered plugins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPluginsInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PluginInfo>>> {
            const localVarAxiosArgs = await PluginInfoApiAxiosParamCreator(configuration).getPluginsInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PluginInfoApi - factory interface
 * @export
 */
export const PluginInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Retrieve the list of registered plugins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginsInfo(options?: any): AxiosPromise<Array<PluginInfo>> {
            return PluginInfoApiFp(configuration).getPluginsInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PluginInfoApi - object-oriented interface
 * @export
 * @class PluginInfoApi
 * @extends {BaseAPI}
 */
export class PluginInfoApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve the list of registered plugins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginInfoApi
     */
    public getPluginsInfo(options?: any) {
        return PluginInfoApiFp(this.configuration).getPluginsInfo(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new role definition)
         * @param {RoleDefinition} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleDefinition: async (body: RoleDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addRoleDefinition.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling addRoleDefinition.');
            }
            const localVarPath = `/1.0/kb/security/roles`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new user with roles (to make api requests)
         * @param {UserRoles} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserRoles: async (body: UserRoles, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addUserRoles.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling addUserRoles.');
            }
            const localVarPath = `/1.0/kb/security/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List user permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserPermissions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/security/permissions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserSubject: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/security/subject`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get role definition
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleDefinition: async (role: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling getRoleDefinition.');
            }
            const localVarPath = `/1.0/kb/security/roles/{role}`
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get roles associated to a user
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles: async (username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling getUserRoles.');
            }
            const localVarPath = `/1.0/kb/security/users/{username}/roles`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate an existing user
         * @param {string} username 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateUser: async (username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling invalidateUser.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling invalidateUser.');
            }
            const localVarPath = `/1.0/kb/security/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a new role definition)
         * @param {RoleDefinition} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleDefinition: async (body: RoleDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateRoleDefinition.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling updateRoleDefinition.');
            }
            const localVarPath = `/1.0/kb/security/roles`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user password
         * @param {UserRoles} body 
         * @param {string} username 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: async (body: UserRoles, username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUserPassword.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling updateUserPassword.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling updateUserPassword.');
            }
            const localVarPath = `/1.0/kb/security/users/{username}/password`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update roles associated to a user
         * @param {UserRoles} body 
         * @param {string} username 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoles: async (body: UserRoles, username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUserRoles.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling updateUserRoles.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling updateUserRoles.');
            }
            const localVarPath = `/1.0/kb/security/users/{username}/roles`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new role definition)
         * @param {RoleDefinition} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRoleDefinition(body: RoleDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleDefinition>> {
            const localVarAxiosArgs = await SecurityApiAxiosParamCreator(configuration).addRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add a new user with roles (to make api requests)
         * @param {UserRoles} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserRoles(body: UserRoles, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoles>> {
            const localVarAxiosArgs = await SecurityApiAxiosParamCreator(configuration).addUserRoles(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List user permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUserPermissions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await SecurityApiAxiosParamCreator(configuration).getCurrentUserPermissions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUserSubject(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subject>> {
            const localVarAxiosArgs = await SecurityApiAxiosParamCreator(configuration).getCurrentUserSubject(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get role definition
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleDefinition(role: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleDefinition>> {
            const localVarAxiosArgs = await SecurityApiAxiosParamCreator(configuration).getRoleDefinition(role, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get roles associated to a user
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRoles(username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoles>> {
            const localVarAxiosArgs = await SecurityApiAxiosParamCreator(configuration).getUserRoles(username, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Invalidate an existing user
         * @param {string} username 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invalidateUser(username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SecurityApiAxiosParamCreator(configuration).invalidateUser(username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a new role definition)
         * @param {RoleDefinition} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRoleDefinition(body: RoleDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SecurityApiAxiosParamCreator(configuration).updateRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a user password
         * @param {UserRoles} body 
         * @param {string} username 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPassword(body: UserRoles, username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SecurityApiAxiosParamCreator(configuration).updateUserPassword(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update roles associated to a user
         * @param {UserRoles} body 
         * @param {string} username 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserRoles(body: UserRoles, username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SecurityApiAxiosParamCreator(configuration).updateUserRoles(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Add a new role definition)
         * @param {RoleDefinition} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleDefinition(body: RoleDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<RoleDefinition> {
            return SecurityApiFp(configuration).addRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new user with roles (to make api requests)
         * @param {UserRoles} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserRoles(body: UserRoles, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<UserRoles> {
            return SecurityApiFp(configuration).addUserRoles(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List user permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserPermissions(options?: any): AxiosPromise<Array<string>> {
            return SecurityApiFp(configuration).getCurrentUserPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserSubject(options?: any): AxiosPromise<Subject> {
            return SecurityApiFp(configuration).getCurrentUserSubject(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get role definition
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleDefinition(role: string, options?: any): AxiosPromise<RoleDefinition> {
            return SecurityApiFp(configuration).getRoleDefinition(role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get roles associated to a user
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles(username: string, options?: any): AxiosPromise<UserRoles> {
            return SecurityApiFp(configuration).getUserRoles(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invalidate an existing user
         * @param {string} username 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateUser(username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return SecurityApiFp(configuration).invalidateUser(username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a new role definition)
         * @param {RoleDefinition} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleDefinition(body: RoleDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return SecurityApiFp(configuration).updateRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user password
         * @param {UserRoles} body 
         * @param {string} username 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(body: UserRoles, username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return SecurityApiFp(configuration).updateUserPassword(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update roles associated to a user
         * @param {UserRoles} body 
         * @param {string} username 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoles(body: UserRoles, username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return SecurityApiFp(configuration).updateUserRoles(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
    /**
     * 
     * @summary Add a new role definition)
     * @param {RoleDefinition} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public addRoleDefinition(body: RoleDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SecurityApiFp(this.configuration).addRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new user with roles (to make api requests)
     * @param {UserRoles} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public addUserRoles(body: UserRoles, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SecurityApiFp(this.configuration).addUserRoles(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List user permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public getCurrentUserPermissions(options?: any) {
        return SecurityApiFp(this.configuration).getCurrentUserPermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public getCurrentUserSubject(options?: any) {
        return SecurityApiFp(this.configuration).getCurrentUserSubject(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get role definition
     * @param {string} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public getRoleDefinition(role: string, options?: any) {
        return SecurityApiFp(this.configuration).getRoleDefinition(role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get roles associated to a user
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public getUserRoles(username: string, options?: any) {
        return SecurityApiFp(this.configuration).getUserRoles(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invalidate an existing user
     * @param {string} username 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public invalidateUser(username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SecurityApiFp(this.configuration).invalidateUser(username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a new role definition)
     * @param {RoleDefinition} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public updateRoleDefinition(body: RoleDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SecurityApiFp(this.configuration).updateRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user password
     * @param {UserRoles} body 
     * @param {string} username 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public updateUserPassword(body: UserRoles, username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SecurityApiFp(this.configuration).updateUserPassword(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update roles associated to a user
     * @param {UserRoles} body 
     * @param {string} username 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public updateUserRoles(body: UserRoles, username: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SecurityApiFp(this.configuration).updateUserRoles(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SubscriptionApi - axios parameter creator
 * @export
 */
export const SubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Block a subscription
         * @param {BlockingState} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscriptionBlockingState: async (body: BlockingState, subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addSubscriptionBlockingState.');
            }
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling addSubscriptionBlockingState.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling addSubscriptionBlockingState.');
            }
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/block`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel an entitlement plan
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {'IMMEDIATE' | 'END_OF_TERM'} [entitlementPolicy] 
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
         * @param {boolean} [useRequestedDateForBilling] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscriptionPlan: async (subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, callCompletion?: boolean, callTimeoutSec?: number, entitlementPolicy?: 'IMMEDIATE' | 'END_OF_TERM', billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', useRequestedDateForBilling?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling cancelSubscriptionPlan.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling cancelSubscriptionPlan.');
            }
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (callCompletion !== undefined) {
                localVarQueryParameter['callCompletion'] = callCompletion;
            }

            if (callTimeoutSec !== undefined) {
                localVarQueryParameter['callTimeoutSec'] = callTimeoutSec;
            }

            if (entitlementPolicy !== undefined) {
                localVarQueryParameter['entitlementPolicy'] = entitlementPolicy;
            }

            if (billingPolicy !== undefined) {
                localVarQueryParameter['billingPolicy'] = billingPolicy;
            }

            if (useRequestedDateForBilling !== undefined) {
                localVarQueryParameter['useRequestedDateForBilling'] = useRequestedDateForBilling;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change entitlement plan
         * @param {Subscription} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscriptionPlan: async (body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, callCompletion?: boolean, callTimeoutSec?: number, billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling changeSubscriptionPlan.');
            }
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling changeSubscriptionPlan.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling changeSubscriptionPlan.');
            }
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate as any instanceof Date) ?
                    (requestedDate as any).toISOString().substr(0,10) :
                    requestedDate;
            }

            if (callCompletion !== undefined) {
                localVarQueryParameter['callCompletion'] = callCompletion;
            }

            if (callTimeoutSec !== undefined) {
                localVarQueryParameter['callTimeoutSec'] = callTimeoutSec;
            }

            if (billingPolicy !== undefined) {
                localVarQueryParameter['billingPolicy'] = billingPolicy;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an subscription
         * @param {Subscription} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [entitlementDate] 
         * @param {string} [billingDate] 
         * @param {boolean} [renameKeyIfExistsAndUnused] 
         * @param {boolean} [migrated] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription: async (body: Subscription, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, renameKeyIfExistsAndUnused?: boolean, migrated?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSubscription.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createSubscription.');
            }
            const localVarPath = `/1.0/kb/subscriptions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (entitlementDate !== undefined) {
                localVarQueryParameter['entitlementDate'] = (entitlementDate as any instanceof Date) ?
                    (entitlementDate as any).toISOString().substr(0,10) :
                    entitlementDate;
            }

            if (billingDate !== undefined) {
                localVarQueryParameter['billingDate'] = (billingDate as any instanceof Date) ?
                    (billingDate as any).toISOString().substr(0,10) :
                    billingDate;
            }

            if (renameKeyIfExistsAndUnused !== undefined) {
                localVarQueryParameter['renameKeyIfExistsAndUnused'] = renameKeyIfExistsAndUnused;
            }

            if (migrated !== undefined) {
                localVarQueryParameter['migrated'] = migrated;
            }

            if (callCompletion !== undefined) {
                localVarQueryParameter['callCompletion'] = callCompletion;
            }

            if (callTimeoutSec !== undefined) {
                localVarQueryParameter['callTimeoutSec'] = callTimeoutSec;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add custom fields to subscription
         * @param {Array<CustomField>} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionCustomFields: async (body: Array<CustomField>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSubscriptionCustomFields.');
            }
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling createSubscriptionCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createSubscriptionCustomFields.');
            }
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/customFields`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionTags: async (body: Array<string>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSubscriptionTags.');
            }
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling createSubscriptionTags.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createSubscriptionTags.');
            }
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/tags`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an entitlement with addOn products
         * @param {Array<Subscription>} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [entitlementDate] 
         * @param {string} [billingDate] 
         * @param {boolean} [migrated] 
         * @param {boolean} [renameKeyIfExistsAndUnused] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionWithAddOns: async (body: Array<Subscription>, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, migrated?: boolean, renameKeyIfExistsAndUnused?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSubscriptionWithAddOns.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createSubscriptionWithAddOns.');
            }
            const localVarPath = `/1.0/kb/subscriptions/createSubscriptionWithAddOns`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (entitlementDate !== undefined) {
                localVarQueryParameter['entitlementDate'] = (entitlementDate as any instanceof Date) ?
                    (entitlementDate as any).toISOString().substr(0,10) :
                    entitlementDate;
            }

            if (billingDate !== undefined) {
                localVarQueryParameter['billingDate'] = (billingDate as any instanceof Date) ?
                    (billingDate as any).toISOString().substr(0,10) :
                    billingDate;
            }

            if (migrated !== undefined) {
                localVarQueryParameter['migrated'] = migrated;
            }

            if (renameKeyIfExistsAndUnused !== undefined) {
                localVarQueryParameter['renameKeyIfExistsAndUnused'] = renameKeyIfExistsAndUnused;
            }

            if (callCompletion !== undefined) {
                localVarQueryParameter['callCompletion'] = callCompletion;
            }

            if (callTimeoutSec !== undefined) {
                localVarQueryParameter['callTimeoutSec'] = callTimeoutSec;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create multiple entitlements with addOn products
         * @param {Array<BulkSubscriptionsBundle>} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [entitlementDate] 
         * @param {string} [billingDate] 
         * @param {boolean} [renameKeyIfExistsAndUnused] 
         * @param {boolean} [migrated] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionsWithAddOns: async (body: Array<BulkSubscriptionsBundle>, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, renameKeyIfExistsAndUnused?: boolean, migrated?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSubscriptionsWithAddOns.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createSubscriptionsWithAddOns.');
            }
            const localVarPath = `/1.0/kb/subscriptions/createSubscriptionsWithAddOns`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (entitlementDate !== undefined) {
                localVarQueryParameter['entitlementDate'] = (entitlementDate as any instanceof Date) ?
                    (entitlementDate as any).toISOString().substr(0,10) :
                    entitlementDate;
            }

            if (billingDate !== undefined) {
                localVarQueryParameter['billingDate'] = (billingDate as any instanceof Date) ?
                    (billingDate as any).toISOString().substr(0,10) :
                    billingDate;
            }

            if (renameKeyIfExistsAndUnused !== undefined) {
                localVarQueryParameter['renameKeyIfExistsAndUnused'] = renameKeyIfExistsAndUnused;
            }

            if (migrated !== undefined) {
                localVarQueryParameter['migrated'] = migrated;
            }

            if (callCompletion !== undefined) {
                localVarQueryParameter['callCompletion'] = callCompletion;
            }

            if (callTimeoutSec !== undefined) {
                localVarQueryParameter['callTimeoutSec'] = callTimeoutSec;
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove custom fields from subscription
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionCustomFields: async (subscriptionId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling deleteSubscriptionCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deleteSubscriptionCustomFields.');
            }
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/customFields`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove tags from subscription
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionTags: async (subscriptionId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling deleteSubscriptionTags.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deleteSubscriptionTags.');
            }
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/tags`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a subscription by id
         * @param {string} subscriptionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription: async (subscriptionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling getSubscription.');
            }
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve subscription audit logs with history by id
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionAuditLogsWithHistory: async (subscriptionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling getSubscriptionAuditLogsWithHistory.');
            }
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/auditLogsWithHistory`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a subscription by external key
         * @param {string} externalKey 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionByKey: async (externalKey: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalKey' is not null or undefined
            if (externalKey === null || externalKey === undefined) {
                throw new RequiredError('externalKey','Required parameter externalKey was null or undefined when calling getSubscriptionByKey.');
            }
            const localVarPath = `/1.0/kb/subscriptions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve subscription custom fields
         * @param {string} subscriptionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionCustomFields: async (subscriptionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling getSubscriptionCustomFields.');
            }
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/customFields`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve subscription event audit logs with history by id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionEventAuditLogsWithHistory: async (eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling getSubscriptionEventAuditLogsWithHistory.');
            }
            const localVarPath = `/1.0/kb/subscriptions/events/{eventId}/auditLogsWithHistory`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve subscription tags
         * @param {string} subscriptionId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTags: async (subscriptionId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling getSubscriptionTags.');
            }
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/tags`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify custom fields to subscription
         * @param {Array<CustomField>} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionCustomFields: async (body: Array<CustomField>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling modifySubscriptionCustomFields.');
            }
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling modifySubscriptionCustomFields.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling modifySubscriptionCustomFields.');
            }
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/customFields`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Un-cancel an entitlement
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uncancelSubscriptionPlan: async (subscriptionId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling uncancelSubscriptionPlan.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling uncancelSubscriptionPlan.');
            }
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/uncancel`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Undo a pending change plan on an entitlement
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undoChangeSubscriptionPlan: async (subscriptionId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling undoChangeSubscriptionPlan.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling undoChangeSubscriptionPlan.');
            }
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/undoChangePlan`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the BCD associated to a subscription
         * @param {Subscription} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [effectiveFromDate] 
         * @param {boolean} [forceNewBcdWithPastEffectiveDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionBCD: async (body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, effectiveFromDate?: string, forceNewBcdWithPastEffectiveDate?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSubscriptionBCD.');
            }
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling updateSubscriptionBCD.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling updateSubscriptionBCD.');
            }
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/bcd`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (effectiveFromDate !== undefined) {
                localVarQueryParameter['effectiveFromDate'] = (effectiveFromDate as any instanceof Date) ?
                    (effectiveFromDate as any).toISOString().substr(0,10) :
                    effectiveFromDate;
            }

            if (forceNewBcdWithPastEffectiveDate !== undefined) {
                localVarQueryParameter['forceNewBcdWithPastEffectiveDate'] = forceNewBcdWithPastEffectiveDate;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionApi - functional programming interface
 * @export
 */
export const SubscriptionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Block a subscription
         * @param {BlockingState} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSubscriptionBlockingState(body: BlockingState, subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlockingState>>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).addSubscriptionBlockingState(body, subscriptionId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Cancel an entitlement plan
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {'IMMEDIATE' | 'END_OF_TERM'} [entitlementPolicy] 
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
         * @param {boolean} [useRequestedDateForBilling] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSubscriptionPlan(subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, callCompletion?: boolean, callTimeoutSec?: number, entitlementPolicy?: 'IMMEDIATE' | 'END_OF_TERM', billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', useRequestedDateForBilling?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).cancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, entitlementPolicy, billingPolicy, useRequestedDateForBilling, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Change entitlement plan
         * @param {Subscription} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeSubscriptionPlan(body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, callCompletion?: boolean, callTimeoutSec?: number, billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).changeSubscriptionPlan(body, subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, billingPolicy, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create an subscription
         * @param {Subscription} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [entitlementDate] 
         * @param {string} [billingDate] 
         * @param {boolean} [renameKeyIfExistsAndUnused] 
         * @param {boolean} [migrated] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscription(body: Subscription, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, renameKeyIfExistsAndUnused?: boolean, migrated?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).createSubscription(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add custom fields to subscription
         * @param {Array<CustomField>} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscriptionCustomFields(body: Array<CustomField>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).createSubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Array<string>} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscriptionTags(body: Array<string>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).createSubscriptionTags(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create an entitlement with addOn products
         * @param {Array<Subscription>} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [entitlementDate] 
         * @param {string} [billingDate] 
         * @param {boolean} [migrated] 
         * @param {boolean} [renameKeyIfExistsAndUnused] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscriptionWithAddOns(body: Array<Subscription>, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, migrated?: boolean, renameKeyIfExistsAndUnused?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bundle>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).createSubscriptionWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, migrated, renameKeyIfExistsAndUnused, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create multiple entitlements with addOn products
         * @param {Array<BulkSubscriptionsBundle>} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [entitlementDate] 
         * @param {string} [billingDate] 
         * @param {boolean} [renameKeyIfExistsAndUnused] 
         * @param {boolean} [migrated] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscriptionsWithAddOns(body: Array<BulkSubscriptionsBundle>, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, renameKeyIfExistsAndUnused?: boolean, migrated?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bundle>>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).createSubscriptionsWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove custom fields from subscription
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubscriptionCustomFields(subscriptionId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).deleteSubscriptionCustomFields(subscriptionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Remove tags from subscription
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubscriptionTags(subscriptionId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).deleteSubscriptionTags(subscriptionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a subscription by id
         * @param {string} subscriptionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscription(subscriptionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).getSubscription(subscriptionId, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve subscription audit logs with history by id
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionAuditLogsWithHistory(subscriptionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).getSubscriptionAuditLogsWithHistory(subscriptionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a subscription by external key
         * @param {string} externalKey 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionByKey(externalKey: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Subscription>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).getSubscriptionByKey(externalKey, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve subscription custom fields
         * @param {string} subscriptionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionCustomFields(subscriptionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomField>>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).getSubscriptionCustomFields(subscriptionId, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve subscription event audit logs with history by id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionEventAuditLogsWithHistory(eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).getSubscriptionEventAuditLogsWithHistory(eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve subscription tags
         * @param {string} subscriptionId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionTags(subscriptionId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).getSubscriptionTags(subscriptionId, includedDeleted, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify custom fields to subscription
         * @param {Array<CustomField>} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifySubscriptionCustomFields(body: Array<CustomField>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).modifySubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Un-cancel an entitlement
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uncancelSubscriptionPlan(subscriptionId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).uncancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Undo a pending change plan on an entitlement
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async undoChangeSubscriptionPlan(subscriptionId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).undoChangeSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update the BCD associated to a subscription
         * @param {Subscription} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [effectiveFromDate] 
         * @param {boolean} [forceNewBcdWithPastEffectiveDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscriptionBCD(body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, effectiveFromDate?: string, forceNewBcdWithPastEffectiveDate?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubscriptionApiAxiosParamCreator(configuration).updateSubscriptionBCD(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewBcdWithPastEffectiveDate, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SubscriptionApi - factory interface
 * @export
 */
export const SubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Block a subscription
         * @param {BlockingState} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscriptionBlockingState(body: BlockingState, subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<BlockingState>> {
            return SubscriptionApiFp(configuration).addSubscriptionBlockingState(body, subscriptionId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel an entitlement plan
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {'IMMEDIATE' | 'END_OF_TERM'} [entitlementPolicy] 
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
         * @param {boolean} [useRequestedDateForBilling] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscriptionPlan(subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, callCompletion?: boolean, callTimeoutSec?: number, entitlementPolicy?: 'IMMEDIATE' | 'END_OF_TERM', billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', useRequestedDateForBilling?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return SubscriptionApiFp(configuration).cancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, entitlementPolicy, billingPolicy, useRequestedDateForBilling, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change entitlement plan
         * @param {Subscription} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [requestedDate] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscriptionPlan(body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, callCompletion?: boolean, callTimeoutSec?: number, billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return SubscriptionApiFp(configuration).changeSubscriptionPlan(body, subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, billingPolicy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an subscription
         * @param {Subscription} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [entitlementDate] 
         * @param {string} [billingDate] 
         * @param {boolean} [renameKeyIfExistsAndUnused] 
         * @param {boolean} [migrated] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(body: Subscription, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, renameKeyIfExistsAndUnused?: boolean, migrated?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Subscription> {
            return SubscriptionApiFp(configuration).createSubscription(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add custom fields to subscription
         * @param {Array<CustomField>} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionCustomFields(body: Array<CustomField>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return SubscriptionApiFp(configuration).createSubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionTags(body: Array<string>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return SubscriptionApiFp(configuration).createSubscriptionTags(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an entitlement with addOn products
         * @param {Array<Subscription>} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [entitlementDate] 
         * @param {string} [billingDate] 
         * @param {boolean} [migrated] 
         * @param {boolean} [renameKeyIfExistsAndUnused] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionWithAddOns(body: Array<Subscription>, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, migrated?: boolean, renameKeyIfExistsAndUnused?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Bundle> {
            return SubscriptionApiFp(configuration).createSubscriptionWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, migrated, renameKeyIfExistsAndUnused, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create multiple entitlements with addOn products
         * @param {Array<BulkSubscriptionsBundle>} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [entitlementDate] 
         * @param {string} [billingDate] 
         * @param {boolean} [renameKeyIfExistsAndUnused] 
         * @param {boolean} [migrated] 
         * @param {boolean} [callCompletion] 
         * @param {number} [callTimeoutSec] 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionsWithAddOns(body: Array<BulkSubscriptionsBundle>, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, renameKeyIfExistsAndUnused?: boolean, migrated?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Array<Bundle>> {
            return SubscriptionApiFp(configuration).createSubscriptionsWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove custom fields from subscription
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [customField] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionCustomFields(subscriptionId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return SubscriptionApiFp(configuration).deleteSubscriptionCustomFields(subscriptionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove tags from subscription
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [tagDef] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionTags(subscriptionId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return SubscriptionApiFp(configuration).deleteSubscriptionTags(subscriptionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a subscription by id
         * @param {string} subscriptionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(subscriptionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Subscription> {
            return SubscriptionApiFp(configuration).getSubscription(subscriptionId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve subscription audit logs with history by id
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionAuditLogsWithHistory(subscriptionId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return SubscriptionApiFp(configuration).getSubscriptionAuditLogsWithHistory(subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a subscription by external key
         * @param {string} externalKey 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionByKey(externalKey: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Subscription> {
            return SubscriptionApiFp(configuration).getSubscriptionByKey(externalKey, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve subscription custom fields
         * @param {string} subscriptionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionCustomFields(subscriptionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<CustomField>> {
            return SubscriptionApiFp(configuration).getSubscriptionCustomFields(subscriptionId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve subscription event audit logs with history by id
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionEventAuditLogsWithHistory(eventId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return SubscriptionApiFp(configuration).getSubscriptionEventAuditLogsWithHistory(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve subscription tags
         * @param {string} subscriptionId 
         * @param {boolean} [includedDeleted] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTags(subscriptionId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return SubscriptionApiFp(configuration).getSubscriptionTags(subscriptionId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify custom fields to subscription
         * @param {Array<CustomField>} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionCustomFields(body: Array<CustomField>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return SubscriptionApiFp(configuration).modifySubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Un-cancel an entitlement
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uncancelSubscriptionPlan(subscriptionId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return SubscriptionApiFp(configuration).uncancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Undo a pending change plan on an entitlement
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {Array<string>} [pluginProperty] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undoChangeSubscriptionPlan(subscriptionId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return SubscriptionApiFp(configuration).undoChangeSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the BCD associated to a subscription
         * @param {Subscription} body 
         * @param {string} subscriptionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [effectiveFromDate] 
         * @param {boolean} [forceNewBcdWithPastEffectiveDate] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionBCD(body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, effectiveFromDate?: string, forceNewBcdWithPastEffectiveDate?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return SubscriptionApiFp(configuration).updateSubscriptionBCD(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewBcdWithPastEffectiveDate, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionApi - object-oriented interface
 * @export
 * @class SubscriptionApi
 * @extends {BaseAPI}
 */
export class SubscriptionApi extends BaseAPI {
    /**
     * 
     * @summary Block a subscription
     * @param {BlockingState} body 
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public addSubscriptionBlockingState(body: BlockingState, subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SubscriptionApiFp(this.configuration).addSubscriptionBlockingState(body, subscriptionId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel an entitlement plan
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {boolean} [callCompletion] 
     * @param {number} [callTimeoutSec] 
     * @param {'IMMEDIATE' | 'END_OF_TERM'} [entitlementPolicy] 
     * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
     * @param {boolean} [useRequestedDateForBilling] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public cancelSubscriptionPlan(subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, callCompletion?: boolean, callTimeoutSec?: number, entitlementPolicy?: 'IMMEDIATE' | 'END_OF_TERM', billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', useRequestedDateForBilling?: boolean, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SubscriptionApiFp(this.configuration).cancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, entitlementPolicy, billingPolicy, useRequestedDateForBilling, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change entitlement plan
     * @param {Subscription} body 
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [requestedDate] 
     * @param {boolean} [callCompletion] 
     * @param {number} [callTimeoutSec] 
     * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public changeSubscriptionPlan(body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, requestedDate?: string, callCompletion?: boolean, callTimeoutSec?: number, billingPolicy?: 'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL', pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SubscriptionApiFp(this.configuration).changeSubscriptionPlan(body, subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, billingPolicy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an subscription
     * @param {Subscription} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [entitlementDate] 
     * @param {string} [billingDate] 
     * @param {boolean} [renameKeyIfExistsAndUnused] 
     * @param {boolean} [migrated] 
     * @param {boolean} [callCompletion] 
     * @param {number} [callTimeoutSec] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public createSubscription(body: Subscription, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, renameKeyIfExistsAndUnused?: boolean, migrated?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SubscriptionApiFp(this.configuration).createSubscription(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add custom fields to subscription
     * @param {Array<CustomField>} body 
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public createSubscriptionCustomFields(body: Array<CustomField>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SubscriptionApiFp(this.configuration).createSubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} body 
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public createSubscriptionTags(body: Array<string>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SubscriptionApiFp(this.configuration).createSubscriptionTags(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an entitlement with addOn products
     * @param {Array<Subscription>} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [entitlementDate] 
     * @param {string} [billingDate] 
     * @param {boolean} [migrated] 
     * @param {boolean} [renameKeyIfExistsAndUnused] 
     * @param {boolean} [callCompletion] 
     * @param {number} [callTimeoutSec] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public createSubscriptionWithAddOns(body: Array<Subscription>, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, migrated?: boolean, renameKeyIfExistsAndUnused?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SubscriptionApiFp(this.configuration).createSubscriptionWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, migrated, renameKeyIfExistsAndUnused, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create multiple entitlements with addOn products
     * @param {Array<BulkSubscriptionsBundle>} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [entitlementDate] 
     * @param {string} [billingDate] 
     * @param {boolean} [renameKeyIfExistsAndUnused] 
     * @param {boolean} [migrated] 
     * @param {boolean} [callCompletion] 
     * @param {number} [callTimeoutSec] 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public createSubscriptionsWithAddOns(body: Array<BulkSubscriptionsBundle>, xKillbillCreatedBy: string, entitlementDate?: string, billingDate?: string, renameKeyIfExistsAndUnused?: boolean, migrated?: boolean, callCompletion?: boolean, callTimeoutSec?: number, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SubscriptionApiFp(this.configuration).createSubscriptionsWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove custom fields from subscription
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [customField] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public deleteSubscriptionCustomFields(subscriptionId: string, xKillbillCreatedBy: string, customField?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SubscriptionApiFp(this.configuration).deleteSubscriptionCustomFields(subscriptionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove tags from subscription
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [tagDef] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public deleteSubscriptionTags(subscriptionId: string, xKillbillCreatedBy: string, tagDef?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SubscriptionApiFp(this.configuration).deleteSubscriptionTags(subscriptionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a subscription by id
     * @param {string} subscriptionId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getSubscription(subscriptionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return SubscriptionApiFp(this.configuration).getSubscription(subscriptionId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve subscription audit logs with history by id
     * @param {string} subscriptionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getSubscriptionAuditLogsWithHistory(subscriptionId: string, options?: any) {
        return SubscriptionApiFp(this.configuration).getSubscriptionAuditLogsWithHistory(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a subscription by external key
     * @param {string} externalKey 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getSubscriptionByKey(externalKey: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return SubscriptionApiFp(this.configuration).getSubscriptionByKey(externalKey, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve subscription custom fields
     * @param {string} subscriptionId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getSubscriptionCustomFields(subscriptionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return SubscriptionApiFp(this.configuration).getSubscriptionCustomFields(subscriptionId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve subscription event audit logs with history by id
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getSubscriptionEventAuditLogsWithHistory(eventId: string, options?: any) {
        return SubscriptionApiFp(this.configuration).getSubscriptionEventAuditLogsWithHistory(eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve subscription tags
     * @param {string} subscriptionId 
     * @param {boolean} [includedDeleted] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getSubscriptionTags(subscriptionId: string, includedDeleted?: boolean, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return SubscriptionApiFp(this.configuration).getSubscriptionTags(subscriptionId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify custom fields to subscription
     * @param {Array<CustomField>} body 
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public modifySubscriptionCustomFields(body: Array<CustomField>, subscriptionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SubscriptionApiFp(this.configuration).modifySubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Un-cancel an entitlement
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public uncancelSubscriptionPlan(subscriptionId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SubscriptionApiFp(this.configuration).uncancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Undo a pending change plan on an entitlement
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {Array<string>} [pluginProperty] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public undoChangeSubscriptionPlan(subscriptionId: string, xKillbillCreatedBy: string, pluginProperty?: Array<string>, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SubscriptionApiFp(this.configuration).undoChangeSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the BCD associated to a subscription
     * @param {Subscription} body 
     * @param {string} subscriptionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [effectiveFromDate] 
     * @param {boolean} [forceNewBcdWithPastEffectiveDate] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public updateSubscriptionBCD(body: Subscription, subscriptionId: string, xKillbillCreatedBy: string, effectiveFromDate?: string, forceNewBcdWithPastEffectiveDate?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return SubscriptionApiFp(this.configuration).updateSubscriptionBCD(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewBcdWithPastEffectiveDate, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TagApi - axios parameter creator
 * @export
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve tag audit logs with history by id
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagAuditLogsWithHistory: async (tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling getTagAuditLogsWithHistory.');
            }
            const localVarPath = `/1.0/kb/tags/{tagId}/auditLogsWithHistory`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tags
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/tags/pagination`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search tags
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTags: async (searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKey' is not null or undefined
            if (searchKey === null || searchKey === undefined) {
                throw new RequiredError('searchKey','Required parameter searchKey was null or undefined when calling searchTags.');
            }
            const localVarPath = `/1.0/kb/tags/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 * @export
 */
export const TagApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve tag audit logs with history by id
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagAuditLogsWithHistory(tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await TagApiAxiosParamCreator(configuration).getTagAuditLogsWithHistory(tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List tags
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await TagApiAxiosParamCreator(configuration).getTags(offset, limit, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Search tags
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTags(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await TagApiAxiosParamCreator(configuration).searchTags(searchKey, offset, limit, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagApi - factory interface
 * @export
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Retrieve tag audit logs with history by id
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagAuditLogsWithHistory(tagId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return TagApiFp(configuration).getTagAuditLogsWithHistory(tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tags
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return TagApiFp(configuration).getTags(offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search tags
         * @param {string} searchKey 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTags(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<Tag>> {
            return TagApiFp(configuration).searchTags(searchKey, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagApi - object-oriented interface
 * @export
 * @class TagApi
 * @extends {BaseAPI}
 */
export class TagApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve tag audit logs with history by id
     * @param {string} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public getTagAuditLogsWithHistory(tagId: string, options?: any) {
        return TagApiFp(this.configuration).getTagAuditLogsWithHistory(tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tags
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public getTags(offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return TagApiFp(this.configuration).getTags(offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search tags
     * @param {string} searchKey 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public searchTags(searchKey: string, offset?: number, limit?: number, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return TagApiFp(this.configuration).searchTags(searchKey, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TagDefinitionApi - axios parameter creator
 * @export
 */
export const TagDefinitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a tag definition
         * @param {TagDefinition} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTagDefinition: async (body: TagDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTagDefinition.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createTagDefinition.');
            }
            const localVarPath = `/1.0/kb/tagDefinitions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a tag definition
         * @param {string} tagDefinitionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagDefinition: async (tagDefinitionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagDefinitionId' is not null or undefined
            if (tagDefinitionId === null || tagDefinitionId === undefined) {
                throw new RequiredError('tagDefinitionId','Required parameter tagDefinitionId was null or undefined when calling deleteTagDefinition.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deleteTagDefinition.');
            }
            const localVarPath = `/1.0/kb/tagDefinitions/{tagDefinitionId}`
                .replace(`{${"tagDefinitionId"}}`, encodeURIComponent(String(tagDefinitionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a tag definition
         * @param {string} tagDefinitionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinition: async (tagDefinitionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagDefinitionId' is not null or undefined
            if (tagDefinitionId === null || tagDefinitionId === undefined) {
                throw new RequiredError('tagDefinitionId','Required parameter tagDefinitionId was null or undefined when calling getTagDefinition.');
            }
            const localVarPath = `/1.0/kb/tagDefinitions/{tagDefinitionId}`
                .replace(`{${"tagDefinitionId"}}`, encodeURIComponent(String(tagDefinitionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve tag definition audit logs with history by id
         * @param {string} tagDefinitionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinitionAuditLogsWithHistory: async (tagDefinitionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagDefinitionId' is not null or undefined
            if (tagDefinitionId === null || tagDefinitionId === undefined) {
                throw new RequiredError('tagDefinitionId','Required parameter tagDefinitionId was null or undefined when calling getTagDefinitionAuditLogsWithHistory.');
            }
            const localVarPath = `/1.0/kb/tagDefinitions/{tagDefinitionId}/auditLogsWithHistory`
                .replace(`{${"tagDefinitionId"}}`, encodeURIComponent(String(tagDefinitionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List tag definitions
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinitions: async (audit?: 'FULL' | 'MINIMAL' | 'NONE', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/tagDefinitions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagDefinitionApi - functional programming interface
 * @export
 */
export const TagDefinitionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a tag definition
         * @param {TagDefinition} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTagDefinition(body: TagDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagDefinition>> {
            const localVarAxiosArgs = await TagDefinitionApiAxiosParamCreator(configuration).createTagDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a tag definition
         * @param {string} tagDefinitionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTagDefinition(tagDefinitionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TagDefinitionApiAxiosParamCreator(configuration).deleteTagDefinition(tagDefinitionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a tag definition
         * @param {string} tagDefinitionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagDefinition(tagDefinitionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagDefinition>> {
            const localVarAxiosArgs = await TagDefinitionApiAxiosParamCreator(configuration).getTagDefinition(tagDefinitionId, audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve tag definition audit logs with history by id
         * @param {string} tagDefinitionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagDefinitionAuditLogsWithHistory(tagDefinitionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLog>>> {
            const localVarAxiosArgs = await TagDefinitionApiAxiosParamCreator(configuration).getTagDefinitionAuditLogsWithHistory(tagDefinitionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List tag definitions
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagDefinitions(audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagDefinition>>> {
            const localVarAxiosArgs = await TagDefinitionApiAxiosParamCreator(configuration).getTagDefinitions(audit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagDefinitionApi - factory interface
 * @export
 */
export const TagDefinitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a tag definition
         * @param {TagDefinition} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTagDefinition(body: TagDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<TagDefinition> {
            return TagDefinitionApiFp(configuration).createTagDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a tag definition
         * @param {string} tagDefinitionId 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagDefinition(tagDefinitionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return TagDefinitionApiFp(configuration).deleteTagDefinition(tagDefinitionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a tag definition
         * @param {string} tagDefinitionId 
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinition(tagDefinitionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<TagDefinition> {
            return TagDefinitionApiFp(configuration).getTagDefinition(tagDefinitionId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve tag definition audit logs with history by id
         * @param {string} tagDefinitionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinitionAuditLogsWithHistory(tagDefinitionId: string, options?: any): AxiosPromise<Array<AuditLog>> {
            return TagDefinitionApiFp(configuration).getTagDefinitionAuditLogsWithHistory(tagDefinitionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List tag definitions
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinitions(audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any): AxiosPromise<Array<TagDefinition>> {
            return TagDefinitionApiFp(configuration).getTagDefinitions(audit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagDefinitionApi - object-oriented interface
 * @export
 * @class TagDefinitionApi
 * @extends {BaseAPI}
 */
export class TagDefinitionApi extends BaseAPI {
    /**
     * 
     * @summary Create a tag definition
     * @param {TagDefinition} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagDefinitionApi
     */
    public createTagDefinition(body: TagDefinition, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return TagDefinitionApiFp(this.configuration).createTagDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a tag definition
     * @param {string} tagDefinitionId 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagDefinitionApi
     */
    public deleteTagDefinition(tagDefinitionId: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return TagDefinitionApiFp(this.configuration).deleteTagDefinition(tagDefinitionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a tag definition
     * @param {string} tagDefinitionId 
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagDefinitionApi
     */
    public getTagDefinition(tagDefinitionId: string, audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return TagDefinitionApiFp(this.configuration).getTagDefinition(tagDefinitionId, audit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve tag definition audit logs with history by id
     * @param {string} tagDefinitionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagDefinitionApi
     */
    public getTagDefinitionAuditLogsWithHistory(tagDefinitionId: string, options?: any) {
        return TagDefinitionApiFp(this.configuration).getTagDefinitionAuditLogsWithHistory(tagDefinitionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List tag definitions
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagDefinitionApi
     */
    public getTagDefinitions(audit?: 'FULL' | 'MINIMAL' | 'NONE', options?: any) {
        return TagDefinitionApiFp(this.configuration).getTagDefinitions(audit, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TenantApi - axios parameter creator
 * @export
 */
export const TenantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a tenant
         * @param {Tenant} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [useGlobalDefault] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenant: async (body: Tenant, xKillbillCreatedBy: string, useGlobalDefault?: boolean, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTenant.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling createTenant.');
            }
            const localVarPath = `/1.0/kb/tenants`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (useGlobalDefault !== undefined) {
                localVarQueryParameter['useGlobalDefault'] = useGlobalDefault;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a per tenant configuration (system properties)
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerTenantConfiguration: async (xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deletePerTenantConfiguration.');
            }
            const localVarPath = `/1.0/kb/tenants/uploadPerTenantConfig`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a per tenant configuration for a plugin
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePluginConfiguration: async (pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginName' is not null or undefined
            if (pluginName === null || pluginName === undefined) {
                throw new RequiredError('pluginName','Required parameter pluginName was null or undefined when calling deletePluginConfiguration.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deletePluginConfiguration.');
            }
            const localVarPath = `/1.0/kb/tenants/uploadPluginConfig/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a per tenant payment state machine for a plugin
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePluginPaymentStateMachineConfig: async (pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginName' is not null or undefined
            if (pluginName === null || pluginName === undefined) {
                throw new RequiredError('pluginName','Required parameter pluginName was null or undefined when calling deletePluginPaymentStateMachineConfig.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deletePluginPaymentStateMachineConfig.');
            }
            const localVarPath = `/1.0/kb/tenants/uploadPluginPaymentStateMachineConfig/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a push notification
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePushNotificationCallbacks: async (xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deletePushNotificationCallbacks.');
            }
            const localVarPath = `/1.0/kb/tenants/registerNotificationCallback`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete  a per tenant user key/value
         * @param {string} keyName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKeyValue: async (keyName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyName' is not null or undefined
            if (keyName === null || keyName === undefined) {
                throw new RequiredError('keyName','Required parameter keyName was null or undefined when calling deleteUserKeyValue.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling deleteUserKeyValue.');
            }
            const localVarPath = `/1.0/kb/tenants/userKeyValue/{keyName}`
                .replace(`{${"keyName"}}`, encodeURIComponent(String(keyName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a per tenant key value based on key prefix
         * @param {string} keyPrefix 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPluginConfiguration: async (keyPrefix: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyPrefix' is not null or undefined
            if (keyPrefix === null || keyPrefix === undefined) {
                throw new RequiredError('keyPrefix','Required parameter keyPrefix was null or undefined when calling getAllPluginConfiguration.');
            }
            const localVarPath = `/1.0/kb/tenants/uploadPerTenantConfig/{keyPrefix}/search`
                .replace(`{${"keyPrefix"}}`, encodeURIComponent(String(keyPrefix)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a per tenant configuration (system properties)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerTenantConfiguration: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/tenants/uploadPerTenantConfig`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a per tenant configuration for a plugin
         * @param {string} pluginName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginConfiguration: async (pluginName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginName' is not null or undefined
            if (pluginName === null || pluginName === undefined) {
                throw new RequiredError('pluginName','Required parameter pluginName was null or undefined when calling getPluginConfiguration.');
            }
            const localVarPath = `/1.0/kb/tenants/uploadPluginConfig/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a per tenant payment state machine for a plugin
         * @param {string} pluginName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginPaymentStateMachineConfig: async (pluginName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginName' is not null or undefined
            if (pluginName === null || pluginName === undefined) {
                throw new RequiredError('pluginName','Required parameter pluginName was null or undefined when calling getPluginPaymentStateMachineConfig.');
            }
            const localVarPath = `/1.0/kb/tenants/uploadPluginPaymentStateMachineConfig/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a push notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushNotificationCallbacks: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/tenants/registerNotificationCallback`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a tenant by id
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenant: async (tenantId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getTenant.');
            }
            const localVarPath = `/1.0/kb/tenants/{tenantId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a tenant by its API key
         * @param {string} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantByApiKey: async (apiKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/1.0/kb/tenants`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a per tenant user key/value
         * @param {string} keyName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserKeyValue: async (keyName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyName' is not null or undefined
            if (keyName === null || keyName === undefined) {
                throw new RequiredError('keyName','Required parameter keyName was null or undefined when calling getUserKeyValue.');
            }
            const localVarPath = `/1.0/kb/tenants/userKeyValue/{keyName}`
                .replace(`{${"keyName"}}`, encodeURIComponent(String(keyName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a per tenant user key/value
         * @param {string} body 
         * @param {string} keyName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertUserKeyValue: async (body: string, keyName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling insertUserKeyValue.');
            }
            // verify required parameter 'keyName' is not null or undefined
            if (keyName === null || keyName === undefined) {
                throw new RequiredError('keyName','Required parameter keyName was null or undefined when calling insertUserKeyValue.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling insertUserKeyValue.');
            }
            const localVarPath = `/1.0/kb/tenants/userKeyValue/{keyName}`
                .replace(`{${"keyName"}}`, encodeURIComponent(String(keyName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a push notification
         * @param {string} xKillbillCreatedBy 
         * @param {string} [cb] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPushNotificationCallback: async (xKillbillCreatedBy: string, cb?: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling registerPushNotificationCallback.');
            }
            const localVarPath = `/1.0/kb/tenants/registerNotificationCallback`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (cb !== undefined) {
                localVarQueryParameter['cb'] = cb;
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a per tenant configuration (system properties)
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPerTenantConfiguration: async (body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadPerTenantConfiguration.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling uploadPerTenantConfiguration.');
            }
            const localVarPath = `/1.0/kb/tenants/uploadPerTenantConfig`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a per tenant configuration for a plugin
         * @param {string} body 
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPluginConfiguration: async (body: string, pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadPluginConfiguration.');
            }
            // verify required parameter 'pluginName' is not null or undefined
            if (pluginName === null || pluginName === undefined) {
                throw new RequiredError('pluginName','Required parameter pluginName was null or undefined when calling uploadPluginConfiguration.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling uploadPluginConfiguration.');
            }
            const localVarPath = `/1.0/kb/tenants/uploadPluginConfig/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a per tenant payment state machine for a plugin
         * @param {string} body 
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPluginPaymentStateMachineConfig: async (body: string, pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling uploadPluginPaymentStateMachineConfig.');
            }
            // verify required parameter 'pluginName' is not null or undefined
            if (pluginName === null || pluginName === undefined) {
                throw new RequiredError('pluginName','Required parameter pluginName was null or undefined when calling uploadPluginPaymentStateMachineConfig.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling uploadPluginPaymentStateMachineConfig.');
            }
            const localVarPath = `/1.0/kb/tenants/uploadPluginPaymentStateMachineConfig/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantApi - functional programming interface
 * @export
 */
export const TenantApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a tenant
         * @param {Tenant} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [useGlobalDefault] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTenant(body: Tenant, xKillbillCreatedBy: string, useGlobalDefault?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).createTenant(body, xKillbillCreatedBy, useGlobalDefault, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a per tenant configuration (system properties)
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePerTenantConfiguration(xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).deletePerTenantConfiguration(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a per tenant configuration for a plugin
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePluginConfiguration(pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).deletePluginConfiguration(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a per tenant payment state machine for a plugin
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePluginPaymentStateMachineConfig(pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).deletePluginPaymentStateMachineConfig(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a push notification
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePushNotificationCallbacks(xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).deletePushNotificationCallbacks(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete  a per tenant user key/value
         * @param {string} keyName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserKeyValue(keyName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).deleteUserKeyValue(keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a per tenant key value based on key prefix
         * @param {string} keyPrefix 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPluginConfiguration(keyPrefix: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).getAllPluginConfiguration(keyPrefix, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a per tenant configuration (system properties)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPerTenantConfiguration(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).getPerTenantConfiguration(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a per tenant configuration for a plugin
         * @param {string} pluginName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPluginConfiguration(pluginName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).getPluginConfiguration(pluginName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a per tenant payment state machine for a plugin
         * @param {string} pluginName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPluginPaymentStateMachineConfig(pluginName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).getPluginPaymentStateMachineConfig(pluginName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a push notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPushNotificationCallbacks(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).getPushNotificationCallbacks(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a tenant by id
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTenant(tenantId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).getTenant(tenantId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a tenant by its API key
         * @param {string} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTenantByApiKey(apiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).getTenantByApiKey(apiKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve a per tenant user key/value
         * @param {string} keyName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserKeyValue(keyName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).getUserKeyValue(keyName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add a per tenant user key/value
         * @param {string} body 
         * @param {string} keyName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertUserKeyValue(body: string, keyName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).insertUserKeyValue(body, keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a push notification
         * @param {string} xKillbillCreatedBy 
         * @param {string} [cb] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerPushNotificationCallback(xKillbillCreatedBy: string, cb?: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).registerPushNotificationCallback(xKillbillCreatedBy, cb, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add a per tenant configuration (system properties)
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPerTenantConfiguration(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).uploadPerTenantConfiguration(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add a per tenant configuration for a plugin
         * @param {string} body 
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPluginConfiguration(body: string, pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).uploadPluginConfiguration(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add a per tenant payment state machine for a plugin
         * @param {string} body 
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPluginPaymentStateMachineConfig(body: string, pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantKeyValue>> {
            const localVarAxiosArgs = await TenantApiAxiosParamCreator(configuration).uploadPluginPaymentStateMachineConfig(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TenantApi - factory interface
 * @export
 */
export const TenantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create a tenant
         * @param {Tenant} body 
         * @param {string} xKillbillCreatedBy 
         * @param {boolean} [useGlobalDefault] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenant(body: Tenant, xKillbillCreatedBy: string, useGlobalDefault?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<Tenant> {
            return TenantApiFp(configuration).createTenant(body, xKillbillCreatedBy, useGlobalDefault, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a per tenant configuration (system properties)
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerTenantConfiguration(xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return TenantApiFp(configuration).deletePerTenantConfiguration(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a per tenant configuration for a plugin
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePluginConfiguration(pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return TenantApiFp(configuration).deletePluginConfiguration(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a per tenant payment state machine for a plugin
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePluginPaymentStateMachineConfig(pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return TenantApiFp(configuration).deletePluginPaymentStateMachineConfig(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a push notification
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePushNotificationCallbacks(xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return TenantApiFp(configuration).deletePushNotificationCallbacks(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete  a per tenant user key/value
         * @param {string} keyName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKeyValue(keyName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return TenantApiFp(configuration).deleteUserKeyValue(keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a per tenant key value based on key prefix
         * @param {string} keyPrefix 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPluginConfiguration(keyPrefix: string, options?: any): AxiosPromise<TenantKeyValue> {
            return TenantApiFp(configuration).getAllPluginConfiguration(keyPrefix, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a per tenant configuration (system properties)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerTenantConfiguration(options?: any): AxiosPromise<TenantKeyValue> {
            return TenantApiFp(configuration).getPerTenantConfiguration(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a per tenant configuration for a plugin
         * @param {string} pluginName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginConfiguration(pluginName: string, options?: any): AxiosPromise<TenantKeyValue> {
            return TenantApiFp(configuration).getPluginConfiguration(pluginName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a per tenant payment state machine for a plugin
         * @param {string} pluginName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginPaymentStateMachineConfig(pluginName: string, options?: any): AxiosPromise<TenantKeyValue> {
            return TenantApiFp(configuration).getPluginPaymentStateMachineConfig(pluginName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a push notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushNotificationCallbacks(options?: any): AxiosPromise<TenantKeyValue> {
            return TenantApiFp(configuration).getPushNotificationCallbacks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a tenant by id
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenant(tenantId: string, options?: any): AxiosPromise<Tenant> {
            return TenantApiFp(configuration).getTenant(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a tenant by its API key
         * @param {string} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantByApiKey(apiKey?: string, options?: any): AxiosPromise<Tenant> {
            return TenantApiFp(configuration).getTenantByApiKey(apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a per tenant user key/value
         * @param {string} keyName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserKeyValue(keyName: string, options?: any): AxiosPromise<TenantKeyValue> {
            return TenantApiFp(configuration).getUserKeyValue(keyName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a per tenant user key/value
         * @param {string} body 
         * @param {string} keyName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertUserKeyValue(body: string, keyName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<TenantKeyValue> {
            return TenantApiFp(configuration).insertUserKeyValue(body, keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a push notification
         * @param {string} xKillbillCreatedBy 
         * @param {string} [cb] 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPushNotificationCallback(xKillbillCreatedBy: string, cb?: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<TenantKeyValue> {
            return TenantApiFp(configuration).registerPushNotificationCallback(xKillbillCreatedBy, cb, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a per tenant configuration (system properties)
         * @param {string} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPerTenantConfiguration(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<TenantKeyValue> {
            return TenantApiFp(configuration).uploadPerTenantConfiguration(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a per tenant configuration for a plugin
         * @param {string} body 
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPluginConfiguration(body: string, pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<TenantKeyValue> {
            return TenantApiFp(configuration).uploadPluginConfiguration(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a per tenant payment state machine for a plugin
         * @param {string} body 
         * @param {string} pluginName 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPluginPaymentStateMachineConfig(body: string, pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<TenantKeyValue> {
            return TenantApiFp(configuration).uploadPluginPaymentStateMachineConfig(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TenantApi - object-oriented interface
 * @export
 * @class TenantApi
 * @extends {BaseAPI}
 */
export class TenantApi extends BaseAPI {
    /**
     * 
     * @summary Create a tenant
     * @param {Tenant} body 
     * @param {string} xKillbillCreatedBy 
     * @param {boolean} [useGlobalDefault] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public createTenant(body: Tenant, xKillbillCreatedBy: string, useGlobalDefault?: boolean, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return TenantApiFp(this.configuration).createTenant(body, xKillbillCreatedBy, useGlobalDefault, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a per tenant configuration (system properties)
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public deletePerTenantConfiguration(xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return TenantApiFp(this.configuration).deletePerTenantConfiguration(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a per tenant configuration for a plugin
     * @param {string} pluginName 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public deletePluginConfiguration(pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return TenantApiFp(this.configuration).deletePluginConfiguration(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a per tenant payment state machine for a plugin
     * @param {string} pluginName 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public deletePluginPaymentStateMachineConfig(pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return TenantApiFp(this.configuration).deletePluginPaymentStateMachineConfig(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a push notification
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public deletePushNotificationCallbacks(xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return TenantApiFp(this.configuration).deletePushNotificationCallbacks(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete  a per tenant user key/value
     * @param {string} keyName 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public deleteUserKeyValue(keyName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return TenantApiFp(this.configuration).deleteUserKeyValue(keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a per tenant key value based on key prefix
     * @param {string} keyPrefix 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getAllPluginConfiguration(keyPrefix: string, options?: any) {
        return TenantApiFp(this.configuration).getAllPluginConfiguration(keyPrefix, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a per tenant configuration (system properties)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getPerTenantConfiguration(options?: any) {
        return TenantApiFp(this.configuration).getPerTenantConfiguration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a per tenant configuration for a plugin
     * @param {string} pluginName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getPluginConfiguration(pluginName: string, options?: any) {
        return TenantApiFp(this.configuration).getPluginConfiguration(pluginName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a per tenant payment state machine for a plugin
     * @param {string} pluginName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getPluginPaymentStateMachineConfig(pluginName: string, options?: any) {
        return TenantApiFp(this.configuration).getPluginPaymentStateMachineConfig(pluginName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a push notification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getPushNotificationCallbacks(options?: any) {
        return TenantApiFp(this.configuration).getPushNotificationCallbacks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a tenant by id
     * @param {string} tenantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getTenant(tenantId: string, options?: any) {
        return TenantApiFp(this.configuration).getTenant(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a tenant by its API key
     * @param {string} [apiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getTenantByApiKey(apiKey?: string, options?: any) {
        return TenantApiFp(this.configuration).getTenantByApiKey(apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a per tenant user key/value
     * @param {string} keyName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getUserKeyValue(keyName: string, options?: any) {
        return TenantApiFp(this.configuration).getUserKeyValue(keyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a per tenant user key/value
     * @param {string} body 
     * @param {string} keyName 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public insertUserKeyValue(body: string, keyName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return TenantApiFp(this.configuration).insertUserKeyValue(body, keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a push notification
     * @param {string} xKillbillCreatedBy 
     * @param {string} [cb] 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public registerPushNotificationCallback(xKillbillCreatedBy: string, cb?: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return TenantApiFp(this.configuration).registerPushNotificationCallback(xKillbillCreatedBy, cb, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a per tenant configuration (system properties)
     * @param {string} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public uploadPerTenantConfiguration(body: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return TenantApiFp(this.configuration).uploadPerTenantConfiguration(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a per tenant configuration for a plugin
     * @param {string} body 
     * @param {string} pluginName 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public uploadPluginConfiguration(body: string, pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return TenantApiFp(this.configuration).uploadPluginConfiguration(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a per tenant payment state machine for a plugin
     * @param {string} body 
     * @param {string} pluginName 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public uploadPluginPaymentStateMachineConfig(body: string, pluginName: string, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return TenantApiFp(this.configuration).uploadPluginPaymentStateMachineConfig(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UsageApi - axios parameter creator
 * @export
 */
export const UsageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve usage for a subscription
         * @param {string} subscriptionId 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsage: async (subscriptionId: string, startDate?: string, endDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling getAllUsage.');
            }
            const localVarPath = `/1.0/kb/usages/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substr(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substr(0,10) :
                    endDate;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve usage for a subscription and unit type
         * @param {string} subscriptionId 
         * @param {string} unitType 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsage: async (subscriptionId: string, unitType: string, startDate?: string, endDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling getUsage.');
            }
            // verify required parameter 'unitType' is not null or undefined
            if (unitType === null || unitType === undefined) {
                throw new RequiredError('unitType','Required parameter unitType was null or undefined when calling getUsage.');
            }
            const localVarPath = `/1.0/kb/usages/{subscriptionId}/{unitType}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)))
                .replace(`{${"unitType"}}`, encodeURIComponent(String(unitType)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substr(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substr(0,10) :
                    endDate;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Record usage for a subscription
         * @param {SubscriptionUsageRecord} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordUsage: async (body: SubscriptionUsageRecord, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling recordUsage.');
            }
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            if (xKillbillCreatedBy === null || xKillbillCreatedBy === undefined) {
                throw new RequiredError('xKillbillCreatedBy','Required parameter xKillbillCreatedBy was null or undefined when calling recordUsage.');
            }
            const localVarPath = `/1.0/kb/usages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Killbill Api Key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiKey")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiKey"] = localVarApiKeyValue;
            }

            // authentication Killbill Api Secret required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Killbill-ApiSecret")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Killbill-ApiSecret"] = localVarApiKeyValue;
            }

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            if (xKillbillCreatedBy !== undefined && xKillbillCreatedBy !== null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }

            if (xKillbillReason !== undefined && xKillbillReason !== null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }

            if (xKillbillComment !== undefined && xKillbillComment !== null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageApi - functional programming interface
 * @export
 */
export const UsageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve usage for a subscription
         * @param {string} subscriptionId 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsage(subscriptionId: string, startDate?: string, endDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolledUpUsage>> {
            const localVarAxiosArgs = await UsageApiAxiosParamCreator(configuration).getAllUsage(subscriptionId, startDate, endDate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Retrieve usage for a subscription and unit type
         * @param {string} subscriptionId 
         * @param {string} unitType 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsage(subscriptionId: string, unitType: string, startDate?: string, endDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolledUpUsage>> {
            const localVarAxiosArgs = await UsageApiAxiosParamCreator(configuration).getUsage(subscriptionId, unitType, startDate, endDate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Record usage for a subscription
         * @param {SubscriptionUsageRecord} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordUsage(body: SubscriptionUsageRecord, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsageApiAxiosParamCreator(configuration).recordUsage(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsageApi - factory interface
 * @export
 */
export const UsageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Retrieve usage for a subscription
         * @param {string} subscriptionId 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsage(subscriptionId: string, startDate?: string, endDate?: string, options?: any): AxiosPromise<RolledUpUsage> {
            return UsageApiFp(configuration).getAllUsage(subscriptionId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve usage for a subscription and unit type
         * @param {string} subscriptionId 
         * @param {string} unitType 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsage(subscriptionId: string, unitType: string, startDate?: string, endDate?: string, options?: any): AxiosPromise<RolledUpUsage> {
            return UsageApiFp(configuration).getUsage(subscriptionId, unitType, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Record usage for a subscription
         * @param {SubscriptionUsageRecord} body 
         * @param {string} xKillbillCreatedBy 
         * @param {string} [xKillbillReason] 
         * @param {string} [xKillbillComment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordUsage(body: SubscriptionUsageRecord, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any): AxiosPromise<void> {
            return UsageApiFp(configuration).recordUsage(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsageApi - object-oriented interface
 * @export
 * @class UsageApi
 * @extends {BaseAPI}
 */
export class UsageApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve usage for a subscription
     * @param {string} subscriptionId 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public getAllUsage(subscriptionId: string, startDate?: string, endDate?: string, options?: any) {
        return UsageApiFp(this.configuration).getAllUsage(subscriptionId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve usage for a subscription and unit type
     * @param {string} subscriptionId 
     * @param {string} unitType 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public getUsage(subscriptionId: string, unitType: string, startDate?: string, endDate?: string, options?: any) {
        return UsageApiFp(this.configuration).getUsage(subscriptionId, unitType, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Record usage for a subscription
     * @param {SubscriptionUsageRecord} body 
     * @param {string} xKillbillCreatedBy 
     * @param {string} [xKillbillReason] 
     * @param {string} [xKillbillComment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    public recordUsage(body: SubscriptionUsageRecord, xKillbillCreatedBy: string, xKillbillReason?: string, xKillbillComment?: string, options?: any) {
        return UsageApiFp(this.configuration).recordUsage(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }

}


